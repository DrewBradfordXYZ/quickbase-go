# CLAUDE.md

This file provides guidance for Claude Code when working with this repository.

## Project Overview

This is the QuickBase Go SDK - a Go client for the QuickBase JSON RESTful API. It mirrors the feature set of [quickbase-js](https://github.com/DrewBradfordXYZ/quickbase-js).

## Architecture

```
quickbase-go/
├── quickbase.go           # Main entry point, re-exports, New() function
├── client/
│   ├── client.go          # HTTP client with auth, retry, rate limiting
│   ├── pagination.go      # Pagination helpers (iterator, collect, fluent API)
│   └── throttle.go        # Rate limiting (SlidingWindowThrottle, NoOpThrottle)
├── auth/
│   ├── strategy.go        # Auth interface
│   ├── user_token.go      # User token auth
│   ├── temp_token.go      # Temporary token auth
│   └── sso_token.go       # SSO/SAML auth
├── core/
│   ├── errors.go          # Error types (RateLimitError, NotFoundError, etc.)
│   ├── dates.go           # ISO date parsing utilities
│   └── logger.go          # Debug logger
├── internal/generated/
│   └── quickbase.gen.go   # Auto-generated from OpenAPI spec (DO NOT EDIT)
├── spec/                  # Git submodule with OpenAPI spec
└── tests/
    └── integration/       # Integration tests (require credentials)
```

## Key Patterns

### Generated Client
The `internal/generated/quickbase.gen.go` file is auto-generated by oapi-codegen from the OpenAPI spec. It contains:
- Request/response types for all endpoints
- `ClientWithResponses` with typed methods like `GetAppWithResponse`, `RunQueryWithResponse`
- Union types using `From*` and `As*` methods (e.g., `FieldValue_Value`)

### Authentication Flow
1. `quickbase.New()` accepts auth options like `WithUserToken()`
2. Creates appropriate `auth.Strategy` implementation
3. `client.Client` uses strategy to add auth headers
4. On 401, strategy can refresh tokens (temp/SSO tokens)

### Request Flow
1. User calls `client.API().SomeMethodWithResponse(ctx, params)`
2. `authHTTPClient.Do()` intercepts the request
3. Applies throttling (waits if rate limited)
4. Adds auth headers via strategy
5. Makes request with retry logic
6. Returns typed response

## Common Commands

```bash
# Run all tests
go test ./...

# Run unit tests only
go test ./core/... ./client/...

# Run integration tests (requires .env)
go test ./tests/integration/... -v

# Build
go build ./...

# Tidy dependencies
go mod tidy

# Regenerate from OpenAPI spec (if spec changes)
go generate ./...
```

## Testing

### Unit Tests
Located in `*_test.go` files alongside source code. Use mocked data.

### Integration Tests
Located in `tests/integration/`. Require real QuickBase credentials:
1. Copy `.env.example` to `.env`
2. Set `QB_REALM` and `QB_USER_TOKEN`
3. Tests create ephemeral apps that are auto-cleaned up

## Working with Generated Types

The generated types can be tricky. Common patterns:

```go
// Creating a record
data := []generated.QuickbaseRecord{
    {
        "6": generated.FieldValue{Value: toFieldValue("text")},
        "7": generated.FieldValue{Value: toFieldValue(42)},
    },
}

// Helper to create FieldValue_Value union
func toFieldValue(v any) generated.FieldValue_Value {
    var fv generated.FieldValue_Value
    switch val := v.(type) {
    case string:
        fv.FromFieldValueValue0(val)
    case int:
        fv.FromFieldValueValue1(float32(val))
    case bool:
        fv.FromFieldValueValue2(val)
    }
    return fv
}
```

## Dependencies

- `github.com/oapi-codegen/runtime` - OpenAPI runtime for generated client
- `github.com/joho/godotenv` - Load .env files for integration tests

## Application Tokens (XML API Only)

Application tokens are an additional security layer for QuickBase apps. When an app has
"Require Application Tokens" enabled, API calls must include a valid app token.

### Key Points

| Auth Method | App Token Required? | Why |
|-------------|---------------------|-----|
| User Token | **No** | User tokens bypass app token checks entirely |
| Temp Token | Only for XML API | JSON API doesn't use app tokens |
| Ticket Auth | Only for XML API | JSON API doesn't use app tokens |
| SSO Token | Only for XML API | JSON API doesn't use app tokens |

### JSON API vs XML API

- **JSON API**: Does not use app tokens. User tokens and temp tokens provide sufficient authentication.
- **XML API**: Uses `<apptoken>` element in request bodies when the app requires them.

The SDK only injects app tokens into XML API requests (via the `xml` sub-package).

### Usage

```go
// For apps requiring application tokens when using ticket auth
client, _ := quickbase.New("myrealm",
    quickbase.WithTicketAuth("user@example.com", "password"),
    quickbase.WithAppToken("your-app-token"),
)

// XML API calls will include the app token
xmlClient := xml.New(client)
roles, _ := xmlClient.GetRoleInfo(ctx, appId)
```

### When You DON'T Need App Tokens

If you're using `WithUserToken()`, you never need to specify an app token - QuickBase
bypasses app token checks for user token authentication.

## Temporary Token Authentication

**This is a key architectural difference between the Go and JS SDKs.**

### The Core Insight
Temp tokens prove a user is logged into QuickBase via their browser session. The benefit is verification - you know the request came from someone actually logged into QuickBase.

### JS SDK (Browser/Code Pages)
The JS SDK can **fetch** temp tokens because it runs in the browser:
```javascript
// In temp-token.ts
const response = await this.fetchApi(url, {
  method: 'GET',
  headers,
  credentials: 'include', // <-- Sends browser cookies!
});
```
- Uses `credentials: 'include'` on the `/auth/temporary/{dbid}` request
- Browser automatically sends QuickBase session cookies
- Works in Code Pages where user is logged into QuickBase
- No user token needed - the browser session IS the auth

### Go SDK (Server-Side)
The Go SDK **receives** pre-existing temp tokens - it cannot fetch them:
- No browser cookies available on server
- Primary use case: receiving tokens from browser clients (e.g., Code Pages)
- Browser fetches tokens using user's QuickBase session, sends via HTTP headers

**Available options:**
- `quickbase.WithTempTokens(map[string]string{"dbid": token})` - Create client with tokens
- `auth.WithInitialTempToken(token)` - Create client with a single token
- `auth.WithInitialTempTokenForTable(token, dbid)` - When you know the table ID
- `strategy.SetToken(dbid, token)` - Add tokens during request lifecycle

### Why use temp tokens over user tokens?
- **Verification**: Proves user is logged into QuickBase right now
- **No credentials storage**: Your server doesn't need to store user tokens
- **Table-scoped**: More restrictive permissions
- **Short-lived**: ~5 minutes, limits damage if leaked

### Why NOT fetch temp tokens with a user token?
You technically CAN call `/auth/temporary/{dbid}` with a user token, but there's no point:
- If you have a user token, just use that directly
- The benefit of temp tokens is proving browser session - if you're using a user token, you've already bypassed that

### Browser-to-Server Token Flow
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  QuickBase  │     │   Browser   │     │  Go Server  │
└─────────────┘     └─────────────┘     └─────────────┘
       │                   │                   │
       │  User opens       │                   │
       │  Code Page        │                   │
       │◄──────────────────│                   │
       │                   │                   │
       │  Browser fetches  │                   │
       │  temp token       │                   │
       │◄─────────────────►│                   │
       │                   │                   │
       │                   │  Request + token  │
       │                   │  (via headers)    │
       │                   │──────────────────►│
       │                   │                   │
       │                   │     API calls     │
       │◄──────────────────┼───────────────────│
       │                   │                   │
```

1. User opens Code Page in QuickBase (logged in)
2. Browser JavaScript fetches temp token using session cookies
3. Browser sends request to Go server with token in header (e.g., X-QB-Token-{dbid})
4. Go server extracts token from header and creates client
5. Go server makes API calls back to QuickBase using that token

### Automatic DBID Extraction

Both the JS and Go SDKs automatically extract the dbid from API requests:
- Query params: `tableId`, `appId`
- Path: `/tables/{tableId}`, `/apps/{appId}`
- Request body: `from` (runQuery, deleteRecords), `to` (upsert)

This means the SDK knows which table you're accessing without explicit configuration.

See `extractDBID()` and `extractDBIDFromBody()` in `client/client.go`.

### Token Negotiation Pattern (Future Enhancement)

Currently, the browser must know which tables it needs tokens for upfront. A better pattern:

**Problem:** Browser doesn't know which tables the Go server will access.

**Solution:** 401 negotiation - server tells browser what tokens it needs.

```
1. Browser sends request to Go server (no tokens)
2. Go server creates client, makes API call
3. SDK returns MissingTokensError with required dbids
4. Go server returns 401 with X-QB-Tables-Needed header
5. Browser fetches those tokens, retries request
```

**Handler pattern (not yet implemented):**

```go
func tempTokenHandler(w http.ResponseWriter, r *http.Request) {
    // Extract whatever tokens the browser sent (header format is user-defined)
    tokens := map[string]string{
        r.Header.Get("X-QB-Table-ID"): r.Header.Get("X-QB-Temp-Token"),
    }

    client, _ := quickbase.New("myrealm", quickbase.WithTempTokens(tokens))

    // Make API call - SDK extracts dbid from request body/path automatically
    _, err := client.RunQuery(ctx, quickbase.RunQueryBody{From: "bqxyz123"})

    // SDK returns structured error with missing dbids
    var missing *quickbase.MissingTokensError
    if errors.As(err, &missing) {
        w.Header().Set("X-QB-Tables-Needed", strings.Join(missing.DBIDs, ","))
        w.WriteHeader(401)
        return
    }

    // Success - return data
}
```

**Key decisions:**
- Header format (how browser sends tokens) is user-defined, not SDK-defined
- SDK provides `MissingTokensError` type for handlers to catch
- One client per request for temp tokens (tokens are user-scoped, short-lived)

**Related:** See `codepage-hypermedia` repo for browser-side handling. The Datastar adapter uses bracket syntax `[bqxyz123]` to pre-fetch tokens, but could fall back to 401 negotiation.

### Auth-Agnostic Handlers

Handlers shouldn't know or care about auth method. The same handler should work with user tokens, temp tokens, tickets, or SSO.

**Solution:** Middleware injects the client into the request context. Handlers just retrieve it.

```go
// Handler is auth-agnostic - doesn't know how client was created
func getRecords(w http.ResponseWriter, r *http.Request) {
    client := getClient(r)  // from context
    records, _ := client.RunQueryAll(r.Context(), body)
    json.NewEncoder(w).Encode(records)
}
```

The middleware varies by auth type:
- **User token / Ticket / SSO**: Returns shared client (created at startup)
- **Temp token**: Creates client per-request with tokens from headers

This keeps handlers simple and testable. The auth complexity lives in middleware.

See `docs/middleware-and-di.md` for a detailed explanation of these patterns.

## Known Design Issues

### Generated Types Strip API Response Data

**Problem:** The oapi-codegen generated types (`GetTableReportsResponse`, etc.) only include fields explicitly defined in the OpenAPI spec. But the actual QuickBase API returns additional useful data that gets lost.

**Example: Get Reports API**

The generated `GetTableReportsWithResponse()` returns typed `Report` objects with:
- `Id`, `Name`, `Type`, `UsedCount`, `UsedLast`

But the raw API response also includes:
- `query.filter` - The report's filter criteria (e.g., `{'6'.EX.'active'}`)
- `query.formulaFields` - Dynamic formula columns
- `properties.columnProperties` - Which fields are displayed as columns

**Workaround in quickbase-mcp-core:**
```go
// Instead of this (loses data):
resp, _ := client.GetTableReports(ctx, params)
reports := resp.JSON200  // Missing query and properties!

// Use raw API (preserves all data):
resp, _ := client.RawGetTableReports(ctx, params)
reports := resp.JSON200  // Has query.filter, properties, etc.
```

**Root Cause:** The OpenAPI spec doesn't fully describe the response schema, or oapi-codegen is configured to strip unknown fields.

**TODO:** Investigate options:
1. Update OpenAPI spec to include all response fields
2. Configure oapi-codegen to preserve extra fields (if possible)
3. Add `Raw*` wrapper methods for commonly-used endpoints
4. Use `map[string]any` for responses where full data is needed

**Affected Endpoints (known):**
- `GET /reports` - Missing `query`, `properties`
- Possibly others - audit as issues arise

**Reference:** This was discovered in quickbase-mcp-core when implementing field-to-report mapping. Reports.json needed query filters to extract which fields each report uses.

---

## Related Repositories

**[quickbase-js](https://github.com/DrewBradfordXYZ/quickbase-js)** - TypeScript/JavaScript SDK
- Same feature set (auth methods, throttling, retry, error types)
- Same test patterns (unit + integration with ephemeral apps)
- Shared OpenAPI spec (git submodule)

**[codepage-go](https://github.com/DrewBradfordXYZ/codepage-go)** - HTTP middleware for this SDK
- Auth-agnostic handlers (same handler works with any auth method)
- Middleware injects QuickBase client into request context
- Token negotiation for temp tokens (401 with X-QB-Tables-Needed header)
- Works with datastar-go for SSE responses

**[codepage-hypermedia](https://github.com/DrewBradfordXYZ/codepage-hypermedia)** - Browser-side companion
- JavaScript client for Code Pages
- Fetches temp tokens using browser session
- Adapters for Datastar, HTMX, Lit

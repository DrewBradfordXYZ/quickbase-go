// Code generated by cmd/generate-builders. DO NOT EDIT.

package client

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"

	"time"

	"github.com/DrewBradfordXYZ/quickbase-go/core"
	"github.com/DrewBradfordXYZ/quickbase-go/internal/generated"

	"github.com/oapi-codegen/runtime/types"

)

// --- Auto-generated builder types ---
// These provide a fluent API for building and executing API requests.
// Method names match QuickBase API operation IDs for consistency with official documentation.

// SortSpec specifies a sort field and order, supporting both field IDs and aliases.
type SortSpec struct {
	Field any                      // Field ID (int) or alias (string)
	Order generated.SortFieldOrder // ASC or DESC
}


// AddManagersToGroupResult contains the result of a addManagersToGroup call.
type AddManagersToGroupResult struct {
	Failure []string
	Success []string
}


// AddManagersToGroupBuilder provides a fluent API for the addManagersToGroup operation.
// Add managers
type AddManagersToGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// AddManagersToGroup starts building a addManagersToGroup request.
func (c *Client) AddManagersToGroup(gid float32) *AddManagersToGroupBuilder {
	b := &AddManagersToGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the addManagersToGroup request.
func (b *AddManagersToGroupBuilder) Run(ctx context.Context) (*AddManagersToGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.AddManagersToGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().AddManagersToGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &AddManagersToGroupResult{}
	result.Failure = resp.JSON200.Failure
	result.Success = resp.JSON200.Success

	return result, nil
}


// AddMembersToGroupResult contains the result of a addMembersToGroup call.
type AddMembersToGroupResult struct {
	Failure []string
	Success []string
}


// AddMembersToGroupBuilder provides a fluent API for the addMembersToGroup operation.
// Add members
type AddMembersToGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// AddMembersToGroup starts building a addMembersToGroup request.
func (c *Client) AddMembersToGroup(gid float32) *AddMembersToGroupBuilder {
	b := &AddMembersToGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the addMembersToGroup request.
func (b *AddMembersToGroupBuilder) Run(ctx context.Context) (*AddMembersToGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.AddMembersToGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().AddMembersToGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &AddMembersToGroupResult{}
	result.Failure = resp.JSON200.Failure
	result.Success = resp.JSON200.Success

	return result, nil
}


// AddSubgroupsToGroupResult contains the result of a addSubgroupsToGroup call.
type AddSubgroupsToGroupResult struct {
	Failure []string
	Success []string
}


// AddSubgroupsToGroupBuilder provides a fluent API for the addSubgroupsToGroup operation.
// Add child groups
type AddSubgroupsToGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// AddSubgroupsToGroup starts building a addSubgroupsToGroup request.
func (c *Client) AddSubgroupsToGroup(gid float32) *AddSubgroupsToGroupBuilder {
	b := &AddSubgroupsToGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the addSubgroupsToGroup request.
func (b *AddSubgroupsToGroupBuilder) Run(ctx context.Context) (*AddSubgroupsToGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.AddSubgroupsToGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().AddSubgroupsToGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &AddSubgroupsToGroupResult{}
	result.Failure = resp.JSON200.Failure
	result.Success = resp.JSON200.Success

	return result, nil
}


// AuditResult contains the result of a audit call.
type AuditResult struct {
	QueryId string
	NextToken string
}


// AuditBuilder provides a fluent API for the audit operation.
// Get audit logs
type AuditBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// Audit starts building a audit request.
func (c *Client) Audit() *AuditBuilder {
	b := &AuditBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Topics An array that may contain up to 20 [topics](https://resources.quickbase.com/nav/app/budurkasx/action/showpage/2b2941e4-f34d-4d41-9b0e-db790d20e9ab?pageIdV2=quickbase.com-DashboardGroup-15760d74-2243-4ce9-9495-7cc8790f12e7) to filter by. If empty, all topics are returned.
func (b *AuditBuilder) Topics(values ...string) *AuditBuilder {
	if b.err != nil {
		return b
	}
	b.params["topics"] = values
	return b
}


// NextToken Token specifying start of page. For first page don't supply this.
func (b *AuditBuilder) NextToken(value string) *AuditBuilder {
	if b.err != nil {
		return b
	}
	b.params["nextToken"] = value
	return b
}


// NumRows Number of logs to return per page, default is 10000, minimum is 1000, max is 50000.
func (b *AuditBuilder) NumRows(value int) *AuditBuilder {
	if b.err != nil {
		return b
	}
	b.params["numRows"] = value
	return b
}


// QueryId The query id of an audit log request. This id is needed to fetch subsequent paged results of a single query.
func (b *AuditBuilder) QueryId(value string) *AuditBuilder {
	if b.err != nil {
		return b
	}
	b.params["queryId"] = value
	return b
}


// Date The date for which audit logs need to be fetched. This must be date-time only, as YYYY-MM-DD, and a valid date in the past.
func (b *AuditBuilder) Date(value string) *AuditBuilder {
	if b.err != nil {
		return b
	}
	b.params["date"] = value
	return b
}



// Run executes the audit request.
func (b *AuditBuilder) Run(ctx context.Context) (*AuditResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.AuditJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().AuditWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &AuditResult{}
	result.QueryId = resp.JSON200.QueryId
	if resp.JSON200.NextToken != nil {
		result.NextToken = *resp.JSON200.NextToken
	}

	return result, nil
}



// ChangesetSolutionBuilder provides a fluent API for the changesetSolution operation.
// List solution changes
type ChangesetSolutionBuilder struct {
	client  *Client
	solutionId string
	params  map[string]any
	err     error
}

// ChangesetSolution starts building a changesetSolution request.
func (c *Client) ChangesetSolution(solutionId string) *ChangesetSolutionBuilder {
	b := &ChangesetSolutionBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	return b
}



// Run executes the changesetSolution request.
func (b *ChangesetSolutionBuilder) Run(ctx context.Context) (*generated.ChangesetSolutionResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.ChangesetSolutionJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.ChangesetSolutionParams{}

	resp, err := b.client.API().ChangesetSolutionWithResponse(ctx, b.solutionId, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// ChangesetSolutionFromRecordBuilder provides a fluent API for the changesetSolutionFromRecord operation.
// List solution changes from record
type ChangesetSolutionFromRecordBuilder struct {
	client  *Client
	table   string
	tableID string
	solutionId string
	qpFieldId *int
	qpRecordId *int
	params  map[string]any
	err     error
}

// ChangesetSolutionFromRecord starts building a changesetSolutionFromRecord request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) ChangesetSolutionFromRecord(solutionId string, table string) *ChangesetSolutionFromRecordBuilder {
	b := &ChangesetSolutionFromRecordBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
func (b *ChangesetSolutionFromRecordBuilder) FieldId(value int) *ChangesetSolutionFromRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpFieldId = &value
	return b
}


// RecordId The unique identifier of the record.
func (b *ChangesetSolutionFromRecordBuilder) RecordId(value int) *ChangesetSolutionFromRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpRecordId = &value
	return b
}


// Run executes the changesetSolutionFromRecord request.
func (b *ChangesetSolutionFromRecordBuilder) Run(ctx context.Context) (*generated.ChangesetSolutionFromRecordResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	if b.qpFieldId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldId is required for changesetSolutionFromRecord",
			},
		}
	}
	if b.qpRecordId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "recordId is required for changesetSolutionFromRecord",
			},
		}
	}
	// Build query params
	params := &generated.ChangesetSolutionFromRecordParams{}
	params.TableId = b.tableID
	if b.qpFieldId != nil {
		params.FieldId = *b.qpFieldId
	}
	if b.qpRecordId != nil {
		params.RecordId = *b.qpRecordId
	}

	resp, err := b.client.API().ChangesetSolutionFromRecordWithResponse(ctx, b.solutionId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}


// CloneUserTokenResult contains the result of a cloneUserToken call.
type CloneUserTokenResult struct {
	Active bool
	LastUsed string
	Description string
	Id int
	Name string
	Token string
}


// CloneUserTokenBuilder provides a fluent API for the cloneUserToken operation.
// Clone a user token
type CloneUserTokenBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// CloneUserToken starts building a cloneUserToken request.
func (c *Client) CloneUserToken() *CloneUserTokenBuilder {
	b := &CloneUserTokenBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Name The new name for the cloned user token.
func (b *CloneUserTokenBuilder) Name(value string) *CloneUserTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}


// Description The description for the cloned user token.
func (b *CloneUserTokenBuilder) Description(value string) *CloneUserTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}



// Run executes the cloneUserToken request.
func (b *CloneUserTokenBuilder) Run(ctx context.Context) (*CloneUserTokenResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CloneUserTokenJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().CloneUserTokenWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &CloneUserTokenResult{}
	if resp.JSON200.Active != nil {
		result.Active = *resp.JSON200.Active
	}
	if resp.JSON200.LastUsed != nil {
		result.LastUsed = *resp.JSON200.LastUsed
	}
	if resp.JSON200.Description != nil {
		result.Description = *resp.JSON200.Description
	}
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}
	if resp.JSON200.Name != nil {
		result.Name = *resp.JSON200.Name
	}
	if resp.JSON200.Token != nil {
		result.Token = *resp.JSON200.Token
	}

	return result, nil
}


// CopyAppResult contains the result of a copyApp call.
type CopyAppResult struct {
	Name string
	Description string
	Updated string
	DateFormat string
	Id string
	HasEveryoneOnTheInternet bool
	DataClassification string
	Created string
	TimeZone string
	AncestorId string
}


// CopyAppBuilder provides a fluent API for the copyApp operation.
// Copy an app
type CopyAppBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// CopyApp starts building a copyApp request.
func (c *Client) CopyApp(appId string) *CopyAppBuilder {
	b := &CopyAppBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}


// Description The description of the newly copied app
func (b *CopyAppBuilder) Description(value string) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}


// AssignUserToken Whether to add the user token used to make this request to the new app
func (b *CopyAppBuilder) AssignUserToken(value bool) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["assignUserToken"] = value
	b.params["properties"] = nested
	return b
}


// ExcludeFiles If keepData is true, whether to copy the file attachments as well. If keepData is false, this property is ignored
func (b *CopyAppBuilder) ExcludeFiles(value bool) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["excludeFiles"] = value
	b.params["properties"] = nested
	return b
}


// KeepData Whether to copy the app's data along with the schema
func (b *CopyAppBuilder) KeepData(value bool) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["keepData"] = value
	b.params["properties"] = nested
	return b
}


// UsersAndRoles If true, users will be copied along with their assigned roles. If false, users and roles will be copied but roles will not be assigned
func (b *CopyAppBuilder) UsersAndRoles(value bool) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["usersAndRoles"] = value
	b.params["properties"] = nested
	return b
}


// Name The name of the newly copied app
func (b *CopyAppBuilder) Name(value string) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}



// Run executes the copyApp request.
func (b *CopyAppBuilder) Run(ctx context.Context) (*CopyAppResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["name"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "name is required for copyApp",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CopyAppJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().CopyAppWithResponse(ctx, b.appId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &CopyAppResult{}
	result.Name = resp.JSON200.Name
	if resp.JSON200.Description != nil {
		result.Description = *resp.JSON200.Description
	}
	if resp.JSON200.Updated != nil {
		result.Updated = *resp.JSON200.Updated
	}
	if resp.JSON200.DateFormat != nil {
		result.DateFormat = *resp.JSON200.DateFormat
	}
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}
	if resp.JSON200.HasEveryoneOnTheInternet != nil {
		result.HasEveryoneOnTheInternet = *resp.JSON200.HasEveryoneOnTheInternet
	}
	if resp.JSON200.DataClassification != nil {
		result.DataClassification = *resp.JSON200.DataClassification
	}
	if resp.JSON200.Created != nil {
		result.Created = *resp.JSON200.Created
	}
	if resp.JSON200.TimeZone != nil {
		result.TimeZone = *resp.JSON200.TimeZone
	}
	if resp.JSON200.AncestorId != nil {
		result.AncestorId = *resp.JSON200.AncestorId
	}

	return result, nil
}


// CreateAppResult contains the result of a createApp call.
type CreateAppResult struct {
	Created string
	Updated string
	DateFormat string
	TimeZone string
	DataClassification string
	Name string
	Id string
	HasEveryoneOnTheInternet bool
	Description string
}


// CreateAppBuilder provides a fluent API for the createApp operation.
// Create an app
type CreateAppBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// CreateApp starts building a createApp request.
func (c *Client) CreateApp() *CreateAppBuilder {
	b := &CreateAppBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// AssignToken Set to true if you would like to assign the app to the user token you used to create the application. The default is false.
func (b *CreateAppBuilder) AssignToken(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["assignToken"] = value
	return b
}


// Variables The app variables. A maximum of 10 variables can be inserted at a time. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
func (b *CreateAppBuilder) Variables(values ...map[string]any) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["variables"] = values
	return b
}


// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
func (b *CreateAppBuilder) Name(value string) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}


// UseIPFilter Only users logging in from "approved" IP addresses may access this application
func (b *CreateAppBuilder) UseIPFilter(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useIPFilter"] = value
	b.params["securityProperties"] = nested
	return b
}


// AllowExport Allow users who are not administrators to export data
func (b *CreateAppBuilder) AllowExport(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowExport"] = value
	b.params["securityProperties"] = nested
	return b
}


// EnableAppTokens Require Application Tokens
func (b *CreateAppBuilder) EnableAppTokens(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["enableAppTokens"] = value
	b.params["securityProperties"] = nested
	return b
}


// HideFromPublic Hide from public application searches
func (b *CreateAppBuilder) HideFromPublic(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hideFromPublic"] = value
	b.params["securityProperties"] = nested
	return b
}


// MustBeRealmApproved Only "approved" users may access this application
func (b *CreateAppBuilder) MustBeRealmApproved(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["mustBeRealmApproved"] = value
	b.params["securityProperties"] = nested
	return b
}


// AllowClone Allow users who are not administrators to copy
func (b *CreateAppBuilder) AllowClone(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowClone"] = value
	b.params["securityProperties"] = nested
	return b
}


// Description The description for the app. If this property is left out, the app description will be blank.
func (b *CreateAppBuilder) Description(value string) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}



// Run executes the createApp request.
func (b *CreateAppBuilder) Run(ctx context.Context) (*CreateAppResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["name"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "name is required for createApp",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CreateAppJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().CreateAppWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &CreateAppResult{}
	if resp.JSON200.Created != nil {
		result.Created = *resp.JSON200.Created
	}
	if resp.JSON200.Updated != nil {
		result.Updated = *resp.JSON200.Updated
	}
	if resp.JSON200.DateFormat != nil {
		result.DateFormat = *resp.JSON200.DateFormat
	}
	if resp.JSON200.TimeZone != nil {
		result.TimeZone = *resp.JSON200.TimeZone
	}
	if resp.JSON200.DataClassification != nil {
		result.DataClassification = *resp.JSON200.DataClassification
	}
	result.Name = resp.JSON200.Name
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}
	if resp.JSON200.HasEveryoneOnTheInternet != nil {
		result.HasEveryoneOnTheInternet = *resp.JSON200.HasEveryoneOnTheInternet
	}
	if resp.JSON200.Description != nil {
		result.Description = *resp.JSON200.Description
	}

	return result, nil
}


// CreateFieldResult contains the result of a createField call.
type CreateFieldResult struct {
	FieldType string
	NoWrap bool
	FindEnabled bool
	Unique bool
	FieldHelp string
	Id int64
	Mode string
	Label string
	AppearsByDefault bool
	DoesDataCopy bool
	Audited bool
	Bold bool
	Required bool
}


// CreateFieldBuilder provides a fluent API for the createField operation.
// Create a field
type CreateFieldBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// CreateField starts building a createField request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) CreateField(table string) *CreateFieldBuilder {
	b := &CreateFieldBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// Comments The comments entered on the field properties by an administrator.
func (b *CreateFieldBuilder) Comments(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["comments"] = value
	b.params["properties"] = nested
	return b
}


// DoesTotal Whether this field totals in reports within the product.
func (b *CreateFieldBuilder) DoesTotal(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["doesTotal"] = value
	b.params["properties"] = nested
	return b
}


// Abbreviate Don't show the URL protocol when showing the URL.
func (b *CreateFieldBuilder) Abbreviate(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["abbreviate"] = value
	b.params["properties"] = nested
	return b
}


// SourceFieldId The id of the source field.
func (b *CreateFieldBuilder) SourceFieldId(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sourceFieldId"] = value
	b.params["properties"] = nested
	return b
}


// DefaultCountryCode Controls the default country shown on international phone widgets on forms. Country code should be entered in the ISO 3166-1 alpha-2 format.
func (b *CreateFieldBuilder) DefaultCountryCode(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultCountryCode"] = value
	b.params["properties"] = nested
	return b
}


// CoverText An alternate user friendly text that can be used to display a link in the browser.
func (b *CreateFieldBuilder) CoverText(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["coverText"] = value
	b.params["properties"] = nested
	return b
}


// NumberFormat The format used for displaying numeric values in the product (decimal, separators, digit group).
func (b *CreateFieldBuilder) NumberFormat(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["numberFormat"] = value
	b.params["properties"] = nested
	return b
}


// TargetTableId The id of the target table.
func (b *CreateFieldBuilder) TargetTableId(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetTableId"] = value
	b.params["properties"] = nested
	return b
}


// Hours24 Indicates whether or not to display time in the 24-hour format within the product.
func (b *CreateFieldBuilder) Hours24(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hours24"] = value
	b.params["properties"] = nested
	return b
}


// SeeVersions Indicates if the user can see other versions, aside from the most recent, of a file attachment within the product.
func (b *CreateFieldBuilder) SeeVersions(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["seeVersions"] = value
	b.params["properties"] = nested
	return b
}


// Choices An array of entries that exist for a field that offers choices to the user. Note that these choices refer to the valid values of any records added in the future. You are allowed to remove values from the list of choices even if there are existing records with those values in this field. They will be displayed in red when users look at the data in the browser but there is no other effect. While updating a field with this property, the old choices are removed and replaced by the new choices.
func (b *CreateFieldBuilder) Choices(value []string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["choices"] = value
	b.params["properties"] = nested
	return b
}


// DisplayAsLink Indicates if a field that is part of the relationship should be shown as a hyperlink to the parent record within the product.
func (b *CreateFieldBuilder) DisplayAsLink(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayAsLink"] = value
	b.params["properties"] = nested
	return b
}


// UseI18NFormat Whether phone numbers should be in E.164 standard international format
func (b *CreateFieldBuilder) UseI18NFormat(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useI18NFormat"] = value
	b.params["properties"] = nested
	return b
}


// MaxVersions The maximum number of versions configured for a file attachment.
func (b *CreateFieldBuilder) MaxVersions(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["maxVersions"] = value
	b.params["properties"] = nested
	return b
}


// Exact Whether an exact match is required for a report link.
func (b *CreateFieldBuilder) Exact(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["exact"] = value
	b.params["properties"] = nested
	return b
}


// TargetTableName The field's target table name.
func (b *CreateFieldBuilder) TargetTableName(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetTableName"] = value
	b.params["properties"] = nested
	return b
}


// AppearsAs The link text, if empty, the url will be used as link text.
func (b *CreateFieldBuilder) AppearsAs(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["appearsAs"] = value
	b.params["properties"] = nested
	return b
}


// Format The format to display time.
func (b *CreateFieldBuilder) Format(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["format"] = value
	b.params["properties"] = nested
	return b
}


// DecimalPlaces The number of decimal places displayed in the product for this field.
func (b *CreateFieldBuilder) DecimalPlaces(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["decimalPlaces"] = value
	b.params["properties"] = nested
	return b
}


// DisplayMonth How to display months.
func (b *CreateFieldBuilder) DisplayMonth(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayMonth"] = value
	b.params["properties"] = nested
	return b
}


// DefaultValue The default value configured for a field when a new record is added.
func (b *CreateFieldBuilder) DefaultValue(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultValue"] = value
	b.params["properties"] = nested
	return b
}


// CurrencyFormat The currency format used when displaying field values within the product.
func (b *CreateFieldBuilder) CurrencyFormat(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["currencyFormat"] = value
	b.params["properties"] = nested
	return b
}


// SnapFieldId The id of the field that is used to snapshot values from, when applicable.
func (b *CreateFieldBuilder) SnapFieldId(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["snapFieldId"] = value
	b.params["properties"] = nested
	return b
}


// DefaultValueLuid Default user id value.
func (b *CreateFieldBuilder) DefaultValueLuid(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultValueLuid"] = value
	b.params["properties"] = nested
	return b
}


// LinkText The configured text value that replaces the URL that users see within the product.
func (b *CreateFieldBuilder) LinkText(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["linkText"] = value
	b.params["properties"] = nested
	return b
}


// VersionMode Version modes for files. Keep all versions vs keep last version.
func (b *CreateFieldBuilder) VersionMode(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["versionMode"] = value
	b.params["properties"] = nested
	return b
}


// SortAsGiven Indicates if the listed entries sort as entered vs alphabetically.
func (b *CreateFieldBuilder) SortAsGiven(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sortAsGiven"] = value
	b.params["properties"] = nested
	return b
}


// OpenTargetIn Indicates which target the URL should open in when a user clicks it within the product.
func (b *CreateFieldBuilder) OpenTargetIn(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["openTargetIn"] = value
	b.params["properties"] = nested
	return b
}


// TargetFieldId The id of the target field.
func (b *CreateFieldBuilder) TargetFieldId(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetFieldId"] = value
	b.params["properties"] = nested
	return b
}


// SortAlpha Whether to sort alphabetically, default sort is by record ID.
func (b *CreateFieldBuilder) SortAlpha(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sortAlpha"] = value
	b.params["properties"] = nested
	return b
}


// HasExtension Whether this field has a phone extension.
func (b *CreateFieldBuilder) HasExtension(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hasExtension"] = value
	b.params["properties"] = nested
	return b
}


// UseNewWindow Indicates if the file should open a new window when a user clicks it within the product.
func (b *CreateFieldBuilder) UseNewWindow(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useNewWindow"] = value
	b.params["properties"] = nested
	return b
}


// AppendOnly Whether this field is append only.
func (b *CreateFieldBuilder) AppendOnly(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["appendOnly"] = value
	b.params["properties"] = nested
	return b
}


// AllowMentions If someone can @mention users in the rich text field to generate an email notification.
func (b *CreateFieldBuilder) AllowMentions(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowMentions"] = value
	b.params["properties"] = nested
	return b
}


// DoesAverage Whether this field averages in reports within the product.
func (b *CreateFieldBuilder) DoesAverage(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["doesAverage"] = value
	b.params["properties"] = nested
	return b
}


// CurrencySymbol The current symbol used when displaying field values within the product.
func (b *CreateFieldBuilder) CurrencySymbol(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["currencySymbol"] = value
	b.params["properties"] = nested
	return b
}


// BlankIsZero Whether a blank value is treated the same as 0 in calculations within the product.
func (b *CreateFieldBuilder) BlankIsZero(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["blankIsZero"] = value
	b.params["properties"] = nested
	return b
}


// DisplayTimezone Indicates whether to display the timezone within the product.
func (b *CreateFieldBuilder) DisplayTimezone(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayTimezone"] = value
	b.params["properties"] = nested
	return b
}


// DisplayDayOfWeek Indicates whether to display the day of the week within the product.
func (b *CreateFieldBuilder) DisplayDayOfWeek(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayDayOfWeek"] = value
	b.params["properties"] = nested
	return b
}


// DisplayCheckboxAsText Indicates whether the checkbox values will be shown as text in reports.
func (b *CreateFieldBuilder) DisplayCheckboxAsText(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayCheckboxAsText"] = value
	b.params["properties"] = nested
	return b
}


// CarryChoices Whether the field should carry its multiple choice fields when copied.
func (b *CreateFieldBuilder) CarryChoices(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["carryChoices"] = value
	b.params["properties"] = nested
	return b
}


// Formula The formula of the field as configured in Quickbase.
func (b *CreateFieldBuilder) Formula(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["formula"] = value
	b.params["properties"] = nested
	return b
}


// AllowNewChoices Indicates if users can add new choices to a selection list.
func (b *CreateFieldBuilder) AllowNewChoices(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowNewChoices"] = value
	b.params["properties"] = nested
	return b
}


// Units The units label.
func (b *CreateFieldBuilder) Units(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["units"] = value
	b.params["properties"] = nested
	return b
}


// DefaultKind The user default type.
func (b *CreateFieldBuilder) DefaultKind(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultKind"] = value
	b.params["properties"] = nested
	return b
}


// DisplayEmail How the email is displayed.
func (b *CreateFieldBuilder) DisplayEmail(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayEmail"] = value
	b.params["properties"] = nested
	return b
}


// DefaultDomain Default email domain.
func (b *CreateFieldBuilder) DefaultDomain(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultDomain"] = value
	b.params["properties"] = nested
	return b
}


// Width The field's html input width in the product.
func (b *CreateFieldBuilder) Width(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["width"] = value
	b.params["properties"] = nested
	return b
}


// DisplayRelative Whether to display time as relative.
func (b *CreateFieldBuilder) DisplayRelative(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayRelative"] = value
	b.params["properties"] = nested
	return b
}


// CompositeFields An array of the fields that make up a composite field (e.g., address).
func (b *CreateFieldBuilder) CompositeFields(value []any) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["compositeFields"] = value
	b.params["properties"] = nested
	return b
}


// DisplayTime Indicates whether to display the time, in addition to the date.
func (b *CreateFieldBuilder) DisplayTime(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayTime"] = value
	b.params["properties"] = nested
	return b
}


// ParentFieldId The id of the parent composite field, when applicable.
func (b *CreateFieldBuilder) ParentFieldId(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["parentFieldId"] = value
	b.params["properties"] = nested
	return b
}


// DefaultToday Indicates if the field value is defaulted today for new records.
func (b *CreateFieldBuilder) DefaultToday(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultToday"] = value
	b.params["properties"] = nested
	return b
}


// DisplayUser The configured option for how users display within the product.
func (b *CreateFieldBuilder) DisplayUser(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayUser"] = value
	b.params["properties"] = nested
	return b
}


// NumLines The number of lines shown in Quickbase for this text field.
func (b *CreateFieldBuilder) NumLines(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["numLines"] = value
	b.params["properties"] = nested
	return b
}


// AutoSave Whether the link field will auto save.
func (b *CreateFieldBuilder) AutoSave(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["autoSave"] = value
	b.params["properties"] = nested
	return b
}


// MaxLength The maximum number of characters allowed for entry in Quickbase for this field.
func (b *CreateFieldBuilder) MaxLength(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["maxLength"] = value
	b.params["properties"] = nested
	return b
}


// CommaStart The number of digits before commas display in the product, when applicable.
func (b *CreateFieldBuilder) CommaStart(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["commaStart"] = value
	b.params["properties"] = nested
	return b
}


// FieldType The [field types](https://help.quickbase.com/user-assistance/field_types.html), click on any of the field type links for more info.
func (b *CreateFieldBuilder) FieldType(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldType"] = value
	return b
}


// AddToForms Whether the field you are adding should appear on forms. Defaults to false.
func (b *CreateFieldBuilder) AddToForms(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["addToForms"] = value
	return b
}


// Label The label (name) of the field.
func (b *CreateFieldBuilder) Label(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["label"] = value
	return b
}


// FindEnabled Indicates if the field is marked as searchable. Defaults to true.
func (b *CreateFieldBuilder) FindEnabled(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["findEnabled"] = value
	return b
}


// AppearsByDefault Indicates if the field is marked as a default in reports. Defaults to true.
func (b *CreateFieldBuilder) AppearsByDefault(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["appearsByDefault"] = value
	return b
}


// Permissions Field Permissions for different roles.
func (b *CreateFieldBuilder) Permissions(values ...map[string]any) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["permissions"] = values
	return b
}


// NoWrap Indicates if the field is configured to not wrap when displayed in the product. Defaults to false.
func (b *CreateFieldBuilder) NoWrap(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["noWrap"] = value
	return b
}


// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs. You can only set this property to "true" if the app has audit logs enabled. See Enable data change logs under [Quickbase Audit Logs](https://help.quickbase.com/user-assistance/audit_logs.html). Defaults to false.
func (b *CreateFieldBuilder) Audited(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["audited"] = value
	return b
}


// FieldHelp The configured help text shown to users within the product.
func (b *CreateFieldBuilder) FieldHelp(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldHelp"] = value
	return b
}


// Bold Indicates if the field is configured to display in bold in the product. Defaults to false.
func (b *CreateFieldBuilder) Bold(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["bold"] = value
	return b
}



// Run executes the createField request.
func (b *CreateFieldBuilder) Run(ctx context.Context) (*CreateFieldResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["fieldType"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldType is required for createField",
			},
		}
	}
	if _, ok := b.params["label"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "label is required for createField",
			},
		}
	}
	// tableId is validated via table resolution
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CreateFieldJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.CreateFieldParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().CreateFieldWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &CreateFieldResult{}
	if resp.JSON200.FieldType != nil {
		result.FieldType = *resp.JSON200.FieldType
	}
	if resp.JSON200.NoWrap != nil {
		result.NoWrap = *resp.JSON200.NoWrap
	}
	if resp.JSON200.FindEnabled != nil {
		result.FindEnabled = *resp.JSON200.FindEnabled
	}
	if resp.JSON200.Unique != nil {
		result.Unique = *resp.JSON200.Unique
	}
	if resp.JSON200.FieldHelp != nil {
		result.FieldHelp = *resp.JSON200.FieldHelp
	}
	result.Id = resp.JSON200.Id
	if resp.JSON200.Mode != nil {
		result.Mode = *resp.JSON200.Mode
	}
	if resp.JSON200.Label != nil {
		result.Label = *resp.JSON200.Label
	}
	if resp.JSON200.AppearsByDefault != nil {
		result.AppearsByDefault = *resp.JSON200.AppearsByDefault
	}
	if resp.JSON200.DoesDataCopy != nil {
		result.DoesDataCopy = *resp.JSON200.DoesDataCopy
	}
	if resp.JSON200.Audited != nil {
		result.Audited = *resp.JSON200.Audited
	}
	if resp.JSON200.Bold != nil {
		result.Bold = *resp.JSON200.Bold
	}
	if resp.JSON200.Required != nil {
		result.Required = *resp.JSON200.Required
	}

	return result, nil
}


// CreateRelationshipResult contains the result of a createRelationship call.
type CreateRelationshipResult struct {
	Id int
	ParentTableId string
	ChildTableId string
	IsCrossApp bool
}


// CreateRelationshipBuilder provides a fluent API for the createRelationship operation.
// Create a relationship
type CreateRelationshipBuilder struct {
	client  *Client
	table   string
	tableID string
	tableId string
	params  map[string]any
	err     error
}

// CreateRelationship starts building a createRelationship request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) CreateRelationship(table string) *CreateRelationshipBuilder {
	b := &CreateRelationshipBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// SummaryFields Array of summary field objects which will turn into summary fields in the parent table. When you specify the 'COUNT' accumulation type, you have to specify 0 as the summaryFid (or not set it in the request). 'DISTINCT-COUNT' requires that summaryFid be set to an actual fid.
func (b *CreateRelationshipBuilder) SummaryFields(values ...map[string]any) *CreateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	b.params["summaryFields"] = values
	return b
}


// LookupFieldIds Array of field ids in the parent table that will become lookup fields in the child table.
func (b *CreateRelationshipBuilder) LookupFieldIds(values ...int) *CreateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	b.params["lookupFieldIds"] = values
	return b
}


// ParentTableId The parent table id for the relationship.
func (b *CreateRelationshipBuilder) ParentTableId(value string) *CreateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	b.params["parentTableId"] = value
	return b
}


// Label The label for the foreign key field.
func (b *CreateRelationshipBuilder) Label(value string) *CreateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["foreignKeyField"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["label"] = value
	b.params["foreignKeyField"] = nested
	return b
}



// Run executes the createRelationship request.
func (b *CreateRelationshipBuilder) Run(ctx context.Context) (*CreateRelationshipResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	body["tableId"] = b.tableID
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CreateRelationshipJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().CreateRelationshipWithResponse(ctx, b.tableId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &CreateRelationshipResult{}
	result.Id = resp.JSON200.Id
	result.ParentTableId = resp.JSON200.ParentTableId
	result.ChildTableId = resp.JSON200.ChildTableId
	result.IsCrossApp = resp.JSON200.IsCrossApp

	return result, nil
}



// CreateSolutionBuilder provides a fluent API for the createSolution operation.
// Create a solution
type CreateSolutionBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// CreateSolution starts building a createSolution request.
func (c *Client) CreateSolution() *CreateSolutionBuilder {
	b := &CreateSolutionBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// Run executes the createSolution request.
func (b *CreateSolutionBuilder) Run(ctx context.Context) (*generated.CreateSolutionResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CreateSolutionJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.CreateSolutionParams{}

	resp, err := b.client.API().CreateSolutionWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// CreateSolutionFromRecordBuilder provides a fluent API for the createSolutionFromRecord operation.
// Create solution from record
type CreateSolutionFromRecordBuilder struct {
	client  *Client
	table   string
	tableID string
	qpFieldId *int
	qpRecordId *int
	params  map[string]any
	err     error
}

// CreateSolutionFromRecord starts building a createSolutionFromRecord request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) CreateSolutionFromRecord(table string) *CreateSolutionFromRecordBuilder {
	b := &CreateSolutionFromRecordBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
func (b *CreateSolutionFromRecordBuilder) FieldId(value int) *CreateSolutionFromRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpFieldId = &value
	return b
}


// RecordId The unique identifier of the record.
func (b *CreateSolutionFromRecordBuilder) RecordId(value int) *CreateSolutionFromRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpRecordId = &value
	return b
}


// Run executes the createSolutionFromRecord request.
func (b *CreateSolutionFromRecordBuilder) Run(ctx context.Context) (*generated.CreateSolutionFromRecordResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	if b.qpFieldId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldId is required for createSolutionFromRecord",
			},
		}
	}
	if b.qpRecordId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "recordId is required for createSolutionFromRecord",
			},
		}
	}
	// Build query params
	params := &generated.CreateSolutionFromRecordParams{}
	params.TableId = b.tableID
	if b.qpFieldId != nil {
		params.FieldId = *b.qpFieldId
	}
	if b.qpRecordId != nil {
		params.RecordId = *b.qpRecordId
	}

	resp, err := b.client.API().CreateSolutionFromRecordWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}


// CreateTableResult contains the result of a createTable call.
type CreateTableResult struct {
	Alias string
	SingleRecordName string
	SizeLimit string
	DefaultSortOrder string
	Created string
	NextRecordId int
	NextFieldId int
	DefaultSortFieldId int
	SpaceRemaining string
	Id string
	Description string
	Updated string
	KeyFieldId int
	PluralRecordName string
	SpaceUsed string
	Name string
}


// CreateTableBuilder provides a fluent API for the createTable operation.
// Create a table
type CreateTableBuilder struct {
	client  *Client
	qpAppId *string
	params  map[string]any
	err     error
}

// CreateTable starts building a createTable request.
func (c *Client) CreateTable() *CreateTableBuilder {
	b := &CreateTableBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Name The name for the table.
func (b *CreateTableBuilder) Name(value string) *CreateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}


// PluralRecordName The plural noun for records in the table. If this value is not passed the default value is 'Records'.
func (b *CreateTableBuilder) PluralRecordName(value string) *CreateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["pluralRecordName"] = value
	return b
}


// SingleRecordName The singular noun for records in the table. If this value is not passed the default value is 'Record'.
func (b *CreateTableBuilder) SingleRecordName(value string) *CreateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["singleRecordName"] = value
	return b
}


// Description The description for the table. If this value is not passed the default value is blank.
func (b *CreateTableBuilder) Description(value string) *CreateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}



// AppId The unique identifier of an app
func (b *CreateTableBuilder) AppId(value string) *CreateTableBuilder {
	if b.err != nil {
		return b
	}
	b.qpAppId = &value
	return b
}


// Run executes the createTable request.
func (b *CreateTableBuilder) Run(ctx context.Context) (*CreateTableResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["name"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "name is required for createTable",
			},
		}
	}
	if b.qpAppId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "appId is required for createTable",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CreateTableJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.CreateTableParams{}
	if b.qpAppId != nil {
		params.AppId = *b.qpAppId
	}

	resp, err := b.client.API().CreateTableWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &CreateTableResult{}
	if resp.JSON200.Alias != nil {
		result.Alias = *resp.JSON200.Alias
	}
	if resp.JSON200.SingleRecordName != nil {
		result.SingleRecordName = *resp.JSON200.SingleRecordName
	}
	if resp.JSON200.SizeLimit != nil {
		result.SizeLimit = *resp.JSON200.SizeLimit
	}
	if resp.JSON200.DefaultSortOrder != nil {
		result.DefaultSortOrder = string(*resp.JSON200.DefaultSortOrder)
	}
	if resp.JSON200.Created != nil {
		result.Created = *resp.JSON200.Created
	}
	if resp.JSON200.NextRecordId != nil {
		result.NextRecordId = *resp.JSON200.NextRecordId
	}
	if resp.JSON200.NextFieldId != nil {
		result.NextFieldId = *resp.JSON200.NextFieldId
	}
	if resp.JSON200.DefaultSortFieldId != nil {
		result.DefaultSortFieldId = *resp.JSON200.DefaultSortFieldId
	}
	if resp.JSON200.SpaceRemaining != nil {
		result.SpaceRemaining = *resp.JSON200.SpaceRemaining
	}
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}
	if resp.JSON200.Description != nil {
		result.Description = *resp.JSON200.Description
	}
	if resp.JSON200.Updated != nil {
		result.Updated = *resp.JSON200.Updated
	}
	if resp.JSON200.KeyFieldId != nil {
		result.KeyFieldId = *resp.JSON200.KeyFieldId
	}
	if resp.JSON200.PluralRecordName != nil {
		result.PluralRecordName = *resp.JSON200.PluralRecordName
	}
	if resp.JSON200.SpaceUsed != nil {
		result.SpaceUsed = *resp.JSON200.SpaceUsed
	}
	if resp.JSON200.Name != nil {
		result.Name = *resp.JSON200.Name
	}

	return result, nil
}


// DeactivateUserTokenResult contains the result of a deactivateUserToken call.
type DeactivateUserTokenResult struct {
	Id int
}


// DeactivateUserTokenBuilder provides a fluent API for the deactivateUserToken operation.
// Deactivate a user token
type DeactivateUserTokenBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// DeactivateUserToken starts building a deactivateUserToken request.
func (c *Client) DeactivateUserToken() *DeactivateUserTokenBuilder {
	b := &DeactivateUserTokenBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// Run executes the deactivateUserToken request.
func (b *DeactivateUserTokenBuilder) Run(ctx context.Context) (*DeactivateUserTokenResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().DeactivateUserTokenWithResponse(ctx)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &DeactivateUserTokenResult{}
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}

	return result, nil
}


// DeleteAppResult contains the result of a deleteApp call.
type DeleteAppResult struct {
	DeletedAppId string
}


// DeleteAppBuilder provides a fluent API for the deleteApp operation.
// Delete an app
type DeleteAppBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// DeleteApp starts building a deleteApp request.
func (c *Client) DeleteApp(appId string) *DeleteAppBuilder {
	b := &DeleteAppBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}


// Name To confirm application deletion we ask for application name.
func (b *DeleteAppBuilder) Name(value string) *DeleteAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}



// Run executes the deleteApp request.
func (b *DeleteAppBuilder) Run(ctx context.Context) (*DeleteAppResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["name"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "name is required for deleteApp",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.DeleteAppJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().DeleteAppWithResponse(ctx, b.appId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &DeleteAppResult{}
	if resp.JSON200.DeletedAppId != nil {
		result.DeletedAppId = *resp.JSON200.DeletedAppId
	}

	return result, nil
}


// DeleteFieldsResult contains the result of a deleteFields call.
type DeleteFieldsResult struct {
	DeletedFieldIds []int
	Errors []string
}


// DeleteFieldsBuilder provides a fluent API for the deleteFields operation.
// Delete field(s)
type DeleteFieldsBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// DeleteFields starts building a deleteFields request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DeleteFields(table string) *DeleteFieldsBuilder {
	b := &DeleteFieldsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// FieldIds List of field ids to be deleted.
func (b *DeleteFieldsBuilder) FieldIds(values ...int) *DeleteFieldsBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldIds"] = values
	return b
}



// Run executes the deleteFields request.
func (b *DeleteFieldsBuilder) Run(ctx context.Context) (*DeleteFieldsResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["fieldIds"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldIds is required for deleteFields",
			},
		}
	}
	// tableId is validated via table resolution
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.DeleteFieldsJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.DeleteFieldsParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().DeleteFieldsWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &DeleteFieldsResult{}
	result.DeletedFieldIds = resp.JSON200.DeletedFieldIds
	result.Errors = resp.JSON200.Errors

	return result, nil
}


// DeleteFileResult contains the result of a deleteFile call.
type DeleteFileResult struct {
	VersionNumber int
	FileName string
	Uploaded string
}


// DeleteFileBuilder provides a fluent API for the deleteFile operation.
// Delete file
type DeleteFileBuilder struct {
	client  *Client
	table   string
	tableID string
	tableId string
	recordId int
	fieldId int
	versionNumber int
	params  map[string]any
	err     error
}

// DeleteFile starts building a deleteFile request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DeleteFile(table string, recordId int, fieldId int, versionNumber int) *DeleteFileBuilder {
	b := &DeleteFileBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.recordId = recordId
	b.fieldId = fieldId
	b.versionNumber = versionNumber
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the deleteFile request.
func (b *DeleteFileBuilder) Run(ctx context.Context) (*DeleteFileResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().DeleteFileWithResponse(ctx, b.tableId, b.recordId, b.fieldId, b.versionNumber)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &DeleteFileResult{}
	if resp.JSON200.VersionNumber != nil {
		result.VersionNumber = *resp.JSON200.VersionNumber
	}
	if resp.JSON200.FileName != nil {
		result.FileName = *resp.JSON200.FileName
	}
	if resp.JSON200.Uploaded != nil {
		result.Uploaded = *resp.JSON200.Uploaded
	}

	return result, nil
}


// DeleteRecordsResult contains the result of a deleteRecords call.
type DeleteRecordsResult struct {
	NumberDeleted int
}

// DeleteRecordsBuilder provides a fluent API for the deleteRecords operation.
// Delete record(s)
type DeleteRecordsBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// DeleteRecords starts building a deleteRecords request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DeleteRecords(table string) *DeleteRecordsBuilder {
	b := &DeleteRecordsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// Where The filter to delete records. To delete all records specify a filter that will include all records, for example {3.GT.0} where 3 is the ID of the Record ID field.
func (b *DeleteRecordsBuilder) Where(value string) *DeleteRecordsBuilder {
	if b.err != nil {
		return b
	}
	b.params["where"] = value
	return b
}



// Run executes the deleteRecords request.
func (b *DeleteRecordsBuilder) Run(ctx context.Context) (*DeleteRecordsResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["where"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "where is required for deleteRecords",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	body["from"] = b.tableID
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.DeleteRecordsJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().DeleteRecordsWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &DeleteRecordsResult{}
	if resp.JSON200.NumberDeleted != nil {
		result.NumberDeleted = *resp.JSON200.NumberDeleted
	}
	return result, nil
}


// DeleteRelationshipResult contains the result of a deleteRelationship call.
type DeleteRelationshipResult struct {
	RelationshipId int
}


// DeleteRelationshipBuilder provides a fluent API for the deleteRelationship operation.
// Delete a relationship
type DeleteRelationshipBuilder struct {
	client  *Client
	table   string
	tableID string
	tableId string
	relationshipId float32
	params  map[string]any
	err     error
}

// DeleteRelationship starts building a deleteRelationship request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DeleteRelationship(table string, relationshipId float32) *DeleteRelationshipBuilder {
	b := &DeleteRelationshipBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.relationshipId = relationshipId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the deleteRelationship request.
func (b *DeleteRelationshipBuilder) Run(ctx context.Context) (*DeleteRelationshipResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().DeleteRelationshipWithResponse(ctx, b.tableId, b.relationshipId)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &DeleteRelationshipResult{}
	result.RelationshipId = resp.JSON200.RelationshipId

	return result, nil
}


// DeleteTableResult contains the result of a deleteTable call.
type DeleteTableResult struct {
	DeletedTableId string
}


// DeleteTableBuilder provides a fluent API for the deleteTable operation.
// Delete a table
type DeleteTableBuilder struct {
	client  *Client
	table   string
	tableID string
	tableId string
	qpAppId *string
	params  map[string]any
	err     error
}

// DeleteTable starts building a deleteTable request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DeleteTable(table string) *DeleteTableBuilder {
	b := &DeleteTableBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// AppId The unique identifier of an app
func (b *DeleteTableBuilder) AppId(value string) *DeleteTableBuilder {
	if b.err != nil {
		return b
	}
	b.qpAppId = &value
	return b
}


// Run executes the deleteTable request.
func (b *DeleteTableBuilder) Run(ctx context.Context) (*DeleteTableResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if b.qpAppId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "appId is required for deleteTable",
			},
		}
	}
	// Build query params
	params := &generated.DeleteTableParams{}
	if b.qpAppId != nil {
		params.AppId = *b.qpAppId
	}

	resp, err := b.client.API().DeleteTableWithResponse(ctx, b.tableId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &DeleteTableResult{}
	if resp.JSON200.DeletedTableId != nil {
		result.DeletedTableId = *resp.JSON200.DeletedTableId
	}

	return result, nil
}


// DeleteUserTokenResult contains the result of a deleteUserToken call.
type DeleteUserTokenResult struct {
	Id int
}


// DeleteUserTokenBuilder provides a fluent API for the deleteUserToken operation.
// Delete a user token
type DeleteUserTokenBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// DeleteUserToken starts building a deleteUserToken request.
func (c *Client) DeleteUserToken() *DeleteUserTokenBuilder {
	b := &DeleteUserTokenBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// Run executes the deleteUserToken request.
func (b *DeleteUserTokenBuilder) Run(ctx context.Context) (*DeleteUserTokenResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().DeleteUserTokenWithResponse(ctx)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &DeleteUserTokenResult{}
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}

	return result, nil
}


// DenyUsersResult contains the result of a denyUsers call.
type DenyUsersResult struct {
	Failure []string
	Success []string
}


// DenyUsersBuilder provides a fluent API for the denyUsers operation.
// Deny users
type DenyUsersBuilder struct {
	client  *Client
	qpAccountId *float32
	params  map[string]any
	err     error
}

// DenyUsers starts building a denyUsers request.
func (c *Client) DenyUsers() *DenyUsersBuilder {
	b := &DenyUsersBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// AccountId The account id being used to deny users. If no value is specified, the first account associated with the requesting user token is chosen.
func (b *DenyUsersBuilder) AccountId(value float32) *DenyUsersBuilder {
	if b.err != nil {
		return b
	}
	b.qpAccountId = &value
	return b
}


// Run executes the denyUsers request.
func (b *DenyUsersBuilder) Run(ctx context.Context) (*DenyUsersResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.DenyUsersJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.DenyUsersParams{}
	if b.qpAccountId != nil {
		params.AccountId = b.qpAccountId
	}

	resp, err := b.client.API().DenyUsersWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &DenyUsersResult{}
	result.Failure = resp.JSON200.Failure
	result.Success = resp.JSON200.Success

	return result, nil
}


// DenyUsersAndGroupsResult contains the result of a denyUsersAndGroups call.
type DenyUsersAndGroupsResult struct {
	Failure []string
	Success []string
}


// DenyUsersAndGroupsBuilder provides a fluent API for the denyUsersAndGroups operation.
// Deny and remove users from groups
type DenyUsersAndGroupsBuilder struct {
	client  *Client
	shouldDeleteFromGroups bool
	qpAccountId *float32
	params  map[string]any
	err     error
}

// DenyUsersAndGroups starts building a denyUsersAndGroups request.
func (c *Client) DenyUsersAndGroups(shouldDeleteFromGroups bool) *DenyUsersAndGroupsBuilder {
	b := &DenyUsersAndGroupsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.shouldDeleteFromGroups = shouldDeleteFromGroups
	return b
}



// AccountId The account id being used to deny users. If no value is specified, the first account associated with the requesting user token is chosen.
func (b *DenyUsersAndGroupsBuilder) AccountId(value float32) *DenyUsersAndGroupsBuilder {
	if b.err != nil {
		return b
	}
	b.qpAccountId = &value
	return b
}


// Run executes the denyUsersAndGroups request.
func (b *DenyUsersAndGroupsBuilder) Run(ctx context.Context) (*DenyUsersAndGroupsResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.DenyUsersAndGroupsJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.DenyUsersAndGroupsParams{}
	if b.qpAccountId != nil {
		params.AccountId = b.qpAccountId
	}

	resp, err := b.client.API().DenyUsersAndGroupsWithResponse(ctx, b.shouldDeleteFromGroups, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &DenyUsersAndGroupsResult{}
	result.Failure = resp.JSON200.Failure
	result.Success = resp.JSON200.Success

	return result, nil
}



// DownloadFileBuilder provides a fluent API for the downloadFile operation.
// Download file
type DownloadFileBuilder struct {
	client  *Client
	table   string
	tableID string
	tableId string
	recordId int
	fieldId int
	versionNumber int
	params  map[string]any
	err     error
}

// DownloadFile starts building a downloadFile request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DownloadFile(table string, recordId int, fieldId int, versionNumber int) *DownloadFileBuilder {
	b := &DownloadFileBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.recordId = recordId
	b.fieldId = fieldId
	b.versionNumber = versionNumber
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the downloadFile request.
func (b *DownloadFileBuilder) Run(ctx context.Context) (*generated.DownloadFileResponse, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().DownloadFileWithResponse(ctx, b.tableId, b.recordId, b.fieldId, b.versionNumber)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}


// ExchangeSsoTokenResult contains the result of a exchangeSsoToken call.
type ExchangeSsoTokenResult struct {
	IssuedTokenType string
	TokenType string
	AccessToken string
}


// ExchangeSsoTokenBuilder provides a fluent API for the exchangeSsoToken operation.
// Exchange an SSO token
type ExchangeSsoTokenBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// ExchangeSsoToken starts building a exchangeSsoToken request.
func (c *Client) ExchangeSsoToken() *ExchangeSsoTokenBuilder {
	b := &ExchangeSsoTokenBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Grant_type The value `urn:ietf:params:oauth:grant-type:token-exchange` indicates that a token exchange is being performed.
func (b *ExchangeSsoTokenBuilder) Grant_type(value string) *ExchangeSsoTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["grant_type"] = value
	return b
}


// Requested_token_type An identifier for the type of the requested security token. For the RESTful API, use `urn:quickbase:params:oauth:token-type:temp_token`. For the XML or SCIM APIs use `urn:quickbase:params:oauth:token-type:temp_ticket`.
func (b *ExchangeSsoTokenBuilder) Requested_token_type(value string) *ExchangeSsoTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["requested_token_type"] = value
	return b
}


// Subject_token A security token that represents the identity of the party on behalf of whom the request is being made. For SAML 2.0, the value should be a base64url-encoded SAML 2.0 assertion.
func (b *ExchangeSsoTokenBuilder) Subject_token(value string) *ExchangeSsoTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["subject_token"] = value
	return b
}


// Subject_token_type An identifier that indicates the type of the security token in the `subject_token` parameter.
func (b *ExchangeSsoTokenBuilder) Subject_token_type(value string) *ExchangeSsoTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["subject_token_type"] = value
	return b
}



// Run executes the exchangeSsoToken request.
func (b *ExchangeSsoTokenBuilder) Run(ctx context.Context) (*ExchangeSsoTokenResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["grant_type"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "grant_type is required for exchangeSsoToken",
			},
		}
	}
	if _, ok := b.params["subject_token"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "subject_token is required for exchangeSsoToken",
			},
		}
	}
	if _, ok := b.params["subject_token_type"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "subject_token_type is required for exchangeSsoToken",
			},
		}
	}
	if _, ok := b.params["requested_token_type"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "requested_token_type is required for exchangeSsoToken",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.ExchangeSsoTokenJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().ExchangeSsoTokenWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &ExchangeSsoTokenResult{}
	if resp.JSON200.IssuedTokenType != nil {
		result.IssuedTokenType = string(*resp.JSON200.IssuedTokenType)
	}
	if resp.JSON200.TokenType != nil {
		result.TokenType = string(*resp.JSON200.TokenType)
	}
	if resp.JSON200.AccessToken != nil {
		result.AccessToken = *resp.JSON200.AccessToken
	}

	return result, nil
}



// ExportSolutionBuilder provides a fluent API for the exportSolution operation.
// Export a solution
type ExportSolutionBuilder struct {
	client  *Client
	solutionId string
	params  map[string]any
	err     error
}

// ExportSolution starts building a exportSolution request.
func (c *Client) ExportSolution(solutionId string) *ExportSolutionBuilder {
	b := &ExportSolutionBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	return b
}



// Run executes the exportSolution request.
func (b *ExportSolutionBuilder) Run(ctx context.Context) (*generated.ExportSolutionResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build query params
	params := &generated.ExportSolutionParams{}

	resp, err := b.client.API().ExportSolutionWithResponse(ctx, b.solutionId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// ExportSolutionToRecordBuilder provides a fluent API for the exportSolutionToRecord operation.
// Export solution to record
type ExportSolutionToRecordBuilder struct {
	client  *Client
	table   string
	tableID string
	solutionId string
	qpFieldId *int
	params  map[string]any
	err     error
}

// ExportSolutionToRecord starts building a exportSolutionToRecord request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) ExportSolutionToRecord(solutionId string, table string) *ExportSolutionToRecordBuilder {
	b := &ExportSolutionToRecordBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
func (b *ExportSolutionToRecordBuilder) FieldId(value int) *ExportSolutionToRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpFieldId = &value
	return b
}


// Run executes the exportSolutionToRecord request.
func (b *ExportSolutionToRecordBuilder) Run(ctx context.Context) (*generated.ExportSolutionToRecordResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	if b.qpFieldId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldId is required for exportSolutionToRecord",
			},
		}
	}
	// Build query params
	params := &generated.ExportSolutionToRecordParams{}
	params.TableId = b.tableID
	if b.qpFieldId != nil {
		params.FieldId = *b.qpFieldId
	}

	resp, err := b.client.API().ExportSolutionToRecordWithResponse(ctx, b.solutionId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}


// GenerateDocumentResult contains the result of a generateDocument call.
type GenerateDocumentResult struct {
	FileName string
	Data string
	ContentType string
}


// GenerateDocumentBuilder provides a fluent API for the generateDocument operation.
// Generate a document
type GenerateDocumentBuilder struct {
	client  *Client
	table   string
	tableID string
	templateId float32
	qpRecordId *float32
	qpFilename *string
	qpFormat *generated.GenerateDocumentParamsFormat
	qpMargin *string
	qpUnit *generated.GenerateDocumentParamsUnit
	qpPageSize *generated.GenerateDocumentParamsPageSize
	qpOrientation *generated.GenerateDocumentParamsOrientation
	qpRealm *string
	params  map[string]any
	err     error
}

// GenerateDocument starts building a generateDocument request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GenerateDocument(templateId float32, table string) *GenerateDocumentBuilder {
	b := &GenerateDocumentBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.templateId = templateId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// RecordId The ID of the record
func (b *GenerateDocumentBuilder) RecordId(value float32) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpRecordId = &value
	return b
}


// Filename File name for the downloaded file
func (b *GenerateDocumentBuilder) Filename(value string) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpFilename = &value
	return b
}


// Format The format of the file that is returned. Default is "pdf".
func (b *GenerateDocumentBuilder) Format(value generated.GenerateDocumentParamsFormat) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpFormat = &value
	return b
}


// Margin Margin formatted as top right bottom left, separated by spaces. Add to override the value set in the template builder.
func (b *GenerateDocumentBuilder) Margin(value string) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpMargin = &value
	return b
}


// Unit Unit of measurement for the margin. Default is "in". Add to override the value set in the template builder.
func (b *GenerateDocumentBuilder) Unit(value generated.GenerateDocumentParamsUnit) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpUnit = &value
	return b
}


// PageSize Page size. Default is "A4". Add to override the value set in the template builder.
func (b *GenerateDocumentBuilder) PageSize(value generated.GenerateDocumentParamsPageSize) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpPageSize = &value
	return b
}


// Orientation Page orientation. Default is "portrait". Add to override the value set in the template builder.
func (b *GenerateDocumentBuilder) Orientation(value generated.GenerateDocumentParamsOrientation) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpOrientation = &value
	return b
}


// Realm Your Quickbase domain, for example demo.quickbase.com
func (b *GenerateDocumentBuilder) Realm(value string) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpRealm = &value
	return b
}


// Run executes the generateDocument request.
func (b *GenerateDocumentBuilder) Run(ctx context.Context) (*GenerateDocumentResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	if b.qpFilename == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "filename is required for generateDocument",
			},
		}
	}
	// Build query params
	params := &generated.GenerateDocumentParams{}
	params.TableId = b.tableID
	if b.qpRecordId != nil {
		params.RecordId = b.qpRecordId
	}
	if b.qpFilename != nil {
		params.Filename = *b.qpFilename
	}
	if b.qpFormat != nil {
		params.Format = b.qpFormat
	}
	if b.qpMargin != nil {
		params.Margin = b.qpMargin
	}
	if b.qpUnit != nil {
		params.Unit = b.qpUnit
	}
	if b.qpPageSize != nil {
		params.PageSize = b.qpPageSize
	}
	if b.qpOrientation != nil {
		params.Orientation = b.qpOrientation
	}
	if b.qpRealm != nil {
		params.Realm = b.qpRealm
	}

	resp, err := b.client.API().GenerateDocumentWithResponse(ctx, b.templateId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GenerateDocumentResult{}
	if resp.JSON200.FileName != nil {
		result.FileName = *resp.JSON200.FileName
	}
	if resp.JSON200.Data != nil {
		result.Data = *resp.JSON200.Data
	}
	if resp.JSON200.ContentType != nil {
		result.ContentType = *resp.JSON200.ContentType
	}

	return result, nil
}


// GetAppResult contains the result of a getApp call.
type GetAppResult struct {
	ID string
	Name string
	Description string
	Created string
	Updated string
	DateFormat string
	TimeZone string
}

// GetAppBuilder provides a fluent API for the getApp operation.
// Get an app
type GetAppBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// GetApp starts building a getApp request.
func (c *Client) GetApp(appId string) *GetAppBuilder {
	b := &GetAppBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}



// Run executes the getApp request.
func (b *GetAppBuilder) Run(ctx context.Context) (*GetAppResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().GetAppWithResponse(ctx, b.appId)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GetAppResult{}
	if resp.JSON200.Id != nil {
		result.ID = *resp.JSON200.Id
	}
	result.Name = resp.JSON200.Name
	if resp.JSON200.Description != nil {
		result.Description = *resp.JSON200.Description
	}
	if resp.JSON200.Created != nil {
		result.Created = *resp.JSON200.Created
	}
	if resp.JSON200.Updated != nil {
		result.Updated = *resp.JSON200.Updated
	}
	if resp.JSON200.DateFormat != nil {
		result.DateFormat = *resp.JSON200.DateFormat
	}
	if resp.JSON200.TimeZone != nil {
		result.TimeZone = *resp.JSON200.TimeZone
	}
	return result, nil
}


// GetAppEventsResult contains the result of a getAppEvents call.
type GetAppEventsResult struct {
	Items []generated.GetAppEvents_200_Item
}


// GetAppEventsBuilder provides a fluent API for the getAppEvents operation.
// Get app events
type GetAppEventsBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// GetAppEvents starts building a getAppEvents request.
func (c *Client) GetAppEvents(appId string) *GetAppEventsBuilder {
	b := &GetAppEventsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}



// Run executes the getAppEvents request.
func (b *GetAppEventsBuilder) Run(ctx context.Context) (*GetAppEventsResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().GetAppEventsWithResponse(ctx, b.appId)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GetAppEventsResult{}
	result.Items = *resp.JSON200

	return result, nil
}


// GetAppTablesResult contains the result of a getAppTables call.
type GetAppTablesResult struct {
	Items []generated.GetAppTables_200_Item
}


// GetAppTablesBuilder provides a fluent API for the getAppTables operation.
// Get tables for an app
type GetAppTablesBuilder struct {
	client  *Client
	qpAppId *string
	params  map[string]any
	err     error
}

// GetAppTables starts building a getAppTables request.
func (c *Client) GetAppTables() *GetAppTablesBuilder {
	b := &GetAppTablesBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// AppId The unique identifier of an app
func (b *GetAppTablesBuilder) AppId(value string) *GetAppTablesBuilder {
	if b.err != nil {
		return b
	}
	b.qpAppId = &value
	return b
}


// Run executes the getAppTables request.
func (b *GetAppTablesBuilder) Run(ctx context.Context) (*GetAppTablesResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if b.qpAppId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "appId is required for getAppTables",
			},
		}
	}
	// Build query params
	params := &generated.GetAppTablesParams{}
	if b.qpAppId != nil {
		params.AppId = *b.qpAppId
	}

	resp, err := b.client.API().GetAppTablesWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GetAppTablesResult{}
	result.Items = *resp.JSON200

	return result, nil
}


// GetFieldResult contains the result of a getField call.
type GetFieldResult struct {
	FieldHelp string
	Audited bool
	Bold bool
	Required bool
	AppearsByDefault bool
	Id int64
	Mode string
	NoWrap bool
	Label string
	FindEnabled bool
	Unique bool
	FieldType string
	DoesDataCopy bool
}


// GetFieldBuilder provides a fluent API for the getField operation.
// Get field
type GetFieldBuilder struct {
	client  *Client
	table   string
	tableID string
	fieldId int
	qpIncludeFieldPerms *bool
	params  map[string]any
	err     error
}

// GetField starts building a getField request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetField(fieldId int, table string) *GetFieldBuilder {
	b := &GetFieldBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.fieldId = fieldId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// IncludeFieldPerms Set to 'true' if you'd like to get back the custom permissions for the field(s).
func (b *GetFieldBuilder) IncludeFieldPerms(value bool) *GetFieldBuilder {
	if b.err != nil {
		return b
	}
	b.qpIncludeFieldPerms = &value
	return b
}


// Run executes the getField request.
func (b *GetFieldBuilder) Run(ctx context.Context) (*GetFieldResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetFieldParams{}
	params.TableId = b.tableID
	if b.qpIncludeFieldPerms != nil {
		params.IncludeFieldPerms = b.qpIncludeFieldPerms
	}

	resp, err := b.client.API().GetFieldWithResponse(ctx, b.fieldId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GetFieldResult{}
	if resp.JSON200.FieldHelp != nil {
		result.FieldHelp = *resp.JSON200.FieldHelp
	}
	if resp.JSON200.Audited != nil {
		result.Audited = *resp.JSON200.Audited
	}
	if resp.JSON200.Bold != nil {
		result.Bold = *resp.JSON200.Bold
	}
	if resp.JSON200.Required != nil {
		result.Required = *resp.JSON200.Required
	}
	if resp.JSON200.AppearsByDefault != nil {
		result.AppearsByDefault = *resp.JSON200.AppearsByDefault
	}
	result.Id = resp.JSON200.Id
	if resp.JSON200.Mode != nil {
		result.Mode = *resp.JSON200.Mode
	}
	if resp.JSON200.NoWrap != nil {
		result.NoWrap = *resp.JSON200.NoWrap
	}
	if resp.JSON200.Label != nil {
		result.Label = *resp.JSON200.Label
	}
	if resp.JSON200.FindEnabled != nil {
		result.FindEnabled = *resp.JSON200.FindEnabled
	}
	if resp.JSON200.Unique != nil {
		result.Unique = *resp.JSON200.Unique
	}
	if resp.JSON200.FieldType != nil {
		result.FieldType = *resp.JSON200.FieldType
	}
	if resp.JSON200.DoesDataCopy != nil {
		result.DoesDataCopy = *resp.JSON200.DoesDataCopy
	}

	return result, nil
}


// GetFieldUsageResult contains the result of a getFieldUsage call.
type GetFieldUsageResult struct {
	Items []generated.GetFieldUsage_200_Item
}


// GetFieldUsageBuilder provides a fluent API for the getFieldUsage operation.
// Get usage for a field
type GetFieldUsageBuilder struct {
	client  *Client
	table   string
	tableID string
	fieldId int
	params  map[string]any
	err     error
}

// GetFieldUsage starts building a getFieldUsage request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetFieldUsage(fieldId int, table string) *GetFieldUsageBuilder {
	b := &GetFieldUsageBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.fieldId = fieldId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the getFieldUsage request.
func (b *GetFieldUsageBuilder) Run(ctx context.Context) (*GetFieldUsageResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetFieldUsageParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().GetFieldUsageWithResponse(ctx, b.fieldId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GetFieldUsageResult{}
	result.Items = *resp.JSON200

	return result, nil
}


// FieldDetails contains the result of a getFields call.
type FieldDetails struct {
	ID int
	Label string
	FieldType string
}

// GetFieldsBuilder provides a fluent API for the getFields operation.
// Get fields for a table
type GetFieldsBuilder struct {
	client  *Client
	table   string
	tableID string
	qpIncludeFieldPerms *bool
	params  map[string]any
	err     error
}

// GetFields starts building a getFields request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetFields(table string) *GetFieldsBuilder {
	b := &GetFieldsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// IncludeFieldPerms Set to 'true' if you'd like to get back the custom permissions for the field(s).
func (b *GetFieldsBuilder) IncludeFieldPerms(value bool) *GetFieldsBuilder {
	if b.err != nil {
		return b
	}
	b.qpIncludeFieldPerms = &value
	return b
}


// Run executes the getFields request.
func (b *GetFieldsBuilder) Run(ctx context.Context) ([]FieldDetails, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetFieldsParams{}
	params.TableId = b.tableID
	if b.qpIncludeFieldPerms != nil {
		params.IncludeFieldPerms = b.qpIncludeFieldPerms
	}

	resp, err := b.client.API().GetFieldsWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result from array response
	var results []FieldDetails
	for _, src := range *resp.JSON200 {
		item := FieldDetails{}
		item.ID = int(src.Id)
		if src.Label != nil {
			item.Label = *src.Label
		}
		if src.FieldType != nil {
			item.FieldType = *src.FieldType
		}
		results = append(results, item)
	}
	return results, nil
}


// GetFieldsUsageResult contains the result of a getFieldsUsage call.
type GetFieldsUsageResult struct {
	Items []generated.GetFieldsUsage_200_Item
}


// GetFieldsUsageBuilder provides a fluent API for the getFieldsUsage operation.
// Get usage for all fields
type GetFieldsUsageBuilder struct {
	client  *Client
	table   string
	tableID string
	qpSkip *int
	qpTop *int
	params  map[string]any
	err     error
}

// GetFieldsUsage starts building a getFieldsUsage request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetFieldsUsage(table string) *GetFieldsUsageBuilder {
	b := &GetFieldsUsageBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Skip The number of fields to skip from the list.
func (b *GetFieldsUsageBuilder) Skip(value int) *GetFieldsUsageBuilder {
	if b.err != nil {
		return b
	}
	b.qpSkip = &value
	return b
}


// Top The maximum number of fields to return.
func (b *GetFieldsUsageBuilder) Top(value int) *GetFieldsUsageBuilder {
	if b.err != nil {
		return b
	}
	b.qpTop = &value
	return b
}


// Run executes the getFieldsUsage request.
func (b *GetFieldsUsageBuilder) Run(ctx context.Context) (*GetFieldsUsageResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetFieldsUsageParams{}
	params.TableId = b.tableID
	if b.qpSkip != nil {
		params.Skip = b.qpSkip
	}
	if b.qpTop != nil {
		params.Top = b.qpTop
	}

	resp, err := b.client.API().GetFieldsUsageWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GetFieldsUsageResult{}
	result.Items = *resp.JSON200

	return result, nil
}



// GetRelationshipsBuilder provides a fluent API for the getRelationships operation.
// Get all relationships
type GetRelationshipsBuilder struct {
	client  *Client
	table   string
	tableID string
	tableId string
	qpSkip *int
	params  map[string]any
	err     error
}

// GetRelationships starts building a getRelationships request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetRelationships(table string) *GetRelationshipsBuilder {
	b := &GetRelationshipsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Skip The number of relationships to skip.
func (b *GetRelationshipsBuilder) Skip(value int) *GetRelationshipsBuilder {
	if b.err != nil {
		return b
	}
	b.qpSkip = &value
	return b
}


// Run executes the getRelationships request.
func (b *GetRelationshipsBuilder) Run(ctx context.Context) (*generated.GetRelationshipsResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build query params
	params := &generated.GetRelationshipsParams{}
	if b.qpSkip != nil {
		params.Skip = b.qpSkip
	}

	resp, err := b.client.API().GetRelationshipsWithResponse(ctx, b.tableId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}


// GetReportResult contains the result of a getReport call.
type GetReportResult struct {
	Id string
	OwnerId int
	UsedLast string
	UsedCount int
	Name string
	Type string
	Description string
}


// GetReportBuilder provides a fluent API for the getReport operation.
// Get a report
type GetReportBuilder struct {
	client  *Client
	table   string
	tableID string
	reportId string
	params  map[string]any
	err     error
}

// GetReport starts building a getReport request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetReport(reportId string, table string) *GetReportBuilder {
	b := &GetReportBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.reportId = reportId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the getReport request.
func (b *GetReportBuilder) Run(ctx context.Context) (*GetReportResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetReportParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().GetReportWithResponse(ctx, b.reportId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GetReportResult{}
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}
	if resp.JSON200.OwnerId != nil {
		result.OwnerId = *resp.JSON200.OwnerId
	}
	if resp.JSON200.UsedLast != nil {
		result.UsedLast = *resp.JSON200.UsedLast
	}
	if resp.JSON200.UsedCount != nil {
		result.UsedCount = *resp.JSON200.UsedCount
	}
	if resp.JSON200.Name != nil {
		result.Name = *resp.JSON200.Name
	}
	if resp.JSON200.Type != nil {
		result.Type = *resp.JSON200.Type
	}
	if resp.JSON200.Description != nil {
		result.Description = *resp.JSON200.Description
	}

	return result, nil
}


// GetTableResult contains the result of a getTable call.
type GetTableResult struct {
	Id string
	Alias string
	DefaultSortFieldId int
	Name string
	Updated string
	NextFieldId int
	DefaultSortOrder string
	SpaceUsed string
	NextRecordId int
	KeyFieldId int
	SingleRecordName string
	PluralRecordName string
	SizeLimit string
	SpaceRemaining string
	Description string
	Created string
}


// GetTableBuilder provides a fluent API for the getTable operation.
// Get a table
type GetTableBuilder struct {
	client  *Client
	table   string
	tableID string
	tableId string
	qpAppId *string
	params  map[string]any
	err     error
}

// GetTable starts building a getTable request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetTable(table string) *GetTableBuilder {
	b := &GetTableBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// AppId The unique identifier of an app
func (b *GetTableBuilder) AppId(value string) *GetTableBuilder {
	if b.err != nil {
		return b
	}
	b.qpAppId = &value
	return b
}


// Run executes the getTable request.
func (b *GetTableBuilder) Run(ctx context.Context) (*GetTableResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if b.qpAppId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "appId is required for getTable",
			},
		}
	}
	// Build query params
	params := &generated.GetTableParams{}
	if b.qpAppId != nil {
		params.AppId = *b.qpAppId
	}

	resp, err := b.client.API().GetTableWithResponse(ctx, b.tableId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GetTableResult{}
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}
	if resp.JSON200.Alias != nil {
		result.Alias = *resp.JSON200.Alias
	}
	if resp.JSON200.DefaultSortFieldId != nil {
		result.DefaultSortFieldId = *resp.JSON200.DefaultSortFieldId
	}
	if resp.JSON200.Name != nil {
		result.Name = *resp.JSON200.Name
	}
	if resp.JSON200.Updated != nil {
		result.Updated = *resp.JSON200.Updated
	}
	if resp.JSON200.NextFieldId != nil {
		result.NextFieldId = *resp.JSON200.NextFieldId
	}
	if resp.JSON200.DefaultSortOrder != nil {
		result.DefaultSortOrder = string(*resp.JSON200.DefaultSortOrder)
	}
	if resp.JSON200.SpaceUsed != nil {
		result.SpaceUsed = *resp.JSON200.SpaceUsed
	}
	if resp.JSON200.NextRecordId != nil {
		result.NextRecordId = *resp.JSON200.NextRecordId
	}
	if resp.JSON200.KeyFieldId != nil {
		result.KeyFieldId = *resp.JSON200.KeyFieldId
	}
	if resp.JSON200.SingleRecordName != nil {
		result.SingleRecordName = *resp.JSON200.SingleRecordName
	}
	if resp.JSON200.PluralRecordName != nil {
		result.PluralRecordName = *resp.JSON200.PluralRecordName
	}
	if resp.JSON200.SizeLimit != nil {
		result.SizeLimit = *resp.JSON200.SizeLimit
	}
	if resp.JSON200.SpaceRemaining != nil {
		result.SpaceRemaining = *resp.JSON200.SpaceRemaining
	}
	if resp.JSON200.Description != nil {
		result.Description = *resp.JSON200.Description
	}
	if resp.JSON200.Created != nil {
		result.Created = *resp.JSON200.Created
	}

	return result, nil
}


// GetTableReportsResult contains the result of a getTableReports call.
type GetTableReportsResult struct {
	Items []generated.GetTableReports_200_Item
}


// GetTableReportsBuilder provides a fluent API for the getTableReports operation.
// Get reports for a table
type GetTableReportsBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// GetTableReports starts building a getTableReports request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetTableReports(table string) *GetTableReportsBuilder {
	b := &GetTableReportsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the getTableReports request.
func (b *GetTableReportsBuilder) Run(ctx context.Context) (*GetTableReportsResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetTableReportsParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().GetTableReportsWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GetTableReportsResult{}
	result.Items = *resp.JSON200

	return result, nil
}


// GetTempTokenDBIDResult contains the result of a getTempTokenDBID call.
type GetTempTokenDBIDResult struct {
	TemporaryAuthorization string
}


// GetTempTokenDBIDBuilder provides a fluent API for the getTempTokenDBID operation.
// Get a temporary token for a dbid
type GetTempTokenDBIDBuilder struct {
	client  *Client
	dbid string
	params  map[string]any
	err     error
}

// GetTempTokenDBID starts building a getTempTokenDBID request.
func (c *Client) GetTempTokenDBID(dbid string) *GetTempTokenDBIDBuilder {
	b := &GetTempTokenDBIDBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.dbid = dbid
	return b
}



// Run executes the getTempTokenDBID request.
func (b *GetTempTokenDBIDBuilder) Run(ctx context.Context) (*GetTempTokenDBIDResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build query params
	params := &generated.GetTempTokenDBIDParams{}

	resp, err := b.client.API().GetTempTokenDBIDWithResponse(ctx, b.dbid, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &GetTempTokenDBIDResult{}
	if resp.JSON200.TemporaryAuthorization != nil {
		result.TemporaryAuthorization = *resp.JSON200.TemporaryAuthorization
	}

	return result, nil
}



// GetUsersBuilder provides a fluent API for the getUsers operation.
// Get users
type GetUsersBuilder struct {
	client  *Client
	qpAccountId *float32
	params  map[string]any
	err     error
}

// GetUsers starts building a getUsers request.
func (c *Client) GetUsers() *GetUsersBuilder {
	b := &GetUsersBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// AppIds When provided, the returned users will be narrowed down only to the users assigned to the app id's provided in this list. The provided app id's should belong to the same account.
func (b *GetUsersBuilder) AppIds(values ...string) *GetUsersBuilder {
	if b.err != nil {
		return b
	}
	b.params["appIds"] = values
	return b
}


// NextPageToken Next page token used to get the next 'page' of results when available. When this field is empty, the first page is returned.
func (b *GetUsersBuilder) NextPageToken(value string) *GetUsersBuilder {
	if b.err != nil {
		return b
	}
	b.params["nextPageToken"] = value
	return b
}


// Emails When provided, the returned users will be narrowed down only to the users included in this list.
func (b *GetUsersBuilder) Emails(values ...string) *GetUsersBuilder {
	if b.err != nil {
		return b
	}
	b.params["emails"] = values
	return b
}



// AccountId The account id being used to get users. If no value is specified, the first account associated with the requesting user token is chosen.
func (b *GetUsersBuilder) AccountId(value float32) *GetUsersBuilder {
	if b.err != nil {
		return b
	}
	b.qpAccountId = &value
	return b
}


// Run executes the getUsers request.
func (b *GetUsersBuilder) Run(ctx context.Context) (*generated.GetUsersResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.GetUsersJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.GetUsersParams{}
	if b.qpAccountId != nil {
		params.AccountId = b.qpAccountId
	}

	resp, err := b.client.API().GetUsersWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}


// PlatformAnalyticEventSummariesResult contains the result of a platformAnalyticEventSummaries call.
type PlatformAnalyticEventSummariesResult struct {
	Start time.Time
	End time.Time
	GroupBy string
	AccountId string
}


// PlatformAnalyticEventSummariesBuilder provides a fluent API for the platformAnalyticEventSummaries operation.
// Get event summaries
type PlatformAnalyticEventSummariesBuilder struct {
	client  *Client
	qpAccountId *float32
	params  map[string]any
	err     error
}

// PlatformAnalyticEventSummaries starts building a platformAnalyticEventSummaries request.
func (c *Client) PlatformAnalyticEventSummaries() *PlatformAnalyticEventSummariesBuilder {
	b := &PlatformAnalyticEventSummariesBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Start The start date and time of the requested summaries in ISO 8601 time format.
func (b *PlatformAnalyticEventSummariesBuilder) Start(value string) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.params["start"] = value
	return b
}


// End The end date and time of the requested summaries in ISO 8601 time format.
func (b *PlatformAnalyticEventSummariesBuilder) End(value string) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.params["end"] = value
	return b
}


// GroupBy How the events should be grouped.
func (b *PlatformAnalyticEventSummariesBuilder) GroupBy(value string) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.params["groupBy"] = value
	return b
}


// NextToken A pagination token from a previous response. Used to fetch the next page.
func (b *PlatformAnalyticEventSummariesBuilder) NextToken(value string) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.params["nextToken"] = value
	return b
}


// Where A list of items to filter events by. Only events which match ALL criteria will be included in the results.
func (b *PlatformAnalyticEventSummariesBuilder) Where(values ...map[string]any) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.params["where"] = values
	return b
}



// AccountId The ID of the account to query. If no value is specified, the first account matching the provided domain is chosen.
func (b *PlatformAnalyticEventSummariesBuilder) AccountId(value float32) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.qpAccountId = &value
	return b
}


// Run executes the platformAnalyticEventSummaries request.
func (b *PlatformAnalyticEventSummariesBuilder) Run(ctx context.Context) (*PlatformAnalyticEventSummariesResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["start"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "start is required for platformAnalyticEventSummaries",
			},
		}
	}
	if _, ok := b.params["end"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "end is required for platformAnalyticEventSummaries",
			},
		}
	}
	if _, ok := b.params["groupBy"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "groupBy is required for platformAnalyticEventSummaries",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.PlatformAnalyticEventSummariesJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.PlatformAnalyticEventSummariesParams{}
	if b.qpAccountId != nil {
		params.AccountId = b.qpAccountId
	}

	resp, err := b.client.API().PlatformAnalyticEventSummariesWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &PlatformAnalyticEventSummariesResult{}
	result.Start = resp.JSON200.Start
	result.End = resp.JSON200.End
	result.GroupBy = string(resp.JSON200.GroupBy)
	result.AccountId = resp.JSON200.AccountId

	return result, nil
}


// PlatformAnalyticReadsResult contains the result of a platformAnalyticReads call.
type PlatformAnalyticReadsResult struct {
	Date types.Date
}


// PlatformAnalyticReadsBuilder provides a fluent API for the platformAnalyticReads operation.
// Get read summaries
type PlatformAnalyticReadsBuilder struct {
	client  *Client
	qpDay *types.Date
	params  map[string]any
	err     error
}

// PlatformAnalyticReads starts building a platformAnalyticReads request.
func (c *Client) PlatformAnalyticReads() *PlatformAnalyticReadsBuilder {
	b := &PlatformAnalyticReadsBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// Day The date for which read summaries need to be fetched. This must be date-time only, as YYYY-MM-DD, and a valid date in the past.
func (b *PlatformAnalyticReadsBuilder) Day(value types.Date) *PlatformAnalyticReadsBuilder {
	if b.err != nil {
		return b
	}
	b.qpDay = &value
	return b
}


// Run executes the platformAnalyticReads request.
func (b *PlatformAnalyticReadsBuilder) Run(ctx context.Context) (*PlatformAnalyticReadsResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build query params
	params := &generated.PlatformAnalyticReadsParams{}
	if b.qpDay != nil {
		params.Day = b.qpDay
	}

	resp, err := b.client.API().PlatformAnalyticReadsWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &PlatformAnalyticReadsResult{}
	result.Date = resp.JSON200.Date

	return result, nil
}


// RemoveManagersFromGroupResult contains the result of a removeManagersFromGroup call.
type RemoveManagersFromGroupResult struct {
	Failure []string
	Success []string
}


// RemoveManagersFromGroupBuilder provides a fluent API for the removeManagersFromGroup operation.
// Remove managers
type RemoveManagersFromGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// RemoveManagersFromGroup starts building a removeManagersFromGroup request.
func (c *Client) RemoveManagersFromGroup(gid float32) *RemoveManagersFromGroupBuilder {
	b := &RemoveManagersFromGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the removeManagersFromGroup request.
func (b *RemoveManagersFromGroupBuilder) Run(ctx context.Context) (*RemoveManagersFromGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RemoveManagersFromGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().RemoveManagersFromGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &RemoveManagersFromGroupResult{}
	result.Failure = resp.JSON200.Failure
	result.Success = resp.JSON200.Success

	return result, nil
}


// RemoveMembersFromGroupResult contains the result of a removeMembersFromGroup call.
type RemoveMembersFromGroupResult struct {
	Failure []string
	Success []string
}


// RemoveMembersFromGroupBuilder provides a fluent API for the removeMembersFromGroup operation.
// Remove members
type RemoveMembersFromGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// RemoveMembersFromGroup starts building a removeMembersFromGroup request.
func (c *Client) RemoveMembersFromGroup(gid float32) *RemoveMembersFromGroupBuilder {
	b := &RemoveMembersFromGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the removeMembersFromGroup request.
func (b *RemoveMembersFromGroupBuilder) Run(ctx context.Context) (*RemoveMembersFromGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RemoveMembersFromGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().RemoveMembersFromGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &RemoveMembersFromGroupResult{}
	result.Failure = resp.JSON200.Failure
	result.Success = resp.JSON200.Success

	return result, nil
}


// RemoveSubgroupsFromGroupResult contains the result of a removeSubgroupsFromGroup call.
type RemoveSubgroupsFromGroupResult struct {
	Failure []string
	Success []string
}


// RemoveSubgroupsFromGroupBuilder provides a fluent API for the removeSubgroupsFromGroup operation.
// Remove child groups
type RemoveSubgroupsFromGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// RemoveSubgroupsFromGroup starts building a removeSubgroupsFromGroup request.
func (c *Client) RemoveSubgroupsFromGroup(gid float32) *RemoveSubgroupsFromGroupBuilder {
	b := &RemoveSubgroupsFromGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the removeSubgroupsFromGroup request.
func (b *RemoveSubgroupsFromGroupBuilder) Run(ctx context.Context) (*RemoveSubgroupsFromGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RemoveSubgroupsFromGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().RemoveSubgroupsFromGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &RemoveSubgroupsFromGroupResult{}
	result.Failure = resp.JSON200.Failure
	result.Success = resp.JSON200.Success

	return result, nil
}


// RunFormulaResult contains the result of a runFormula call.
type RunFormulaResult struct {
	Result string
}


// RunFormulaBuilder provides a fluent API for the runFormula operation.
// Run a formula
type RunFormulaBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// RunFormula starts building a runFormula request.
func (c *Client) RunFormula() *RunFormulaBuilder {
	b := &RunFormulaBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// From The unique identifier (dbid) of the table.
func (b *RunFormulaBuilder) From(value string) *RunFormulaBuilder {
	if b.err != nil {
		return b
	}
	b.params["from"] = value
	return b
}


// Formula The formula to run. This must be a valid Quickbase formula.
func (b *RunFormulaBuilder) Formula(value string) *RunFormulaBuilder {
	if b.err != nil {
		return b
	}
	b.params["formula"] = value
	return b
}


// Rid The record ID to run the formula against. Only necessary for formulas that are run in the context of a record. For example, the formula User() does not need a record ID.
func (b *RunFormulaBuilder) Rid(value int) *RunFormulaBuilder {
	if b.err != nil {
		return b
	}
	b.params["rid"] = value
	return b
}



// Run executes the runFormula request.
func (b *RunFormulaBuilder) Run(ctx context.Context) (*RunFormulaResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["formula"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "formula is required for runFormula",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RunFormulaJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().RunFormulaWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &RunFormulaResult{}
	if resp.JSON200.Result != nil {
		result.Result = *resp.JSON200.Result
	}

	return result, nil
}



// RunReportBuilder provides a fluent API for the runReport operation.
// Run a report
type RunReportBuilder struct {
	client  *Client
	table   string
	tableID string
	reportId string
	qpSkip *int
	qpTop *int
	params  map[string]any
	err     error
}

// RunReport starts building a runReport request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) RunReport(reportId string, table string) *RunReportBuilder {
	b := &RunReportBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.reportId = reportId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Skip The number of records to skip. You can set this value when paginating through a set of results.
func (b *RunReportBuilder) Skip(value int) *RunReportBuilder {
	if b.err != nil {
		return b
	}
	b.qpSkip = &value
	return b
}


// Top The maximum number of records to return. You can override the default Quickbase pagination to get more or fewer results. If your requested value here exceeds the dynamic maximums, we will return a subset of results and the rest can be gathered in subsequent API calls.
func (b *RunReportBuilder) Top(value int) *RunReportBuilder {
	if b.err != nil {
		return b
	}
	b.qpTop = &value
	return b
}


// Run executes the runReport request.
func (b *RunReportBuilder) Run(ctx context.Context) (*generated.RunReportResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RunReportJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.RunReportParams{}
	params.TableId = b.tableID
	if b.qpSkip != nil {
		params.Skip = b.qpSkip
	}
	if b.qpTop != nil {
		params.Top = b.qpTop
	}

	resp, err := b.client.API().RunReportWithResponse(ctx, b.reportId, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}


// TransferUserTokenResult contains the result of a transferUserToken call.
type TransferUserTokenResult struct {
	Id int
	Name string
	Active bool
	LastUsed string
	Description string
}


// TransferUserTokenBuilder provides a fluent API for the transferUserToken operation.
// Transfer a user token
type TransferUserTokenBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// TransferUserToken starts building a transferUserToken request.
func (c *Client) TransferUserToken() *TransferUserTokenBuilder {
	b := &TransferUserTokenBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// From The id of the user to transfer the user token from
func (b *TransferUserTokenBuilder) From(value string) *TransferUserTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["from"] = value
	return b
}


// To The id of the user to transfer the user token to
func (b *TransferUserTokenBuilder) To(value string) *TransferUserTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["to"] = value
	return b
}


// Id The id of the user token to transfer
func (b *TransferUserTokenBuilder) Id(value float64) *TransferUserTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["id"] = value
	return b
}



// Run executes the transferUserToken request.
func (b *TransferUserTokenBuilder) Run(ctx context.Context) (*TransferUserTokenResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.TransferUserTokenJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().TransferUserTokenWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &TransferUserTokenResult{}
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}
	if resp.JSON200.Name != nil {
		result.Name = *resp.JSON200.Name
	}
	if resp.JSON200.Active != nil {
		result.Active = *resp.JSON200.Active
	}
	if resp.JSON200.LastUsed != nil {
		result.LastUsed = *resp.JSON200.LastUsed
	}
	if resp.JSON200.Description != nil {
		result.Description = *resp.JSON200.Description
	}

	return result, nil
}


// UndenyUsersResult contains the result of a undenyUsers call.
type UndenyUsersResult struct {
	Failure []string
	Success []string
}


// UndenyUsersBuilder provides a fluent API for the undenyUsers operation.
// Undeny users
type UndenyUsersBuilder struct {
	client  *Client
	qpAccountId *float32
	params  map[string]any
	err     error
}

// UndenyUsers starts building a undenyUsers request.
func (c *Client) UndenyUsers() *UndenyUsersBuilder {
	b := &UndenyUsersBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// AccountId The account id being used to undeny users. If no value is specified, the first account associated with the requesting user token is chosen.
func (b *UndenyUsersBuilder) AccountId(value float32) *UndenyUsersBuilder {
	if b.err != nil {
		return b
	}
	b.qpAccountId = &value
	return b
}


// Run executes the undenyUsers request.
func (b *UndenyUsersBuilder) Run(ctx context.Context) (*UndenyUsersResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UndenyUsersJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.UndenyUsersParams{}
	if b.qpAccountId != nil {
		params.AccountId = b.qpAccountId
	}

	resp, err := b.client.API().UndenyUsersWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &UndenyUsersResult{}
	result.Failure = resp.JSON200.Failure
	result.Success = resp.JSON200.Success

	return result, nil
}


// UpdateAppResult contains the result of a updateApp call.
type UpdateAppResult struct {
	Updated string
	HasEveryoneOnTheInternet bool
	Name string
	Created string
	DateFormat string
	TimeZone string
	Id string
	DataClassification string
	AncestorId string
	Description string
}


// UpdateAppBuilder provides a fluent API for the updateApp operation.
// Update an app
type UpdateAppBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// UpdateApp starts building a updateApp request.
func (c *Client) UpdateApp(appId string) *UpdateAppBuilder {
	b := &UpdateAppBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}


// Variables The app variables. A maximum of 10 variables can be updated at a time. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
func (b *UpdateAppBuilder) Variables(values ...map[string]any) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["variables"] = values
	return b
}


// Name The name for the app.
func (b *UpdateAppBuilder) Name(value string) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}


// HideFromPublic Hide from public application searches
func (b *UpdateAppBuilder) HideFromPublic(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hideFromPublic"] = value
	b.params["securityProperties"] = nested
	return b
}


// MustBeRealmApproved Only "approved" users may access this application
func (b *UpdateAppBuilder) MustBeRealmApproved(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["mustBeRealmApproved"] = value
	b.params["securityProperties"] = nested
	return b
}


// AllowClone Allow users who are not administrators to copy
func (b *UpdateAppBuilder) AllowClone(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowClone"] = value
	b.params["securityProperties"] = nested
	return b
}


// UseIPFilter Only users logging in from "approved" IP addresses may access this application
func (b *UpdateAppBuilder) UseIPFilter(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useIPFilter"] = value
	b.params["securityProperties"] = nested
	return b
}


// AllowExport Allow users who are not administrators to export data
func (b *UpdateAppBuilder) AllowExport(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowExport"] = value
	b.params["securityProperties"] = nested
	return b
}


// EnableAppTokens Require Application Tokens
func (b *UpdateAppBuilder) EnableAppTokens(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["enableAppTokens"] = value
	b.params["securityProperties"] = nested
	return b
}


// Description The description for the app.
func (b *UpdateAppBuilder) Description(value string) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}



// Run executes the updateApp request.
func (b *UpdateAppBuilder) Run(ctx context.Context) (*UpdateAppResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateAppJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().UpdateAppWithResponse(ctx, b.appId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &UpdateAppResult{}
	if resp.JSON200.Updated != nil {
		result.Updated = *resp.JSON200.Updated
	}
	if resp.JSON200.HasEveryoneOnTheInternet != nil {
		result.HasEveryoneOnTheInternet = *resp.JSON200.HasEveryoneOnTheInternet
	}
	result.Name = resp.JSON200.Name
	if resp.JSON200.Created != nil {
		result.Created = *resp.JSON200.Created
	}
	if resp.JSON200.DateFormat != nil {
		result.DateFormat = *resp.JSON200.DateFormat
	}
	if resp.JSON200.TimeZone != nil {
		result.TimeZone = *resp.JSON200.TimeZone
	}
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}
	if resp.JSON200.DataClassification != nil {
		result.DataClassification = *resp.JSON200.DataClassification
	}
	if resp.JSON200.AncestorId != nil {
		result.AncestorId = *resp.JSON200.AncestorId
	}
	if resp.JSON200.Description != nil {
		result.Description = *resp.JSON200.Description
	}

	return result, nil
}


// UpdateFieldResult contains the result of a updateField call.
type UpdateFieldResult struct {
	NoWrap bool
	Bold bool
	AppearsByDefault bool
	FindEnabled bool
	Audited bool
	FieldType string
	Required bool
	Unique bool
	DoesDataCopy bool
	FieldHelp string
	Id int64
	Mode string
	Label string
}


// UpdateFieldBuilder provides a fluent API for the updateField operation.
// Update a field
type UpdateFieldBuilder struct {
	client  *Client
	table   string
	tableID string
	fieldId int
	params  map[string]any
	err     error
}

// UpdateField starts building a updateField request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) UpdateField(fieldId int, table string) *UpdateFieldBuilder {
	b := &UpdateFieldBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.fieldId = fieldId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// Label The label (name) of the field.
func (b *UpdateFieldBuilder) Label(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["label"] = value
	return b
}


// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs. You can only set this property to "true" if the app has audit logs enabled. See Enable data change logs under [Quickbase Audit Logs](https://help.quickbase.com/user-assistance/audit_logs.html).
func (b *UpdateFieldBuilder) Audited(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["audited"] = value
	return b
}


// Required Indicates if the field is required (i.e. if every record must have a non-null value in this field). If you attempt to change a field from not-required to required, and the table currently contains records that have null values in that field, you will get an error indicating that there are null values of the field. In this case you need to find and update those records with null values of the field before changing the field to required.
func (b *UpdateFieldBuilder) Required(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["required"] = value
	return b
}


// UseNewWindow Indicates if the file should open a new window when a user clicks it within the product.
func (b *UpdateFieldBuilder) UseNewWindow(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useNewWindow"] = value
	b.params["properties"] = nested
	return b
}


// DoesTotal Whether this field totals in reports within the product.
func (b *UpdateFieldBuilder) DoesTotal(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["doesTotal"] = value
	b.params["properties"] = nested
	return b
}


// SummaryQuery The summary query.
func (b *UpdateFieldBuilder) SummaryQuery(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["summaryQuery"] = value
	b.params["properties"] = nested
	return b
}


// DisplayUser The configured option for how users display within the product.
func (b *UpdateFieldBuilder) DisplayUser(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayUser"] = value
	b.params["properties"] = nested
	return b
}


// SortAsGiven Indicates if the listed entries sort as entered vs alphabetically.
func (b *UpdateFieldBuilder) SortAsGiven(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sortAsGiven"] = value
	b.params["properties"] = nested
	return b
}


// DefaultCountryCode Controls the default country shown on international phone widgets on forms. Country code should be entered in the ISO 3166-1 alpha-2 format.
func (b *UpdateFieldBuilder) DefaultCountryCode(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultCountryCode"] = value
	b.params["properties"] = nested
	return b
}


// BlankIsZero Whether a blank value is treated the same as 0 in calculations within the product.
func (b *UpdateFieldBuilder) BlankIsZero(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["blankIsZero"] = value
	b.params["properties"] = nested
	return b
}


// AllowMentions If someone can @mention users in the rich text field to generate an email notification.
func (b *UpdateFieldBuilder) AllowMentions(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowMentions"] = value
	b.params["properties"] = nested
	return b
}


// Format The format to display time.
func (b *UpdateFieldBuilder) Format(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["format"] = value
	b.params["properties"] = nested
	return b
}


// LookupTargetFieldId The id of the field that is the target on the parent table for this lookup.
func (b *UpdateFieldBuilder) LookupTargetFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["lookupTargetFieldId"] = value
	b.params["properties"] = nested
	return b
}


// DoesAverage Whether this field averages in reports within the product.
func (b *UpdateFieldBuilder) DoesAverage(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["doesAverage"] = value
	b.params["properties"] = nested
	return b
}


// NumberFormat The format used for displaying numeric values in the product (decimal, separators, digit group).
func (b *UpdateFieldBuilder) NumberFormat(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["numberFormat"] = value
	b.params["properties"] = nested
	return b
}


// DisplayDayOfWeek Indicates whether to display the day of the week within the product.
func (b *UpdateFieldBuilder) DisplayDayOfWeek(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayDayOfWeek"] = value
	b.params["properties"] = nested
	return b
}


// SortAlpha Whether to sort alphabetically, default sort is by record ID.
func (b *UpdateFieldBuilder) SortAlpha(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sortAlpha"] = value
	b.params["properties"] = nested
	return b
}


// AutoSave Whether the link field will auto save.
func (b *UpdateFieldBuilder) AutoSave(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["autoSave"] = value
	b.params["properties"] = nested
	return b
}


// AllowNewChoices Indicates if users can add new choices to a selection list.
func (b *UpdateFieldBuilder) AllowNewChoices(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowNewChoices"] = value
	b.params["properties"] = nested
	return b
}


// SummaryFunction The accumulation type for the summary field.
func (b *UpdateFieldBuilder) SummaryFunction(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["summaryFunction"] = value
	b.params["properties"] = nested
	return b
}


// NumLines The number of lines shown in Quickbase for this text field.
func (b *UpdateFieldBuilder) NumLines(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["numLines"] = value
	b.params["properties"] = nested
	return b
}


// DisplayEmail How the email is displayed.
func (b *UpdateFieldBuilder) DisplayEmail(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayEmail"] = value
	b.params["properties"] = nested
	return b
}


// CurrencySymbol The current symbol used when displaying field values within the product.
func (b *UpdateFieldBuilder) CurrencySymbol(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["currencySymbol"] = value
	b.params["properties"] = nested
	return b
}


// Exact Whether an exact match is required for a report link.
func (b *UpdateFieldBuilder) Exact(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["exact"] = value
	b.params["properties"] = nested
	return b
}


// Hours24 Indicates whether or not to display time in the 24-hour format within the product.
func (b *UpdateFieldBuilder) Hours24(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hours24"] = value
	b.params["properties"] = nested
	return b
}


// AppendOnly Whether this field is append only.
func (b *UpdateFieldBuilder) AppendOnly(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["appendOnly"] = value
	b.params["properties"] = nested
	return b
}


// DefaultKind The user default type.
func (b *UpdateFieldBuilder) DefaultKind(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultKind"] = value
	b.params["properties"] = nested
	return b
}


// Width The field's html input width in the product.
func (b *UpdateFieldBuilder) Width(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["width"] = value
	b.params["properties"] = nested
	return b
}


// MaxVersions The maximum number of versions configured for a file attachment.
func (b *UpdateFieldBuilder) MaxVersions(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["maxVersions"] = value
	b.params["properties"] = nested
	return b
}


// DefaultToday Indicates if the field value is defaulted today for new records.
func (b *UpdateFieldBuilder) DefaultToday(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultToday"] = value
	b.params["properties"] = nested
	return b
}


// Abbreviate Don't show the URL protocol when showing the URL.
func (b *UpdateFieldBuilder) Abbreviate(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["abbreviate"] = value
	b.params["properties"] = nested
	return b
}


// AppearsAs The link text, if empty, the url will be used as link text.
func (b *UpdateFieldBuilder) AppearsAs(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["appearsAs"] = value
	b.params["properties"] = nested
	return b
}


// DisplayAsLink Indicates if a field that is part of the relationship should be shown as a hyperlink to the parent record within the product.
func (b *UpdateFieldBuilder) DisplayAsLink(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayAsLink"] = value
	b.params["properties"] = nested
	return b
}


// UseI18NFormat Whether phone numbers should be in E.164 standard international format
func (b *UpdateFieldBuilder) UseI18NFormat(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useI18NFormat"] = value
	b.params["properties"] = nested
	return b
}


// DisplayTimezone Indicates whether to display the timezone within the product.
func (b *UpdateFieldBuilder) DisplayTimezone(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayTimezone"] = value
	b.params["properties"] = nested
	return b
}


// OpenTargetIn Indicates which target the URL should open in when a user clicks it within the product.
func (b *UpdateFieldBuilder) OpenTargetIn(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["openTargetIn"] = value
	b.params["properties"] = nested
	return b
}


// DefaultValue The default value configured for a field when a new record is added.
func (b *UpdateFieldBuilder) DefaultValue(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultValue"] = value
	b.params["properties"] = nested
	return b
}


// DisplayRelative Whether to display time as relative.
func (b *UpdateFieldBuilder) DisplayRelative(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayRelative"] = value
	b.params["properties"] = nested
	return b
}


// SummaryTableId The table the summary field references fields from.
func (b *UpdateFieldBuilder) SummaryTableId(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["summaryTableId"] = value
	b.params["properties"] = nested
	return b
}


// Comments The comments entered on the field properties by an administrator.
func (b *UpdateFieldBuilder) Comments(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["comments"] = value
	b.params["properties"] = nested
	return b
}


// SummaryTargetFieldId The id of the field that is used to aggregate values from the child, when applicable. This displays 0 if the summary function doesnt require a field selection (like count).
func (b *UpdateFieldBuilder) SummaryTargetFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["summaryTargetFieldId"] = value
	b.params["properties"] = nested
	return b
}


// SeeVersions Indicates if the user can see other versions, aside from the most recent, of a file attachment within the product.
func (b *UpdateFieldBuilder) SeeVersions(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["seeVersions"] = value
	b.params["properties"] = nested
	return b
}


// CommaStart The number of digits before commas display in the product, when applicable.
func (b *UpdateFieldBuilder) CommaStart(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["commaStart"] = value
	b.params["properties"] = nested
	return b
}


// DisplayCheckboxAsText Indicates whether the checkbox values will be shown as text in reports.
func (b *UpdateFieldBuilder) DisplayCheckboxAsText(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayCheckboxAsText"] = value
	b.params["properties"] = nested
	return b
}


// MaxLength The maximum number of characters allowed for entry in Quickbase for this field.
func (b *UpdateFieldBuilder) MaxLength(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["maxLength"] = value
	b.params["properties"] = nested
	return b
}


// LinkText The configured text value that replaces the URL that users see within the product.
func (b *UpdateFieldBuilder) LinkText(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["linkText"] = value
	b.params["properties"] = nested
	return b
}


// Units The units label.
func (b *UpdateFieldBuilder) Units(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["units"] = value
	b.params["properties"] = nested
	return b
}


// SourceFieldId The id of the source field.
func (b *UpdateFieldBuilder) SourceFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sourceFieldId"] = value
	b.params["properties"] = nested
	return b
}


// HasExtension Whether this field has a phone extension.
func (b *UpdateFieldBuilder) HasExtension(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hasExtension"] = value
	b.params["properties"] = nested
	return b
}


// CarryChoices Whether the field should carry its multiple choice fields when copied.
func (b *UpdateFieldBuilder) CarryChoices(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["carryChoices"] = value
	b.params["properties"] = nested
	return b
}


// TargetTableName The field's target table name.
func (b *UpdateFieldBuilder) TargetTableName(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetTableName"] = value
	b.params["properties"] = nested
	return b
}


// Choices An array of entries that exist for a field that offers choices to the user. Note that these choices refer to the valid values of any records added in the future. You are allowed to remove values from the list of choices even if there are existing records with those values in this field. They will be displayed in red when users look at the data in the browser but there is no other effect. While updating a field with this property, the old choices are removed and replaced by the new choices.
func (b *UpdateFieldBuilder) Choices(value []string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["choices"] = value
	b.params["properties"] = nested
	return b
}


// CompositeFields An array of the fields that make up a composite field (e.g., address).
func (b *UpdateFieldBuilder) CompositeFields(value []any) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["compositeFields"] = value
	b.params["properties"] = nested
	return b
}


// VersionMode Version modes for files. Keep all versions vs keep last version.
func (b *UpdateFieldBuilder) VersionMode(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["versionMode"] = value
	b.params["properties"] = nested
	return b
}


// DecimalPlaces The number of decimal places displayed in the product for this field.
func (b *UpdateFieldBuilder) DecimalPlaces(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["decimalPlaces"] = value
	b.params["properties"] = nested
	return b
}


// SummaryReferenceFieldId The id of the field that is the reference in the relationship for this summary.
func (b *UpdateFieldBuilder) SummaryReferenceFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["summaryReferenceFieldId"] = value
	b.params["properties"] = nested
	return b
}


// DefaultValueLuid Default user id value.
func (b *UpdateFieldBuilder) DefaultValueLuid(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultValueLuid"] = value
	b.params["properties"] = nested
	return b
}


// DisplayMonth How to display months.
func (b *UpdateFieldBuilder) DisplayMonth(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayMonth"] = value
	b.params["properties"] = nested
	return b
}


// TargetFieldId The id of the target field.
func (b *UpdateFieldBuilder) TargetFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetFieldId"] = value
	b.params["properties"] = nested
	return b
}


// CurrencyFormat The currency format used when displaying field values within the product.
func (b *UpdateFieldBuilder) CurrencyFormat(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["currencyFormat"] = value
	b.params["properties"] = nested
	return b
}


// Formula The formula of the field as configured in Quickbase.
func (b *UpdateFieldBuilder) Formula(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["formula"] = value
	b.params["properties"] = nested
	return b
}


// TargetTableId The id of the target table.
func (b *UpdateFieldBuilder) TargetTableId(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetTableId"] = value
	b.params["properties"] = nested
	return b
}


// DisplayTime Indicates whether to display the time, in addition to the date.
func (b *UpdateFieldBuilder) DisplayTime(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayTime"] = value
	b.params["properties"] = nested
	return b
}


// SnapFieldId The id of the field that is used to snapshot values from, when applicable.
func (b *UpdateFieldBuilder) SnapFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["snapFieldId"] = value
	b.params["properties"] = nested
	return b
}


// ParentFieldId The id of the parent composite field, when applicable.
func (b *UpdateFieldBuilder) ParentFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["parentFieldId"] = value
	b.params["properties"] = nested
	return b
}


// CoverText An alternate user friendly text that can be used to display a link in the browser.
func (b *UpdateFieldBuilder) CoverText(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["coverText"] = value
	b.params["properties"] = nested
	return b
}


// DefaultDomain Default email domain.
func (b *UpdateFieldBuilder) DefaultDomain(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultDomain"] = value
	b.params["properties"] = nested
	return b
}


// LookupReferenceFieldId The id of the field that is the reference in the relationship for this lookup.
func (b *UpdateFieldBuilder) LookupReferenceFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["lookupReferenceFieldId"] = value
	b.params["properties"] = nested
	return b
}


// AppearsByDefault Indicates if the field is marked as a default in reports.
func (b *UpdateFieldBuilder) AppearsByDefault(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["appearsByDefault"] = value
	return b
}


// Permissions Field Permissions for different roles.
func (b *UpdateFieldBuilder) Permissions(values ...map[string]any) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["permissions"] = values
	return b
}


// FindEnabled Indicates if the field is marked as searchable.
func (b *UpdateFieldBuilder) FindEnabled(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["findEnabled"] = value
	return b
}


// NoWrap Indicates if the field is configured to not wrap when displayed in the product.
func (b *UpdateFieldBuilder) NoWrap(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["noWrap"] = value
	return b
}


// FieldHelp The configured help text shown to users within the product.
func (b *UpdateFieldBuilder) FieldHelp(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldHelp"] = value
	return b
}


// Bold Indicates if the field is configured to display in bold in the product.
func (b *UpdateFieldBuilder) Bold(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["bold"] = value
	return b
}


// Unique Indicates if every record in the table must contain a unique value of this field. If you attempt to change a field from not-unique to unique, and the table currently contains records with the same value of this field, you will get an error. In this case you need to find and update those records with duplicate values of the field before changing the field to unique.
func (b *UpdateFieldBuilder) Unique(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["unique"] = value
	return b
}


// AddToForms Whether the field you are adding should appear on forms.
func (b *UpdateFieldBuilder) AddToForms(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["addToForms"] = value
	return b
}



// Run executes the updateField request.
func (b *UpdateFieldBuilder) Run(ctx context.Context) (*UpdateFieldResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateFieldJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.UpdateFieldParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().UpdateFieldWithResponse(ctx, b.fieldId, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &UpdateFieldResult{}
	if resp.JSON200.NoWrap != nil {
		result.NoWrap = *resp.JSON200.NoWrap
	}
	if resp.JSON200.Bold != nil {
		result.Bold = *resp.JSON200.Bold
	}
	if resp.JSON200.AppearsByDefault != nil {
		result.AppearsByDefault = *resp.JSON200.AppearsByDefault
	}
	if resp.JSON200.FindEnabled != nil {
		result.FindEnabled = *resp.JSON200.FindEnabled
	}
	if resp.JSON200.Audited != nil {
		result.Audited = *resp.JSON200.Audited
	}
	if resp.JSON200.FieldType != nil {
		result.FieldType = *resp.JSON200.FieldType
	}
	if resp.JSON200.Required != nil {
		result.Required = *resp.JSON200.Required
	}
	if resp.JSON200.Unique != nil {
		result.Unique = *resp.JSON200.Unique
	}
	if resp.JSON200.DoesDataCopy != nil {
		result.DoesDataCopy = *resp.JSON200.DoesDataCopy
	}
	if resp.JSON200.FieldHelp != nil {
		result.FieldHelp = *resp.JSON200.FieldHelp
	}
	result.Id = resp.JSON200.Id
	if resp.JSON200.Mode != nil {
		result.Mode = *resp.JSON200.Mode
	}
	if resp.JSON200.Label != nil {
		result.Label = *resp.JSON200.Label
	}

	return result, nil
}


// UpdateRelationshipResult contains the result of a updateRelationship call.
type UpdateRelationshipResult struct {
	Id int
	ParentTableId string
	ChildTableId string
	IsCrossApp bool
}


// UpdateRelationshipBuilder provides a fluent API for the updateRelationship operation.
// Update a relationship
type UpdateRelationshipBuilder struct {
	client  *Client
	table   string
	tableID string
	tableId string
	relationshipId float32
	params  map[string]any
	err     error
}

// UpdateRelationship starts building a updateRelationship request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) UpdateRelationship(table string, relationshipId float32) *UpdateRelationshipBuilder {
	b := &UpdateRelationshipBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.relationshipId = relationshipId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// SummaryFields An array of objects, each representing a configuration of one field from the child table, that will become summary fields on the parent table. When you specify the 'COUNT' accumulation type, you have to specify 0 as the summaryFid (or not set it in the request). 'DISTINCT-COUNT' requires that summaryFid be set to an actual fid.
func (b *UpdateRelationshipBuilder) SummaryFields(values ...map[string]any) *UpdateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	b.params["summaryFields"] = values
	return b
}


// LookupFieldIds An array of field ids on the parent table that will become lookup fields on the child table.
func (b *UpdateRelationshipBuilder) LookupFieldIds(values ...int) *UpdateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	b.params["lookupFieldIds"] = values
	return b
}



// Run executes the updateRelationship request.
func (b *UpdateRelationshipBuilder) Run(ctx context.Context) (*UpdateRelationshipResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	body["tableId"] = b.tableID
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateRelationshipJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().UpdateRelationshipWithResponse(ctx, b.tableId, b.relationshipId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &UpdateRelationshipResult{}
	result.Id = resp.JSON200.Id
	result.ParentTableId = resp.JSON200.ParentTableId
	result.ChildTableId = resp.JSON200.ChildTableId
	result.IsCrossApp = resp.JSON200.IsCrossApp

	return result, nil
}



// UpdateSolutionBuilder provides a fluent API for the updateSolution operation.
// Update a solution
type UpdateSolutionBuilder struct {
	client  *Client
	solutionId string
	params  map[string]any
	err     error
}

// UpdateSolution starts building a updateSolution request.
func (c *Client) UpdateSolution(solutionId string) *UpdateSolutionBuilder {
	b := &UpdateSolutionBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	return b
}



// Run executes the updateSolution request.
func (b *UpdateSolutionBuilder) Run(ctx context.Context) (*generated.UpdateSolutionResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateSolutionJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.UpdateSolutionParams{}

	resp, err := b.client.API().UpdateSolutionWithResponse(ctx, b.solutionId, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// UpdateSolutionToRecordBuilder provides a fluent API for the updateSolutionToRecord operation.
// Update solution from record
type UpdateSolutionToRecordBuilder struct {
	client  *Client
	table   string
	tableID string
	solutionId string
	qpFieldId *int
	qpRecordId *int
	params  map[string]any
	err     error
}

// UpdateSolutionToRecord starts building a updateSolutionToRecord request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) UpdateSolutionToRecord(solutionId string, table string) *UpdateSolutionToRecordBuilder {
	b := &UpdateSolutionToRecordBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
func (b *UpdateSolutionToRecordBuilder) FieldId(value int) *UpdateSolutionToRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpFieldId = &value
	return b
}


// RecordId The unique identifier of the record.
func (b *UpdateSolutionToRecordBuilder) RecordId(value int) *UpdateSolutionToRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpRecordId = &value
	return b
}


// Run executes the updateSolutionToRecord request.
func (b *UpdateSolutionToRecordBuilder) Run(ctx context.Context) (*generated.UpdateSolutionToRecordResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	if b.qpFieldId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldId is required for updateSolutionToRecord",
			},
		}
	}
	if b.qpRecordId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "recordId is required for updateSolutionToRecord",
			},
		}
	}
	// Build query params
	params := &generated.UpdateSolutionToRecordParams{}
	params.TableId = b.tableID
	if b.qpFieldId != nil {
		params.FieldId = *b.qpFieldId
	}
	if b.qpRecordId != nil {
		params.RecordId = *b.qpRecordId
	}

	resp, err := b.client.API().UpdateSolutionToRecordWithResponse(ctx, b.solutionId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}


// UpdateTableResult contains the result of a updateTable call.
type UpdateTableResult struct {
	SpaceUsed string
	PluralRecordName string
	NextRecordId int
	SingleRecordName string
	SpaceRemaining string
	Id string
	DefaultSortOrder string
	Name string
	Alias string
	Description string
	Updated string
	DefaultSortFieldId int
	KeyFieldId int
	Created string
	NextFieldId int
	SizeLimit string
}


// UpdateTableBuilder provides a fluent API for the updateTable operation.
// Update a table
type UpdateTableBuilder struct {
	client  *Client
	table   string
	tableID string
	tableId string
	qpAppId *string
	params  map[string]any
	err     error
}

// UpdateTable starts building a updateTable request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) UpdateTable(table string) *UpdateTableBuilder {
	b := &UpdateTableBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// Name The name for the table.
func (b *UpdateTableBuilder) Name(value string) *UpdateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}


// PluralRecordName The plural noun for records in the table. If this value is not passed the default value is 'Records'.
func (b *UpdateTableBuilder) PluralRecordName(value string) *UpdateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["pluralRecordName"] = value
	return b
}


// SingleRecordName The singular noun for records in the table. If this value is not passed the default value is 'Record'.
func (b *UpdateTableBuilder) SingleRecordName(value string) *UpdateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["singleRecordName"] = value
	return b
}


// Description The description for the table. If this value is not passed the default value is blank.
func (b *UpdateTableBuilder) Description(value string) *UpdateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}



// AppId The unique identifier of an app
func (b *UpdateTableBuilder) AppId(value string) *UpdateTableBuilder {
	if b.err != nil {
		return b
	}
	b.qpAppId = &value
	return b
}


// Run executes the updateTable request.
func (b *UpdateTableBuilder) Run(ctx context.Context) (*UpdateTableResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if b.qpAppId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "appId is required for updateTable",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	body["tableId"] = b.tableID
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateTableJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.UpdateTableParams{}
	if b.qpAppId != nil {
		params.AppId = *b.qpAppId
	}

	resp, err := b.client.API().UpdateTableWithResponse(ctx, b.tableId, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &UpdateTableResult{}
	if resp.JSON200.SpaceUsed != nil {
		result.SpaceUsed = *resp.JSON200.SpaceUsed
	}
	if resp.JSON200.PluralRecordName != nil {
		result.PluralRecordName = *resp.JSON200.PluralRecordName
	}
	if resp.JSON200.NextRecordId != nil {
		result.NextRecordId = *resp.JSON200.NextRecordId
	}
	if resp.JSON200.SingleRecordName != nil {
		result.SingleRecordName = *resp.JSON200.SingleRecordName
	}
	if resp.JSON200.SpaceRemaining != nil {
		result.SpaceRemaining = *resp.JSON200.SpaceRemaining
	}
	if resp.JSON200.Id != nil {
		result.Id = *resp.JSON200.Id
	}
	if resp.JSON200.DefaultSortOrder != nil {
		result.DefaultSortOrder = string(*resp.JSON200.DefaultSortOrder)
	}
	if resp.JSON200.Name != nil {
		result.Name = *resp.JSON200.Name
	}
	if resp.JSON200.Alias != nil {
		result.Alias = *resp.JSON200.Alias
	}
	if resp.JSON200.Description != nil {
		result.Description = *resp.JSON200.Description
	}
	if resp.JSON200.Updated != nil {
		result.Updated = *resp.JSON200.Updated
	}
	if resp.JSON200.DefaultSortFieldId != nil {
		result.DefaultSortFieldId = *resp.JSON200.DefaultSortFieldId
	}
	if resp.JSON200.KeyFieldId != nil {
		result.KeyFieldId = *resp.JSON200.KeyFieldId
	}
	if resp.JSON200.Created != nil {
		result.Created = *resp.JSON200.Created
	}
	if resp.JSON200.NextFieldId != nil {
		result.NextFieldId = *resp.JSON200.NextFieldId
	}
	if resp.JSON200.SizeLimit != nil {
		result.SizeLimit = *resp.JSON200.SizeLimit
	}

	return result, nil
}


// UpsertResult contains the result of a upsert call.
type UpsertResult struct {
	CreatedRecordIDs []int
	UnchangedRecordIDs []int
	UpdatedRecordIDs []int
	TotalNumberOfRecordsProcessed int
}

// UpsertBuilder provides a fluent API for the upsert operation.
// Insert/Update record(s)
type UpsertBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// Upsert starts building a upsert request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) Upsert(table string) *UpsertBuilder {
	b := &UpsertBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// Data Record data array, where each record contains key-value mappings of fields to be defined/updated and their values.
func (b *UpsertBuilder) Data(values ...any) *UpsertBuilder {
	if b.err != nil {
		return b
	}
	b.params["data"] = values
	return b
}


// MergeFieldId The merge field id.
func (b *UpsertBuilder) MergeFieldId(value int) *UpsertBuilder {
	if b.err != nil {
		return b
	}
	b.params["mergeFieldId"] = value
	return b
}


// FieldsToReturn Specify an array of field ids that will return data for any updates or added record. Record ID (FID 3) is always returned if any field ID is requested.
func (b *UpsertBuilder) FieldsToReturn(values ...int) *UpsertBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldsToReturn"] = values
	return b
}



// Run executes the upsert request.
func (b *UpsertBuilder) Run(ctx context.Context) (*UpsertResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	body["to"] = b.tableID
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpsertJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().UpsertWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Build friendly result
	result := &UpsertResult{}
	if resp.JSON200.Metadata.CreatedRecordIds != nil {
		result.CreatedRecordIDs = *resp.JSON200.Metadata.CreatedRecordIds
	}
	if resp.JSON200.Metadata.UnchangedRecordIds != nil {
		result.UnchangedRecordIDs = *resp.JSON200.Metadata.UnchangedRecordIds
	}
	if resp.JSON200.Metadata.UpdatedRecordIds != nil {
		result.UpdatedRecordIDs = *resp.JSON200.Metadata.UpdatedRecordIds
	}
	if resp.JSON200.Metadata.TotalNumberOfRecordsProcessed != nil {
		result.TotalNumberOfRecordsProcessed = *resp.JSON200.Metadata.TotalNumberOfRecordsProcessed
	}
	return result, nil
}


// Ensure imports are used
var (
	_ = fmt.Sprintf
	_ = json.Marshal
	_ = strconv.Itoa
	_ = core.ValidationError{}
)

// Code generated by cmd/generate-builders. DO NOT EDIT.

package client

import (
	"context"
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/DrewBradfordXYZ/quickbase-go/v2/core"
	"github.com/DrewBradfordXYZ/quickbase-go/v2/generated"

	"github.com/oapi-codegen/runtime/types"

)

// --- Auto-generated builder types ---
// These provide a fluent API for building and executing API requests.
// Method names match QuickBase API operation IDs for consistency with official documentation.

// SortSpec specifies a sort field and order, supporting both field IDs and aliases.
type SortSpec struct {
	Field any                      // Field ID (int) or alias (string)
	Order generated.SortFieldOrder // ASC or DESC
}

// --- Result types for transformed responses ---




// AddManagersToGroupBuilder provides a fluent API for the addManagersToGroup operation.
// Add managers
type AddManagersToGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// AddManagersToGroup starts building a addManagersToGroup request.
func (c *Client) AddManagersToGroup(gid float32) *AddManagersToGroupBuilder {
	b := &AddManagersToGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the addManagersToGroup request and returns the response data directly.
func (b *AddManagersToGroupBuilder) Run(ctx context.Context) (*AddManagersToGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.AddManagersToGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().AddManagersToGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &AddManagersToGroupResult{resp.JSON200}, nil
}



// AddMembersToGroupBuilder provides a fluent API for the addMembersToGroup operation.
// Add members
type AddMembersToGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// AddMembersToGroup starts building a addMembersToGroup request.
func (c *Client) AddMembersToGroup(gid float32) *AddMembersToGroupBuilder {
	b := &AddMembersToGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the addMembersToGroup request and returns the response data directly.
func (b *AddMembersToGroupBuilder) Run(ctx context.Context) (*AddMembersToGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.AddMembersToGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().AddMembersToGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &AddMembersToGroupResult{resp.JSON200}, nil
}



// AddSubgroupsToGroupBuilder provides a fluent API for the addSubgroupsToGroup operation.
// Add child groups
type AddSubgroupsToGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// AddSubgroupsToGroup starts building a addSubgroupsToGroup request.
func (c *Client) AddSubgroupsToGroup(gid float32) *AddSubgroupsToGroupBuilder {
	b := &AddSubgroupsToGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the addSubgroupsToGroup request and returns the response data directly.
func (b *AddSubgroupsToGroupBuilder) Run(ctx context.Context) (*AddSubgroupsToGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.AddSubgroupsToGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().AddSubgroupsToGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &AddSubgroupsToGroupResult{resp.JSON200}, nil
}



// AddTrusteesBuilder provides a fluent API for the addTrustees operation.
// Add trustees to an app
type AddTrusteesBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// AddTrustees starts building a addTrustees request.
func (c *Client) AddTrustees(appId string) *AddTrusteesBuilder {
	b := &AddTrusteesBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}



// Run executes the addTrustees request and returns the response data directly.
func (b *AddTrusteesBuilder) Run(ctx context.Context) (*AddTrusteesResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.AddTrusteesJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().AddTrusteesWithResponse(ctx, b.appId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &AddTrusteesResult{resp.JSON200}, nil
}



// AuditBuilder provides a fluent API for the audit operation.
// Get audit logs
type AuditBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// Audit starts building a audit request.
func (c *Client) Audit() *AuditBuilder {
	b := &AuditBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// NextToken Token specifying start of page. For first page don't supply this.
func (b *AuditBuilder) NextToken(value string) *AuditBuilder {
	if b.err != nil {
		return b
	}
	b.params["nextToken"] = value
	return b
}


// NumRows Number of logs to return per page, default is 10000, minimum is 1000, max is 50000.
func (b *AuditBuilder) NumRows(value int) *AuditBuilder {
	if b.err != nil {
		return b
	}
	b.params["numRows"] = value
	return b
}


// QueryId The query id of an audit log request. This id is needed to fetch subsequent paged results of a single query.
func (b *AuditBuilder) QueryId(value string) *AuditBuilder {
	if b.err != nil {
		return b
	}
	b.params["queryId"] = value
	return b
}


// Date The date for which audit logs need to be fetched. This must be date-time only, as YYYY-MM-DD, and a valid date in the past.
func (b *AuditBuilder) Date(value string) *AuditBuilder {
	if b.err != nil {
		return b
	}
	b.params["date"] = value
	return b
}


// Topics An array that may contain up to 20 [topics](https://resources.quickbase.com/nav/app/budurkasx/action/showpage/2b2941e4-f34d-4d41-9b0e-db790d20e9ab?pageIdV2=quickbase.com-DashboardGroup-15760d74-2243-4ce9-9495-7cc8790f12e7) to filter by. If empty, all topics are returned.
func (b *AuditBuilder) Topics(values ...string) *AuditBuilder {
	if b.err != nil {
		return b
	}
	b.params["topics"] = values
	return b
}



// Run executes the audit request and returns the response data directly.
func (b *AuditBuilder) Run(ctx context.Context) (*AuditResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.AuditJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().AuditWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &AuditResult{resp.JSON200}, nil
}



// ChangesetSolutionBuilder provides a fluent API for the changesetSolution operation.
// List solution changes
type ChangesetSolutionBuilder struct {
	client  *Client
	solutionId string
	params  map[string]any
	err     error
}

// ChangesetSolution starts building a changesetSolution request.
func (c *Client) ChangesetSolution(solutionId string) *ChangesetSolutionBuilder {
	b := &ChangesetSolutionBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	return b
}



// Run executes the changesetSolution request and returns the response data directly.
func (b *ChangesetSolutionBuilder) Run(ctx context.Context) (*generated.ChangesetSolutionResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.ChangesetSolutionJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.ChangesetSolutionParams{}

	resp, err := b.client.API().ChangesetSolutionWithResponse(ctx, b.solutionId, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// ChangesetSolutionFromRecordBuilder provides a fluent API for the changesetSolutionFromRecord operation.
// List solution changes from record
type ChangesetSolutionFromRecordBuilder struct {
	client  *Client
	table   string
	tableID string
	solutionId string
	qpFieldId *int
	qpRecordId *int
	params  map[string]any
	err     error
}

// ChangesetSolutionFromRecord starts building a changesetSolutionFromRecord request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) ChangesetSolutionFromRecord(solutionId string, table string) *ChangesetSolutionFromRecordBuilder {
	b := &ChangesetSolutionFromRecordBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
func (b *ChangesetSolutionFromRecordBuilder) FieldId(value int) *ChangesetSolutionFromRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpFieldId = &value
	return b
}


// RecordId The unique identifier of the record.
func (b *ChangesetSolutionFromRecordBuilder) RecordId(value int) *ChangesetSolutionFromRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpRecordId = &value
	return b
}


// Run executes the changesetSolutionFromRecord request and returns the response data directly.
func (b *ChangesetSolutionFromRecordBuilder) Run(ctx context.Context) (*generated.ChangesetSolutionFromRecordResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	if b.qpFieldId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldId is required for changesetSolutionFromRecord",
			},
		}
	}
	if b.qpRecordId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "recordId is required for changesetSolutionFromRecord",
			},
		}
	}
	// Build query params
	params := &generated.ChangesetSolutionFromRecordParams{}
	params.TableId = b.tableID
	if b.qpFieldId != nil {
		params.FieldId = *b.qpFieldId
	}
	if b.qpRecordId != nil {
		params.RecordId = *b.qpRecordId
	}

	resp, err := b.client.API().ChangesetSolutionFromRecordWithResponse(ctx, b.solutionId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// CloneUserTokenBuilder provides a fluent API for the cloneUserToken operation.
// Clone a user token
type CloneUserTokenBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// CloneUserToken starts building a cloneUserToken request.
func (c *Client) CloneUserToken() *CloneUserTokenBuilder {
	b := &CloneUserTokenBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Name The new name for the cloned user token.
func (b *CloneUserTokenBuilder) Name(value string) *CloneUserTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}


// Description The description for the cloned user token.
func (b *CloneUserTokenBuilder) Description(value string) *CloneUserTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}



// Run executes the cloneUserToken request and returns the response data directly.
func (b *CloneUserTokenBuilder) Run(ctx context.Context) (*CloneUserTokenResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CloneUserTokenJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().CloneUserTokenWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &CloneUserTokenResult{resp.JSON200}, nil
}



// CopyAppBuilder provides a fluent API for the copyApp operation.
// Copy an app
type CopyAppBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// CopyApp starts building a copyApp request.
func (c *Client) CopyApp(appId string) *CopyAppBuilder {
	b := &CopyAppBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}


// Name The name of the newly copied app
func (b *CopyAppBuilder) Name(value string) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}


// Description The description of the newly copied app
func (b *CopyAppBuilder) Description(value string) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}


// KeepData Whether to copy the app's data along with the schema
func (b *CopyAppBuilder) KeepData(value bool) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["keepData"] = value
	b.params["properties"] = nested
	return b
}


// UsersAndRoles If true, users will be copied along with their assigned roles. If false, users and roles will be copied but roles will not be assigned
func (b *CopyAppBuilder) UsersAndRoles(value bool) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["usersAndRoles"] = value
	b.params["properties"] = nested
	return b
}


// AssignUserToken Whether to add the user token used to make this request to the new app
func (b *CopyAppBuilder) AssignUserToken(value bool) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["assignUserToken"] = value
	b.params["properties"] = nested
	return b
}


// ExcludeFiles If keepData is true, whether to copy the file attachments as well. If keepData is false, this property is ignored
func (b *CopyAppBuilder) ExcludeFiles(value bool) *CopyAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["excludeFiles"] = value
	b.params["properties"] = nested
	return b
}



// Run executes the copyApp request and returns the response data directly.
func (b *CopyAppBuilder) Run(ctx context.Context) (*CopyAppResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["name"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "name is required for copyApp",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CopyAppJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().CopyAppWithResponse(ctx, b.appId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &CopyAppResult{resp.JSON200}, nil
}



// CreateAppBuilder provides a fluent API for the createApp operation.
// Create an app
type CreateAppBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// CreateApp starts building a createApp request.
func (c *Client) CreateApp() *CreateAppBuilder {
	b := &CreateAppBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Variables The app variables. A maximum of 10 variables can be inserted at a time. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
func (b *CreateAppBuilder) Variables(values ...map[string]any) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["variables"] = values
	return b
}


// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
func (b *CreateAppBuilder) Name(value string) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}


// MustBeRealmApproved Only "approved" users may access this application
func (b *CreateAppBuilder) MustBeRealmApproved(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["mustBeRealmApproved"] = value
	b.params["securityProperties"] = nested
	return b
}


// AllowClone Allow users who are not administrators to copy
func (b *CreateAppBuilder) AllowClone(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowClone"] = value
	b.params["securityProperties"] = nested
	return b
}


// UseIPFilter Only users logging in from "approved" IP addresses may access this application
func (b *CreateAppBuilder) UseIPFilter(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useIPFilter"] = value
	b.params["securityProperties"] = nested
	return b
}


// AllowExport Allow users who are not administrators to export data
func (b *CreateAppBuilder) AllowExport(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowExport"] = value
	b.params["securityProperties"] = nested
	return b
}


// EnableAppTokens Require Application Tokens
func (b *CreateAppBuilder) EnableAppTokens(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["enableAppTokens"] = value
	b.params["securityProperties"] = nested
	return b
}


// HideFromPublic Hide from public application searches
func (b *CreateAppBuilder) HideFromPublic(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hideFromPublic"] = value
	b.params["securityProperties"] = nested
	return b
}


// Description The description for the app. If this property is left out, the app description will be blank.
func (b *CreateAppBuilder) Description(value string) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}


// AssignToken Set to true if you would like to assign the app to the user token you used to create the application. The default is false.
func (b *CreateAppBuilder) AssignToken(value bool) *CreateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["assignToken"] = value
	return b
}



// Run executes the createApp request and returns the response data directly.
func (b *CreateAppBuilder) Run(ctx context.Context) (*CreateAppResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["name"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "name is required for createApp",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CreateAppJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().CreateAppWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &CreateAppResult{resp.JSON200}, nil
}



// CreateFieldBuilder provides a fluent API for the createField operation.
// Create a field
type CreateFieldBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// CreateField starts building a createField request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) CreateField(table string) *CreateFieldBuilder {
	b := &CreateFieldBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// AddToForms Whether the field you are adding should appear on forms. Defaults to false.
func (b *CreateFieldBuilder) AddToForms(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["addToForms"] = value
	return b
}


// Label The label (name) of the field.
func (b *CreateFieldBuilder) Label(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["label"] = value
	return b
}


// NoWrap Indicates if the field is configured to not wrap when displayed in the product. Defaults to false.
func (b *CreateFieldBuilder) NoWrap(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["noWrap"] = value
	return b
}


// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs. You can only set this property to "true" if the app has audit logs enabled. See Enable data change logs under [Quickbase Audit Logs](https://help.quickbase.com/docs/audit-logs). Defaults to false.
func (b *CreateFieldBuilder) Audited(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["audited"] = value
	return b
}


// Bold Indicates if the field is configured to display in bold in the product. Defaults to false.
func (b *CreateFieldBuilder) Bold(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["bold"] = value
	return b
}


// AppearsByDefault Indicates if the field is marked as a default in reports. Defaults to true.
func (b *CreateFieldBuilder) AppearsByDefault(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["appearsByDefault"] = value
	return b
}


// FieldType The [field types](https://help.quickbase.com/docs/field-types), click on any of the field type links for more info.
func (b *CreateFieldBuilder) FieldType(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldType"] = value
	return b
}


// Permissions Field Permissions for different roles.
func (b *CreateFieldBuilder) Permissions(values ...map[string]any) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["permissions"] = values
	return b
}


// FindEnabled Indicates if the field is marked as searchable. Defaults to true.
func (b *CreateFieldBuilder) FindEnabled(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["findEnabled"] = value
	return b
}


// FieldHelp The configured help text shown to users within the product.
func (b *CreateFieldBuilder) FieldHelp(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldHelp"] = value
	return b
}


// DefaultKind The user default type.
func (b *CreateFieldBuilder) DefaultKind(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultKind"] = value
	b.params["properties"] = nested
	return b
}


// SourceFieldId The id of the source field.
func (b *CreateFieldBuilder) SourceFieldId(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sourceFieldId"] = value
	b.params["properties"] = nested
	return b
}


// Abbreviate Don't show the URL protocol when showing the URL.
func (b *CreateFieldBuilder) Abbreviate(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["abbreviate"] = value
	b.params["properties"] = nested
	return b
}


// DisplayDayOfWeek Indicates whether to display the day of the week within the product.
func (b *CreateFieldBuilder) DisplayDayOfWeek(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayDayOfWeek"] = value
	b.params["properties"] = nested
	return b
}


// DisplayCheckboxAsText Indicates whether the checkbox values will be shown as text in reports.
func (b *CreateFieldBuilder) DisplayCheckboxAsText(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayCheckboxAsText"] = value
	b.params["properties"] = nested
	return b
}


// SortAsGiven Indicates if the listed entries sort as entered vs alphabetically.
func (b *CreateFieldBuilder) SortAsGiven(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sortAsGiven"] = value
	b.params["properties"] = nested
	return b
}


// MaxVersions The maximum number of versions configured for a file attachment.
func (b *CreateFieldBuilder) MaxVersions(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["maxVersions"] = value
	b.params["properties"] = nested
	return b
}


// DisplayTimezone Indicates whether to display the timezone within the product.
func (b *CreateFieldBuilder) DisplayTimezone(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayTimezone"] = value
	b.params["properties"] = nested
	return b
}


// DoesAverage Whether this field averages in reports within the product.
func (b *CreateFieldBuilder) DoesAverage(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["doesAverage"] = value
	b.params["properties"] = nested
	return b
}


// SeeVersions Indicates if the user can see other versions, aside from the most recent, of a file attachment within the product.
func (b *CreateFieldBuilder) SeeVersions(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["seeVersions"] = value
	b.params["properties"] = nested
	return b
}


// DefaultDomain Default email domain.
func (b *CreateFieldBuilder) DefaultDomain(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultDomain"] = value
	b.params["properties"] = nested
	return b
}


// CurrencyFormat The currency format used when displaying field values within the product.
func (b *CreateFieldBuilder) CurrencyFormat(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["currencyFormat"] = value
	b.params["properties"] = nested
	return b
}


// DisplayRelative Whether to display time as relative.
func (b *CreateFieldBuilder) DisplayRelative(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayRelative"] = value
	b.params["properties"] = nested
	return b
}


// Hours24 Indicates whether or not to display time in the 24-hour format within the product.
func (b *CreateFieldBuilder) Hours24(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hours24"] = value
	b.params["properties"] = nested
	return b
}


// DoesTotal Whether this field totals in reports within the product.
func (b *CreateFieldBuilder) DoesTotal(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["doesTotal"] = value
	b.params["properties"] = nested
	return b
}


// NumberFormat The format used for displaying numeric values in the product (decimal, separators, digit group).
func (b *CreateFieldBuilder) NumberFormat(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["numberFormat"] = value
	b.params["properties"] = nested
	return b
}


// SortAlpha Whether to sort alphabetically, default sort is by record ID.
func (b *CreateFieldBuilder) SortAlpha(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sortAlpha"] = value
	b.params["properties"] = nested
	return b
}


// HasExtension Whether this field has a phone extension.
func (b *CreateFieldBuilder) HasExtension(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hasExtension"] = value
	b.params["properties"] = nested
	return b
}


// DisplayAsLink Indicates if a field that is part of the relationship should be shown as a hyperlink to the parent record within the product.
func (b *CreateFieldBuilder) DisplayAsLink(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayAsLink"] = value
	b.params["properties"] = nested
	return b
}


// AutoSave Whether the link field will auto save.
func (b *CreateFieldBuilder) AutoSave(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["autoSave"] = value
	b.params["properties"] = nested
	return b
}


// DefaultValueLuid Default user id value.
func (b *CreateFieldBuilder) DefaultValueLuid(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultValueLuid"] = value
	b.params["properties"] = nested
	return b
}


// LinkText The configured text value that replaces the URL that users see within the product.
func (b *CreateFieldBuilder) LinkText(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["linkText"] = value
	b.params["properties"] = nested
	return b
}


// Exact Whether an exact match is required for a report link.
func (b *CreateFieldBuilder) Exact(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["exact"] = value
	b.params["properties"] = nested
	return b
}


// TargetTableId The id of the target table.
func (b *CreateFieldBuilder) TargetTableId(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetTableId"] = value
	b.params["properties"] = nested
	return b
}


// DisplayTime Indicates whether to display the time, in addition to the date.
func (b *CreateFieldBuilder) DisplayTime(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayTime"] = value
	b.params["properties"] = nested
	return b
}


// Comments The comments entered on the field properties by an administrator.
func (b *CreateFieldBuilder) Comments(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["comments"] = value
	b.params["properties"] = nested
	return b
}


// CarryChoices Whether the field should carry its multiple choice fields when copied.
func (b *CreateFieldBuilder) CarryChoices(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["carryChoices"] = value
	b.params["properties"] = nested
	return b
}


// DisplayMonth How to display months.
func (b *CreateFieldBuilder) DisplayMonth(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayMonth"] = value
	b.params["properties"] = nested
	return b
}


// DefaultValue The default value configured for a field when a new record is added.
func (b *CreateFieldBuilder) DefaultValue(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultValue"] = value
	b.params["properties"] = nested
	return b
}


// UseNewWindow Indicates if the file should open a new window when a user clicks it within the product.
func (b *CreateFieldBuilder) UseNewWindow(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useNewWindow"] = value
	b.params["properties"] = nested
	return b
}


// AppendOnly Whether this field is append only.
func (b *CreateFieldBuilder) AppendOnly(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["appendOnly"] = value
	b.params["properties"] = nested
	return b
}


// DefaultCountryCode Controls the default country shown on international phone widgets on forms. Country code should be entered in the ISO 3166-1 alpha-2 format.
func (b *CreateFieldBuilder) DefaultCountryCode(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultCountryCode"] = value
	b.params["properties"] = nested
	return b
}


// Width The field's html input width in the product.
func (b *CreateFieldBuilder) Width(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["width"] = value
	b.params["properties"] = nested
	return b
}


// CompositeFields An array of the fields that make up a composite field (e.g., address).
func (b *CreateFieldBuilder) CompositeFields(value []any) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["compositeFields"] = value
	b.params["properties"] = nested
	return b
}


// SnapFieldId The id of the field that is used to snapshot values from, when applicable.
func (b *CreateFieldBuilder) SnapFieldId(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["snapFieldId"] = value
	b.params["properties"] = nested
	return b
}


// PostTempToken POSTs a temporary token to the first URL when clicked by a user. [Learn more](https://help.quickbase.com/docs/post-temporary-token-from-a-quickbase-field)
func (b *CreateFieldBuilder) PostTempToken(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["postTempToken"] = value
	b.params["properties"] = nested
	return b
}


// DefaultToday Indicates if the field value is defaulted today for new records.
func (b *CreateFieldBuilder) DefaultToday(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultToday"] = value
	b.params["properties"] = nested
	return b
}


// OpenTargetIn Indicates which target the URL should open in when a user clicks it within the product.
func (b *CreateFieldBuilder) OpenTargetIn(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["openTargetIn"] = value
	b.params["properties"] = nested
	return b
}


// Choices An array of entries that exist for a field that offers choices to the user. Note that these choices refer to the valid values of any records added in the future. You are allowed to remove values from the list of choices even if there are existing records with those values in this field. They will be displayed in red when users look at the data in the browser but there is no other effect. While updating a field with this property, the old choices are removed and replaced by the new choices.
func (b *CreateFieldBuilder) Choices(value []string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["choices"] = value
	b.params["properties"] = nested
	return b
}


// VersionMode Version modes for files. Keep all versions vs keep last version.
func (b *CreateFieldBuilder) VersionMode(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["versionMode"] = value
	b.params["properties"] = nested
	return b
}


// Formula The formula of the field as configured in Quickbase.
func (b *CreateFieldBuilder) Formula(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["formula"] = value
	b.params["properties"] = nested
	return b
}


// CoverText An alternate user friendly text that can be used to display a link in the browser.
func (b *CreateFieldBuilder) CoverText(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["coverText"] = value
	b.params["properties"] = nested
	return b
}


// CommaStart The number of digits before commas display in the product, when applicable.
func (b *CreateFieldBuilder) CommaStart(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["commaStart"] = value
	b.params["properties"] = nested
	return b
}


// NumLines The number of lines shown in Quickbase for this text field.
func (b *CreateFieldBuilder) NumLines(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["numLines"] = value
	b.params["properties"] = nested
	return b
}


// UseI18NFormat Whether phone numbers should be in E.164 standard international format
func (b *CreateFieldBuilder) UseI18NFormat(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useI18NFormat"] = value
	b.params["properties"] = nested
	return b
}


// AllowNewChoices Indicates if users can add new choices to a selection list.
func (b *CreateFieldBuilder) AllowNewChoices(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowNewChoices"] = value
	b.params["properties"] = nested
	return b
}


// Units The units label.
func (b *CreateFieldBuilder) Units(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["units"] = value
	b.params["properties"] = nested
	return b
}


// DecimalPlaces The number of decimal places displayed in the product for this field.
func (b *CreateFieldBuilder) DecimalPlaces(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["decimalPlaces"] = value
	b.params["properties"] = nested
	return b
}


// AllowMentions If someone can @mention users in the rich text field to generate an email notification.
func (b *CreateFieldBuilder) AllowMentions(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowMentions"] = value
	b.params["properties"] = nested
	return b
}


// Format The format to display time.
func (b *CreateFieldBuilder) Format(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["format"] = value
	b.params["properties"] = nested
	return b
}


// TargetTableName The field's target table name.
func (b *CreateFieldBuilder) TargetTableName(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetTableName"] = value
	b.params["properties"] = nested
	return b
}


// AppearsAs The link text, if empty, the url will be used as link text.
func (b *CreateFieldBuilder) AppearsAs(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["appearsAs"] = value
	b.params["properties"] = nested
	return b
}


// CurrencySymbol The current symbol used when displaying field values within the product.
func (b *CreateFieldBuilder) CurrencySymbol(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["currencySymbol"] = value
	b.params["properties"] = nested
	return b
}


// TargetFieldId The id of the target field.
func (b *CreateFieldBuilder) TargetFieldId(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetFieldId"] = value
	b.params["properties"] = nested
	return b
}


// DisplayUser The configured option for how users display within the product.
func (b *CreateFieldBuilder) DisplayUser(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayUser"] = value
	b.params["properties"] = nested
	return b
}


// MaxLength The maximum number of characters allowed for entry in Quickbase for this field.
func (b *CreateFieldBuilder) MaxLength(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["maxLength"] = value
	b.params["properties"] = nested
	return b
}


// ParentFieldId The id of the parent composite field, when applicable.
func (b *CreateFieldBuilder) ParentFieldId(value int) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["parentFieldId"] = value
	b.params["properties"] = nested
	return b
}


// DisplayEmail How the email is displayed.
func (b *CreateFieldBuilder) DisplayEmail(value string) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayEmail"] = value
	b.params["properties"] = nested
	return b
}


// BlankIsZero Whether a blank value is treated the same as 0 in calculations within the product.
func (b *CreateFieldBuilder) BlankIsZero(value bool) *CreateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["blankIsZero"] = value
	b.params["properties"] = nested
	return b
}



// Run executes the createField request and returns the response data directly.
func (b *CreateFieldBuilder) Run(ctx context.Context) (*CreateFieldResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["fieldType"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldType is required for createField",
			},
		}
	}
	if _, ok := b.params["label"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "label is required for createField",
			},
		}
	}
	// tableId is validated via table resolution
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CreateFieldJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.CreateFieldParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().CreateFieldWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &CreateFieldResult{resp.JSON200}, nil
}



// CreateRelationshipBuilder provides a fluent API for the createRelationship operation.
// Create a relationship
type CreateRelationshipBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// CreateRelationship starts building a createRelationship request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) CreateRelationship(table string) *CreateRelationshipBuilder {
	b := &CreateRelationshipBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// SummaryFields Array of summary field objects which will turn into summary fields in the parent table. When you specify the 'COUNT' accumulation type, you have to specify 0 as the summaryFid (or not set it in the request). 'DISTINCT-COUNT' requires that summaryFid be set to an actual fid.
func (b *CreateRelationshipBuilder) SummaryFields(values ...map[string]any) *CreateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	b.params["summaryFields"] = values
	return b
}


// LookupFieldIds Array of field IDs in the parent table that will become lookup fields in the child table.
func (b *CreateRelationshipBuilder) LookupFieldIds(values ...int) *CreateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	b.params["lookupFieldIds"] = values
	return b
}


// ParentTableId The parent table id for the relationship.
func (b *CreateRelationshipBuilder) ParentTableId(value string) *CreateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	b.params["parentTableId"] = value
	return b
}


// Label The label for the foreign key field.
func (b *CreateRelationshipBuilder) Label(value string) *CreateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["foreignKeyField"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["label"] = value
	b.params["foreignKeyField"] = nested
	return b
}



// Run executes the createRelationship request and returns the response data directly.
func (b *CreateRelationshipBuilder) Run(ctx context.Context) (*CreateRelationshipResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	body["tableId"] = b.tableID
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CreateRelationshipJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().CreateRelationshipWithResponse(ctx, b.tableID, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &CreateRelationshipResult{resp.JSON200}, nil
}



// CreateSolutionBuilder provides a fluent API for the createSolution operation.
// Create a solution
type CreateSolutionBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// CreateSolution starts building a createSolution request.
func (c *Client) CreateSolution() *CreateSolutionBuilder {
	b := &CreateSolutionBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// Run executes the createSolution request and returns the response data directly.
func (b *CreateSolutionBuilder) Run(ctx context.Context) (*generated.CreateSolutionResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CreateSolutionJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.CreateSolutionParams{}

	resp, err := b.client.API().CreateSolutionWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// CreateSolutionFromRecordBuilder provides a fluent API for the createSolutionFromRecord operation.
// Create solution from record
type CreateSolutionFromRecordBuilder struct {
	client  *Client
	table   string
	tableID string
	qpFieldId *int
	qpRecordId *int
	params  map[string]any
	err     error
}

// CreateSolutionFromRecord starts building a createSolutionFromRecord request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) CreateSolutionFromRecord(table string) *CreateSolutionFromRecordBuilder {
	b := &CreateSolutionFromRecordBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
func (b *CreateSolutionFromRecordBuilder) FieldId(value int) *CreateSolutionFromRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpFieldId = &value
	return b
}


// RecordId The unique identifier of the record.
func (b *CreateSolutionFromRecordBuilder) RecordId(value int) *CreateSolutionFromRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpRecordId = &value
	return b
}


// Run executes the createSolutionFromRecord request and returns the response data directly.
func (b *CreateSolutionFromRecordBuilder) Run(ctx context.Context) (*generated.CreateSolutionFromRecordResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	if b.qpFieldId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldId is required for createSolutionFromRecord",
			},
		}
	}
	if b.qpRecordId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "recordId is required for createSolutionFromRecord",
			},
		}
	}
	// Build query params
	params := &generated.CreateSolutionFromRecordParams{}
	params.TableId = b.tableID
	if b.qpFieldId != nil {
		params.FieldId = *b.qpFieldId
	}
	if b.qpRecordId != nil {
		params.RecordId = *b.qpRecordId
	}

	resp, err := b.client.API().CreateSolutionFromRecordWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// CreateTableBuilder provides a fluent API for the createTable operation.
// Create a table
type CreateTableBuilder struct {
	client  *Client
	qpAppId *string
	params  map[string]any
	err     error
}

// CreateTable starts building a createTable request.
func (c *Client) CreateTable() *CreateTableBuilder {
	b := &CreateTableBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// PluralRecordName The plural noun for records in the table. If this value is not passed the default value is 'Records'.
func (b *CreateTableBuilder) PluralRecordName(value string) *CreateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["pluralRecordName"] = value
	return b
}


// SingleRecordName The singular noun for records in the table. If this value is not passed the default value is 'Record'.
func (b *CreateTableBuilder) SingleRecordName(value string) *CreateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["singleRecordName"] = value
	return b
}


// Description The description for the table. If this value is not passed the default value is blank.
func (b *CreateTableBuilder) Description(value string) *CreateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}


// Name The name for the table.
func (b *CreateTableBuilder) Name(value string) *CreateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}



// AppId The unique identifier of an app
func (b *CreateTableBuilder) AppId(value string) *CreateTableBuilder {
	if b.err != nil {
		return b
	}
	b.qpAppId = &value
	return b
}


// Run executes the createTable request and returns the response data directly.
func (b *CreateTableBuilder) Run(ctx context.Context) (*CreateTableResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["name"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "name is required for createTable",
			},
		}
	}
	if b.qpAppId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "appId is required for createTable",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.CreateTableJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.CreateTableParams{}
	if b.qpAppId != nil {
		params.AppId = *b.qpAppId
	}

	resp, err := b.client.API().CreateTableWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &CreateTableResult{resp.JSON200}, nil
}



// DeactivateUserTokenBuilder provides a fluent API for the deactivateUserToken operation.
// Deactivate a user token
type DeactivateUserTokenBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// DeactivateUserToken starts building a deactivateUserToken request.
func (c *Client) DeactivateUserToken() *DeactivateUserTokenBuilder {
	b := &DeactivateUserTokenBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// Run executes the deactivateUserToken request and returns the response data directly.
func (b *DeactivateUserTokenBuilder) Run(ctx context.Context) (*DeactivateUserTokenResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().DeactivateUserTokenWithResponse(ctx)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &DeactivateUserTokenResult{resp.JSON200}, nil
}



// DeleteAppBuilder provides a fluent API for the deleteApp operation.
// Delete an app
type DeleteAppBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// DeleteApp starts building a deleteApp request.
func (c *Client) DeleteApp(appId string) *DeleteAppBuilder {
	b := &DeleteAppBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}


// Name To confirm application deletion we ask for application name.
func (b *DeleteAppBuilder) Name(value string) *DeleteAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}



// Run executes the deleteApp request and returns the response data directly.
func (b *DeleteAppBuilder) Run(ctx context.Context) (*DeleteAppResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["name"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "name is required for deleteApp",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.DeleteAppJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().DeleteAppWithResponse(ctx, b.appId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &DeleteAppResult{resp.JSON200}, nil
}



// DeleteFieldsBuilder provides a fluent API for the deleteFields operation.
// Delete field(s)
type DeleteFieldsBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// DeleteFields starts building a deleteFields request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DeleteFields(table string) *DeleteFieldsBuilder {
	b := &DeleteFieldsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// FieldIds List of field IDs to be deleted.
func (b *DeleteFieldsBuilder) FieldIds(values ...int) *DeleteFieldsBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldIds"] = values
	return b
}



// Run executes the deleteFields request and returns the response data directly.
func (b *DeleteFieldsBuilder) Run(ctx context.Context) (*DeleteFieldsResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["fieldIds"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldIds is required for deleteFields",
			},
		}
	}
	// tableId is validated via table resolution
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.DeleteFieldsJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.DeleteFieldsParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().DeleteFieldsWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &DeleteFieldsResult{resp.JSON200}, nil
}



// DeleteFileBuilder provides a fluent API for the deleteFile operation.
// Delete file
type DeleteFileBuilder struct {
	client  *Client
	table   string
	tableID string
	recordId int
	fieldId int
	versionNumber int
	params  map[string]any
	err     error
}

// DeleteFile starts building a deleteFile request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DeleteFile(table string, recordId int, fieldId int, versionNumber int) *DeleteFileBuilder {
	b := &DeleteFileBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.recordId = recordId
	b.fieldId = fieldId
	b.versionNumber = versionNumber
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the deleteFile request and returns the response data directly.
func (b *DeleteFileBuilder) Run(ctx context.Context) (*DeleteFileResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().DeleteFileWithResponse(ctx, b.tableID, b.recordId, b.fieldId, b.versionNumber)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &DeleteFileResult{resp.JSON200}, nil
}



// DeleteRecordsBuilder provides a fluent API for the deleteRecords operation.
// Delete record(s)
type DeleteRecordsBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// DeleteRecords starts building a deleteRecords request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DeleteRecords(table string) *DeleteRecordsBuilder {
	b := &DeleteRecordsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// Where The filter to delete records. To delete all records specify a filter that will include all records, for example {3.GT.0} where 3 is the ID of the Record ID field. Or supply a JSON array of Record IDs.
func (b *DeleteRecordsBuilder) Where(value any) *DeleteRecordsBuilder {
	if b.err != nil {
		return b
	}
	b.params["where"] = value
	return b
}



// Run executes the deleteRecords request and returns the response data directly.
func (b *DeleteRecordsBuilder) Run(ctx context.Context) (*DeleteRecordsResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["where"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "where is required for deleteRecords",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	body["from"] = b.tableID
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.DeleteRecordsJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().DeleteRecordsWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &DeleteRecordsResult{resp.JSON200}, nil
}



// DeleteRelationshipBuilder provides a fluent API for the deleteRelationship operation.
// Delete a relationship
type DeleteRelationshipBuilder struct {
	client  *Client
	table   string
	tableID string
	relationshipId float32
	params  map[string]any
	err     error
}

// DeleteRelationship starts building a deleteRelationship request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DeleteRelationship(table string, relationshipId float32) *DeleteRelationshipBuilder {
	b := &DeleteRelationshipBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.relationshipId = relationshipId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the deleteRelationship request and returns the response data directly.
func (b *DeleteRelationshipBuilder) Run(ctx context.Context) (*DeleteRelationshipResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().DeleteRelationshipWithResponse(ctx, b.tableID, b.relationshipId)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &DeleteRelationshipResult{resp.JSON200}, nil
}



// DeleteTableBuilder provides a fluent API for the deleteTable operation.
// Delete a table
type DeleteTableBuilder struct {
	client  *Client
	table   string
	tableID string
	qpAppId *string
	params  map[string]any
	err     error
}

// DeleteTable starts building a deleteTable request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DeleteTable(table string) *DeleteTableBuilder {
	b := &DeleteTableBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// AppId The unique identifier of an app
func (b *DeleteTableBuilder) AppId(value string) *DeleteTableBuilder {
	if b.err != nil {
		return b
	}
	b.qpAppId = &value
	return b
}


// Run executes the deleteTable request and returns the response data directly.
func (b *DeleteTableBuilder) Run(ctx context.Context) (*DeleteTableResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if b.qpAppId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "appId is required for deleteTable",
			},
		}
	}
	// Build query params
	params := &generated.DeleteTableParams{}
	if b.qpAppId != nil {
		params.AppId = *b.qpAppId
	}

	resp, err := b.client.API().DeleteTableWithResponse(ctx, b.tableID, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &DeleteTableResult{resp.JSON200}, nil
}



// DeleteUserTokenBuilder provides a fluent API for the deleteUserToken operation.
// Delete a user token
type DeleteUserTokenBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// DeleteUserToken starts building a deleteUserToken request.
func (c *Client) DeleteUserToken() *DeleteUserTokenBuilder {
	b := &DeleteUserTokenBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// Run executes the deleteUserToken request and returns the response data directly.
func (b *DeleteUserTokenBuilder) Run(ctx context.Context) (*DeleteUserTokenResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().DeleteUserTokenWithResponse(ctx)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &DeleteUserTokenResult{resp.JSON200}, nil
}



// DenyUsersBuilder provides a fluent API for the denyUsers operation.
// Deny users
type DenyUsersBuilder struct {
	client  *Client
	qpAccountId *float32
	params  map[string]any
	err     error
}

// DenyUsers starts building a denyUsers request.
func (c *Client) DenyUsers() *DenyUsersBuilder {
	b := &DenyUsersBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// AccountId The account id being used to deny users. If no value is specified, the first account associated with the requesting user token is chosen.
func (b *DenyUsersBuilder) AccountId(value float32) *DenyUsersBuilder {
	if b.err != nil {
		return b
	}
	b.qpAccountId = &value
	return b
}


// Run executes the denyUsers request and returns the response data directly.
func (b *DenyUsersBuilder) Run(ctx context.Context) (*DenyUsersResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.DenyUsersJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.DenyUsersParams{}
	if b.qpAccountId != nil {
		params.AccountId = b.qpAccountId
	}

	resp, err := b.client.API().DenyUsersWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &DenyUsersResult{resp.JSON200}, nil
}



// DenyUsersAndGroupsBuilder provides a fluent API for the denyUsersAndGroups operation.
// Deny and remove users from groups
type DenyUsersAndGroupsBuilder struct {
	client  *Client
	shouldDeleteFromGroups bool
	qpAccountId *float32
	params  map[string]any
	err     error
}

// DenyUsersAndGroups starts building a denyUsersAndGroups request.
func (c *Client) DenyUsersAndGroups(shouldDeleteFromGroups bool) *DenyUsersAndGroupsBuilder {
	b := &DenyUsersAndGroupsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.shouldDeleteFromGroups = shouldDeleteFromGroups
	return b
}



// AccountId The account id being used to deny users. If no value is specified, the first account associated with the requesting user token is chosen.
func (b *DenyUsersAndGroupsBuilder) AccountId(value float32) *DenyUsersAndGroupsBuilder {
	if b.err != nil {
		return b
	}
	b.qpAccountId = &value
	return b
}


// Run executes the denyUsersAndGroups request and returns the response data directly.
func (b *DenyUsersAndGroupsBuilder) Run(ctx context.Context) (*DenyUsersAndGroupsResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.DenyUsersAndGroupsJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.DenyUsersAndGroupsParams{}
	if b.qpAccountId != nil {
		params.AccountId = b.qpAccountId
	}

	resp, err := b.client.API().DenyUsersAndGroupsWithResponse(ctx, b.shouldDeleteFromGroups, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &DenyUsersAndGroupsResult{resp.JSON200}, nil
}



// DownloadFileBuilder provides a fluent API for the downloadFile operation.
// Download file
type DownloadFileBuilder struct {
	client  *Client
	table   string
	tableID string
	recordId int
	fieldId int
	versionNumber int
	params  map[string]any
	err     error
}

// DownloadFile starts building a downloadFile request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) DownloadFile(table string, recordId int, fieldId int, versionNumber int) *DownloadFileBuilder {
	b := &DownloadFileBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.recordId = recordId
	b.fieldId = fieldId
	b.versionNumber = versionNumber
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the downloadFile request and returns the response data directly.
func (b *DownloadFileBuilder) Run(ctx context.Context) (*generated.DownloadFileResponse, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().DownloadFileWithResponse(ctx, b.tableID, b.recordId, b.fieldId, b.versionNumber)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// ExchangeSsoTokenBuilder provides a fluent API for the exchangeSsoToken operation.
// Exchange an SSO token
type ExchangeSsoTokenBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// ExchangeSsoToken starts building a exchangeSsoToken request.
func (c *Client) ExchangeSsoToken() *ExchangeSsoTokenBuilder {
	b := &ExchangeSsoTokenBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Grant_type The value `urn:ietf:params:oauth:grant-type:token-exchange` indicates that a token exchange is being performed.
func (b *ExchangeSsoTokenBuilder) Grant_type(value string) *ExchangeSsoTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["grant_type"] = value
	return b
}


// Requested_token_type An identifier for the type of the requested security token. For the RESTful API, use `urn:quickbase:params:oauth:token-type:temp_token`. For the XML or SCIM APIs use `urn:quickbase:params:oauth:token-type:temp_ticket`.
func (b *ExchangeSsoTokenBuilder) Requested_token_type(value string) *ExchangeSsoTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["requested_token_type"] = value
	return b
}


// Subject_token A security token that represents the identity of the party on behalf of whom the request is being made. For SAML 2.0, the value should be a base64url-encoded SAML 2.0 assertion.
func (b *ExchangeSsoTokenBuilder) Subject_token(value string) *ExchangeSsoTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["subject_token"] = value
	return b
}


// Subject_token_type An identifier that indicates the type of the security token in the `subject_token` parameter.
func (b *ExchangeSsoTokenBuilder) Subject_token_type(value string) *ExchangeSsoTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["subject_token_type"] = value
	return b
}



// Run executes the exchangeSsoToken request and returns the response data directly.
func (b *ExchangeSsoTokenBuilder) Run(ctx context.Context) (*ExchangeSsoTokenResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["grant_type"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "grant_type is required for exchangeSsoToken",
			},
		}
	}
	if _, ok := b.params["subject_token"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "subject_token is required for exchangeSsoToken",
			},
		}
	}
	if _, ok := b.params["subject_token_type"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "subject_token_type is required for exchangeSsoToken",
			},
		}
	}
	if _, ok := b.params["requested_token_type"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "requested_token_type is required for exchangeSsoToken",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.ExchangeSsoTokenJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().ExchangeSsoTokenWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &ExchangeSsoTokenResult{resp.JSON200}, nil
}



// ExportSolutionBuilder provides a fluent API for the exportSolution operation.
// Export a solution
type ExportSolutionBuilder struct {
	client  *Client
	solutionId string
	params  map[string]any
	err     error
}

// ExportSolution starts building a exportSolution request.
func (c *Client) ExportSolution(solutionId string) *ExportSolutionBuilder {
	b := &ExportSolutionBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	return b
}



// Run executes the exportSolution request and returns the response data directly.
func (b *ExportSolutionBuilder) Run(ctx context.Context) (*generated.ExportSolutionResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build query params
	params := &generated.ExportSolutionParams{}

	resp, err := b.client.API().ExportSolutionWithResponse(ctx, b.solutionId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// ExportSolutionToRecordBuilder provides a fluent API for the exportSolutionToRecord operation.
// Export solution to record
type ExportSolutionToRecordBuilder struct {
	client  *Client
	table   string
	tableID string
	solutionId string
	qpFieldId *int
	params  map[string]any
	err     error
}

// ExportSolutionToRecord starts building a exportSolutionToRecord request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) ExportSolutionToRecord(solutionId string, table string) *ExportSolutionToRecordBuilder {
	b := &ExportSolutionToRecordBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
func (b *ExportSolutionToRecordBuilder) FieldId(value int) *ExportSolutionToRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpFieldId = &value
	return b
}


// Run executes the exportSolutionToRecord request and returns the response data directly.
func (b *ExportSolutionToRecordBuilder) Run(ctx context.Context) (*generated.ExportSolutionToRecordResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	if b.qpFieldId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldId is required for exportSolutionToRecord",
			},
		}
	}
	// Build query params
	params := &generated.ExportSolutionToRecordParams{}
	params.TableId = b.tableID
	if b.qpFieldId != nil {
		params.FieldId = *b.qpFieldId
	}

	resp, err := b.client.API().ExportSolutionToRecordWithResponse(ctx, b.solutionId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// GenerateDocumentBuilder provides a fluent API for the generateDocument operation.
// Generate a document
type GenerateDocumentBuilder struct {
	client  *Client
	table   string
	tableID string
	templateId float32
	qpRecordId *float32
	qpFilename *string
	qpFormat *generated.GenerateDocumentParamsFormat
	qpMargin *string
	qpUnit *generated.GenerateDocumentParamsUnit
	qpPageSize *generated.GenerateDocumentParamsPageSize
	qpOrientation *generated.GenerateDocumentParamsOrientation
	qpRealm *string
	params  map[string]any
	err     error
}

// GenerateDocument starts building a generateDocument request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GenerateDocument(templateId float32, table string) *GenerateDocumentBuilder {
	b := &GenerateDocumentBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.templateId = templateId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// RecordId The ID of the record
func (b *GenerateDocumentBuilder) RecordId(value float32) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpRecordId = &value
	return b
}


// Filename File name for the downloaded file
func (b *GenerateDocumentBuilder) Filename(value string) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpFilename = &value
	return b
}


// Format The format of the file that is returned. Default is "pdf".
func (b *GenerateDocumentBuilder) Format(value generated.GenerateDocumentParamsFormat) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpFormat = &value
	return b
}


// Margin Margin formatted as top right bottom left, separated by spaces. Add to override the value set in the template builder.
func (b *GenerateDocumentBuilder) Margin(value string) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpMargin = &value
	return b
}


// Unit Unit of measurement for the margin. Default is "in". Add to override the value set in the template builder.
func (b *GenerateDocumentBuilder) Unit(value generated.GenerateDocumentParamsUnit) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpUnit = &value
	return b
}


// PageSize Page size. Default is "A4". Add to override the value set in the template builder.
func (b *GenerateDocumentBuilder) PageSize(value generated.GenerateDocumentParamsPageSize) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpPageSize = &value
	return b
}


// Orientation Page orientation. Default is "portrait". Add to override the value set in the template builder.
func (b *GenerateDocumentBuilder) Orientation(value generated.GenerateDocumentParamsOrientation) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpOrientation = &value
	return b
}


// Realm Your Quickbase domain, for example demo.quickbase.com
func (b *GenerateDocumentBuilder) Realm(value string) *GenerateDocumentBuilder {
	if b.err != nil {
		return b
	}
	b.qpRealm = &value
	return b
}


// Run executes the generateDocument request and returns the response data directly.
func (b *GenerateDocumentBuilder) Run(ctx context.Context) (*GenerateDocumentResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	if b.qpFilename == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "filename is required for generateDocument",
			},
		}
	}
	// Build query params
	params := &generated.GenerateDocumentParams{}
	params.TableId = b.tableID
	if b.qpRecordId != nil {
		params.RecordId = b.qpRecordId
	}
	if b.qpFilename != nil {
		params.Filename = *b.qpFilename
	}
	if b.qpFormat != nil {
		params.Format = b.qpFormat
	}
	if b.qpMargin != nil {
		params.Margin = b.qpMargin
	}
	if b.qpUnit != nil {
		params.Unit = b.qpUnit
	}
	if b.qpPageSize != nil {
		params.PageSize = b.qpPageSize
	}
	if b.qpOrientation != nil {
		params.Orientation = b.qpOrientation
	}
	if b.qpRealm != nil {
		params.Realm = b.qpRealm
	}

	resp, err := b.client.API().GenerateDocumentWithResponse(ctx, b.templateId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &GenerateDocumentResult{resp.JSON200}, nil
}



// GetAppBuilder provides a fluent API for the getApp operation.
// Get an app
type GetAppBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// GetApp starts building a getApp request.
func (c *Client) GetApp(appId string) *GetAppBuilder {
	b := &GetAppBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}



// Run executes the getApp request and returns the response data directly.
func (b *GetAppBuilder) Run(ctx context.Context) (*AppResult, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().GetAppWithResponse(ctx, b.appId)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &AppResult{resp.JSON200}, nil
}



// GetAppEventsBuilder provides a fluent API for the getAppEvents operation.
// Get app events
type GetAppEventsBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// GetAppEvents starts building a getAppEvents request.
func (c *Client) GetAppEvents(appId string) *GetAppEventsBuilder {
	b := &GetAppEventsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}



// Run executes the getAppEvents request and returns the response data directly.
func (b *GetAppEventsBuilder) Run(ctx context.Context) ([]*AppEventsItem, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().GetAppEventsWithResponse(ctx, b.appId)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Wrap each item in the result wrapper
	items := make([]*AppEventsItem, len(*resp.JSON200))
	for i := range *resp.JSON200 {
		items[i] = &AppEventsItem{&(*resp.JSON200)[i]}
	}
	return items, nil
}



// GetAppTablesBuilder provides a fluent API for the getAppTables operation.
// Get tables for an app
type GetAppTablesBuilder struct {
	client  *Client
	qpAppId *string
	params  map[string]any
	err     error
}

// GetAppTables starts building a getAppTables request.
func (c *Client) GetAppTables() *GetAppTablesBuilder {
	b := &GetAppTablesBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// AppId The unique identifier of an app
func (b *GetAppTablesBuilder) AppId(value string) *GetAppTablesBuilder {
	if b.err != nil {
		return b
	}
	b.qpAppId = &value
	return b
}


// Run executes the getAppTables request and returns the response data directly.
func (b *GetAppTablesBuilder) Run(ctx context.Context) ([]*AppTablesItem, error) {
	if b.err != nil {
		return nil, b.err
	}
	if b.qpAppId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "appId is required for getAppTables",
			},
		}
	}
	// Build query params
	params := &generated.GetAppTablesParams{}
	if b.qpAppId != nil {
		params.AppId = *b.qpAppId
	}

	resp, err := b.client.API().GetAppTablesWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Wrap each item in the result wrapper
	items := make([]*AppTablesItem, len(*resp.JSON200))
	for i := range *resp.JSON200 {
		items[i] = &AppTablesItem{&(*resp.JSON200)[i]}
	}
	return items, nil
}



// GetFieldBuilder provides a fluent API for the getField operation.
// Get field
type GetFieldBuilder struct {
	client  *Client
	table   string
	tableID string
	fieldId int
	qpIncludeFieldPerms *bool
	params  map[string]any
	err     error
}

// GetField starts building a getField request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetField(fieldId int, table string) *GetFieldBuilder {
	b := &GetFieldBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.fieldId = fieldId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// IncludeFieldPerms Set to 'true' if you'd like to get back the custom permissions for the field(s).
func (b *GetFieldBuilder) IncludeFieldPerms(value bool) *GetFieldBuilder {
	if b.err != nil {
		return b
	}
	b.qpIncludeFieldPerms = &value
	return b
}


// Run executes the getField request and returns the response data directly.
func (b *GetFieldBuilder) Run(ctx context.Context) (*FieldResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetFieldParams{}
	params.TableId = b.tableID
	if b.qpIncludeFieldPerms != nil {
		params.IncludeFieldPerms = b.qpIncludeFieldPerms
	}

	resp, err := b.client.API().GetFieldWithResponse(ctx, b.fieldId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &FieldResult{resp.JSON200}, nil
}



// GetFieldUsageBuilder provides a fluent API for the getFieldUsage operation.
// Get usage for a field
type GetFieldUsageBuilder struct {
	client  *Client
	table   string
	tableID string
	fieldId int
	params  map[string]any
	err     error
}

// GetFieldUsage starts building a getFieldUsage request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetFieldUsage(fieldId int, table string) *GetFieldUsageBuilder {
	b := &GetFieldUsageBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.fieldId = fieldId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the getFieldUsage request and returns the response data directly.
func (b *GetFieldUsageBuilder) Run(ctx context.Context) ([]*FieldUsageItem, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetFieldUsageParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().GetFieldUsageWithResponse(ctx, b.fieldId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Wrap each item in the result wrapper
	items := make([]*FieldUsageItem, len(*resp.JSON200))
	for i := range *resp.JSON200 {
		items[i] = &FieldUsageItem{&(*resp.JSON200)[i]}
	}
	return items, nil
}



// GetFieldsBuilder provides a fluent API for the getFields operation.
// Get fields for a table
type GetFieldsBuilder struct {
	client  *Client
	table   string
	tableID string
	qpIncludeFieldPerms *bool
	params  map[string]any
	err     error
}

// GetFields starts building a getFields request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetFields(table string) *GetFieldsBuilder {
	b := &GetFieldsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// IncludeFieldPerms Set to 'true' if you'd like to get back the custom permissions for the field(s).
func (b *GetFieldsBuilder) IncludeFieldPerms(value bool) *GetFieldsBuilder {
	if b.err != nil {
		return b
	}
	b.qpIncludeFieldPerms = &value
	return b
}


// Run executes the getFields request and returns the response data directly.
func (b *GetFieldsBuilder) Run(ctx context.Context) ([]*FieldsItem, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetFieldsParams{}
	params.TableId = b.tableID
	if b.qpIncludeFieldPerms != nil {
		params.IncludeFieldPerms = b.qpIncludeFieldPerms
	}

	resp, err := b.client.API().GetFieldsWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Wrap each item in the result wrapper
	items := make([]*FieldsItem, len(*resp.JSON200))
	for i := range *resp.JSON200 {
		items[i] = &FieldsItem{&(*resp.JSON200)[i]}
	}
	return items, nil
}



// GetFieldsUsageBuilder provides a fluent API for the getFieldsUsage operation.
// Get usage for all fields
type GetFieldsUsageBuilder struct {
	client  *Client
	table   string
	tableID string
	qpSkip *int
	qpTop *int
	params  map[string]any
	err     error
}

// GetFieldsUsage starts building a getFieldsUsage request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetFieldsUsage(table string) *GetFieldsUsageBuilder {
	b := &GetFieldsUsageBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Skip The number of fields to skip from the list.
func (b *GetFieldsUsageBuilder) Skip(value int) *GetFieldsUsageBuilder {
	if b.err != nil {
		return b
	}
	b.qpSkip = &value
	return b
}


// Top The maximum number of fields to return.
func (b *GetFieldsUsageBuilder) Top(value int) *GetFieldsUsageBuilder {
	if b.err != nil {
		return b
	}
	b.qpTop = &value
	return b
}


// Run executes the getFieldsUsage request and returns the response data directly.
func (b *GetFieldsUsageBuilder) Run(ctx context.Context) ([]*FieldsUsageItem, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetFieldsUsageParams{}
	params.TableId = b.tableID
	if b.qpSkip != nil {
		params.Skip = b.qpSkip
	}
	if b.qpTop != nil {
		params.Top = b.qpTop
	}

	resp, err := b.client.API().GetFieldsUsageWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Wrap each item in the result wrapper
	items := make([]*FieldsUsageItem, len(*resp.JSON200))
	for i := range *resp.JSON200 {
		items[i] = &FieldsUsageItem{&(*resp.JSON200)[i]}
	}
	return items, nil
}



// GetRelationshipsBuilder provides a fluent API for the getRelationships operation.
// Get all relationships
type GetRelationshipsBuilder struct {
	client  *Client
	table   string
	tableID string
	qpSkip *int
	params  map[string]any
	err     error
}

// GetRelationships starts building a getRelationships request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetRelationships(table string) *GetRelationshipsBuilder {
	b := &GetRelationshipsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Skip The number of relationships to skip.
func (b *GetRelationshipsBuilder) Skip(value int) *GetRelationshipsBuilder {
	if b.err != nil {
		return b
	}
	b.qpSkip = &value
	return b
}


// Run executes the getRelationships request and returns the response data directly.
func (b *GetRelationshipsBuilder) Run(ctx context.Context) (*RelationshipsResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build query params
	params := &generated.GetRelationshipsParams{}
	if b.qpSkip != nil {
		params.Skip = b.qpSkip
	}

	resp, err := b.client.API().GetRelationshipsWithResponse(ctx, b.tableID, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &RelationshipsResult{resp.JSON200}, nil
}



// GetReportBuilder provides a fluent API for the getReport operation.
// Get a report
type GetReportBuilder struct {
	client  *Client
	table   string
	tableID string
	reportId string
	params  map[string]any
	err     error
}

// GetReport starts building a getReport request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetReport(reportId string, table string) *GetReportBuilder {
	b := &GetReportBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.reportId = reportId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the getReport request and returns the response data directly.
func (b *GetReportBuilder) Run(ctx context.Context) (*ReportResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetReportParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().GetReportWithResponse(ctx, b.reportId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &ReportResult{resp.JSON200}, nil
}



// GetRolesBuilder provides a fluent API for the getRoles operation.
// Get app roles
type GetRolesBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// GetRoles starts building a getRoles request.
func (c *Client) GetRoles(appId string) *GetRolesBuilder {
	b := &GetRolesBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}



// Run executes the getRoles request and returns the response data directly.
func (b *GetRolesBuilder) Run(ctx context.Context) ([]*RolesItem, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().GetRolesWithResponse(ctx, b.appId)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Wrap each item in the result wrapper
	items := make([]*RolesItem, len(*resp.JSON200))
	for i := range *resp.JSON200 {
		items[i] = &RolesItem{&(*resp.JSON200)[i]}
	}
	return items, nil
}



// GetSolutionPublicBuilder provides a fluent API for the getSolutionPublic operation.
// Get solution information
type GetSolutionPublicBuilder struct {
	client  *Client
	solutionId string
	params  map[string]any
	err     error
}

// GetSolutionPublic starts building a getSolutionPublic request.
func (c *Client) GetSolutionPublic(solutionId string) *GetSolutionPublicBuilder {
	b := &GetSolutionPublicBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	return b
}



// Run executes the getSolutionPublic request and returns the response data directly.
func (b *GetSolutionPublicBuilder) Run(ctx context.Context) (*generated.GetSolutionPublicResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build query params
	params := &generated.GetSolutionPublicParams{}

	resp, err := b.client.API().GetSolutionPublicWithResponse(ctx, b.solutionId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// GetTableBuilder provides a fluent API for the getTable operation.
// Get a table
type GetTableBuilder struct {
	client  *Client
	table   string
	tableID string
	qpAppId *string
	params  map[string]any
	err     error
}

// GetTable starts building a getTable request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetTable(table string) *GetTableBuilder {
	b := &GetTableBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// AppId The unique identifier of an app
func (b *GetTableBuilder) AppId(value string) *GetTableBuilder {
	if b.err != nil {
		return b
	}
	b.qpAppId = &value
	return b
}


// Run executes the getTable request and returns the response data directly.
func (b *GetTableBuilder) Run(ctx context.Context) (*TableResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if b.qpAppId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "appId is required for getTable",
			},
		}
	}
	// Build query params
	params := &generated.GetTableParams{}
	if b.qpAppId != nil {
		params.AppId = *b.qpAppId
	}

	resp, err := b.client.API().GetTableWithResponse(ctx, b.tableID, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &TableResult{resp.JSON200}, nil
}



// GetTableReportsBuilder provides a fluent API for the getTableReports operation.
// Get reports for a table
type GetTableReportsBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// GetTableReports starts building a getTableReports request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) GetTableReports(table string) *GetTableReportsBuilder {
	b := &GetTableReportsBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Run executes the getTableReports request and returns the response data directly.
func (b *GetTableReportsBuilder) Run(ctx context.Context) ([]*TableReportsItem, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build query params
	params := &generated.GetTableReportsParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().GetTableReportsWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Wrap each item in the result wrapper
	items := make([]*TableReportsItem, len(*resp.JSON200))
	for i := range *resp.JSON200 {
		items[i] = &TableReportsItem{&(*resp.JSON200)[i]}
	}
	return items, nil
}



// GetTempTokenDBIDBuilder provides a fluent API for the getTempTokenDBID operation.
// Get a temporary token for a dbid
type GetTempTokenDBIDBuilder struct {
	client  *Client
	dbid string
	params  map[string]any
	err     error
}

// GetTempTokenDBID starts building a getTempTokenDBID request.
func (c *Client) GetTempTokenDBID(dbid string) *GetTempTokenDBIDBuilder {
	b := &GetTempTokenDBIDBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.dbid = dbid
	return b
}



// Run executes the getTempTokenDBID request and returns the response data directly.
func (b *GetTempTokenDBIDBuilder) Run(ctx context.Context) (*TempTokenDBIDResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build query params
	params := &generated.GetTempTokenDBIDParams{}

	resp, err := b.client.API().GetTempTokenDBIDWithResponse(ctx, b.dbid, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &TempTokenDBIDResult{resp.JSON200}, nil
}



// GetTrusteesBuilder provides a fluent API for the getTrustees operation.
// Get trustees for an app
type GetTrusteesBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// GetTrustees starts building a getTrustees request.
func (c *Client) GetTrustees(appId string) *GetTrusteesBuilder {
	b := &GetTrusteesBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}



// Run executes the getTrustees request and returns the response data directly.
func (b *GetTrusteesBuilder) Run(ctx context.Context) ([]*TrusteesItem, error) {
	if b.err != nil {
		return nil, b.err
	}

	resp, err := b.client.API().GetTrusteesWithResponse(ctx, b.appId)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	// Wrap each item in the result wrapper
	items := make([]*TrusteesItem, len(*resp.JSON200))
	for i := range *resp.JSON200 {
		items[i] = &TrusteesItem{&(*resp.JSON200)[i]}
	}
	return items, nil
}



// GetUsersBuilder provides a fluent API for the getUsers operation.
// Get users
type GetUsersBuilder struct {
	client  *Client
	qpAccountId *float32
	params  map[string]any
	err     error
}

// GetUsers starts building a getUsers request.
func (c *Client) GetUsers() *GetUsersBuilder {
	b := &GetUsersBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// AppIds When provided, the returned users will be narrowed down only to the users assigned to the app id's provided in this list. The provided app id's should belong to the same account.
func (b *GetUsersBuilder) AppIds(values ...string) *GetUsersBuilder {
	if b.err != nil {
		return b
	}
	b.params["appIds"] = values
	return b
}


// NextPageToken Next page token used to get the next 'page' of results when available. When this field is empty, the first page is returned.
func (b *GetUsersBuilder) NextPageToken(value string) *GetUsersBuilder {
	if b.err != nil {
		return b
	}
	b.params["nextPageToken"] = value
	return b
}


// Emails When provided, the returned users will be narrowed down only to the users included in this list.
func (b *GetUsersBuilder) Emails(values ...string) *GetUsersBuilder {
	if b.err != nil {
		return b
	}
	b.params["emails"] = values
	return b
}



// AccountId The account id being used to get users. If no value is specified, the first account associated with the requesting user token is chosen.
func (b *GetUsersBuilder) AccountId(value float32) *GetUsersBuilder {
	if b.err != nil {
		return b
	}
	b.qpAccountId = &value
	return b
}


// Run executes the getUsers request and returns the response data directly.
func (b *GetUsersBuilder) Run(ctx context.Context) (*UsersResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.GetUsersJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.GetUsersParams{}
	if b.qpAccountId != nil {
		params.AccountId = b.qpAccountId
	}

	resp, err := b.client.API().GetUsersWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &UsersResult{resp.JSON200}, nil
}



// PlatformAnalyticEventSummariesBuilder provides a fluent API for the platformAnalyticEventSummaries operation.
// Get event summaries
type PlatformAnalyticEventSummariesBuilder struct {
	client  *Client
	qpAccountId *float32
	params  map[string]any
	err     error
}

// PlatformAnalyticEventSummaries starts building a platformAnalyticEventSummaries request.
func (c *Client) PlatformAnalyticEventSummaries() *PlatformAnalyticEventSummariesBuilder {
	b := &PlatformAnalyticEventSummariesBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Start The start date and time of the requested summaries in ISO 8601 time format.
func (b *PlatformAnalyticEventSummariesBuilder) Start(value string) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.params["start"] = value
	return b
}


// End The end date and time of the requested summaries in ISO 8601 time format.
func (b *PlatformAnalyticEventSummariesBuilder) End(value string) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.params["end"] = value
	return b
}


// NextToken A pagination token from a previous response made using the same parameters. Used to fetch the next page.
func (b *PlatformAnalyticEventSummariesBuilder) NextToken(value string) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.params["nextToken"] = value
	return b
}


// GroupBy How the events should be grouped.
func (b *PlatformAnalyticEventSummariesBuilder) GroupBy(value string) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.params["groupBy"] = value
	return b
}


// Where A list of items to filter events by. Only events which match ALL criteria will be included in the results.
func (b *PlatformAnalyticEventSummariesBuilder) Where(values ...map[string]any) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.params["where"] = values
	return b
}



// AccountId The ID of the account to query. If no value is specified, the first account matching the provided domain is chosen.
func (b *PlatformAnalyticEventSummariesBuilder) AccountId(value float32) *PlatformAnalyticEventSummariesBuilder {
	if b.err != nil {
		return b
	}
	b.qpAccountId = &value
	return b
}


// Run executes the platformAnalyticEventSummaries request and returns the response data directly.
func (b *PlatformAnalyticEventSummariesBuilder) Run(ctx context.Context) (*PlatformAnalyticEventSummariesResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["start"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "start is required for platformAnalyticEventSummaries",
			},
		}
	}
	if _, ok := b.params["end"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "end is required for platformAnalyticEventSummaries",
			},
		}
	}
	if _, ok := b.params["groupBy"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "groupBy is required for platformAnalyticEventSummaries",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.PlatformAnalyticEventSummariesJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.PlatformAnalyticEventSummariesParams{}
	if b.qpAccountId != nil {
		params.AccountId = b.qpAccountId
	}

	resp, err := b.client.API().PlatformAnalyticEventSummariesWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &PlatformAnalyticEventSummariesResult{resp.JSON200}, nil
}



// PlatformAnalyticReadsBuilder provides a fluent API for the platformAnalyticReads operation.
// Get read summaries
type PlatformAnalyticReadsBuilder struct {
	client  *Client
	qpDay *types.Date
	params  map[string]any
	err     error
}

// PlatformAnalyticReads starts building a platformAnalyticReads request.
func (c *Client) PlatformAnalyticReads() *PlatformAnalyticReadsBuilder {
	b := &PlatformAnalyticReadsBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// Day The date for which read summaries need to be fetched. This must be date-time only, as YYYY-MM-DD, and a valid date in the past.
func (b *PlatformAnalyticReadsBuilder) Day(value types.Date) *PlatformAnalyticReadsBuilder {
	if b.err != nil {
		return b
	}
	b.qpDay = &value
	return b
}


// Run executes the platformAnalyticReads request and returns the response data directly.
func (b *PlatformAnalyticReadsBuilder) Run(ctx context.Context) (*PlatformAnalyticReadsResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build query params
	params := &generated.PlatformAnalyticReadsParams{}
	if b.qpDay != nil {
		params.Day = b.qpDay
	}

	resp, err := b.client.API().PlatformAnalyticReadsWithResponse(ctx, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &PlatformAnalyticReadsResult{resp.JSON200}, nil
}



// RecordsModifiedSinceBuilder provides a fluent API for the recordsModifiedSince operation.
// Get records modified since
type RecordsModifiedSinceBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// RecordsModifiedSince starts building a recordsModifiedSince request.
func (c *Client) RecordsModifiedSince() *RecordsModifiedSinceBuilder {
	b := &RecordsModifiedSinceBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// FieldList List of field IDs. Each field is crawled across the entire record dependency graph to find its source record's date modified. If one is not provided, only the current table will be referenced.
func (b *RecordsModifiedSinceBuilder) FieldList(values ...int) *RecordsModifiedSinceBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldList"] = values
	return b
}


// IncludeDetails When true, the individual record IDs and timestamps will be returned. If false, only the count of changes will be returned.
func (b *RecordsModifiedSinceBuilder) IncludeDetails(value bool) *RecordsModifiedSinceBuilder {
	if b.err != nil {
		return b
	}
	b.params["includeDetails"] = value
	return b
}


// From The table identifier.
func (b *RecordsModifiedSinceBuilder) From(value string) *RecordsModifiedSinceBuilder {
	if b.err != nil {
		return b
	}
	b.params["from"] = value
	return b
}


// After A timestamp, formatted in ISO-8601 UTC, representing the date and time to search.
func (b *RecordsModifiedSinceBuilder) After(value string) *RecordsModifiedSinceBuilder {
	if b.err != nil {
		return b
	}
	b.params["after"] = value
	return b
}



// Run executes the recordsModifiedSince request and returns the response data directly.
func (b *RecordsModifiedSinceBuilder) Run(ctx context.Context) (*RecordsModifiedSinceResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["after"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "after is required for recordsModifiedSince",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RecordsModifiedSinceJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().RecordsModifiedSinceWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &RecordsModifiedSinceResult{resp.JSON200}, nil
}



// RemoveManagersFromGroupBuilder provides a fluent API for the removeManagersFromGroup operation.
// Remove managers
type RemoveManagersFromGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// RemoveManagersFromGroup starts building a removeManagersFromGroup request.
func (c *Client) RemoveManagersFromGroup(gid float32) *RemoveManagersFromGroupBuilder {
	b := &RemoveManagersFromGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the removeManagersFromGroup request and returns the response data directly.
func (b *RemoveManagersFromGroupBuilder) Run(ctx context.Context) (*RemoveManagersFromGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RemoveManagersFromGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().RemoveManagersFromGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &RemoveManagersFromGroupResult{resp.JSON200}, nil
}



// RemoveMembersFromGroupBuilder provides a fluent API for the removeMembersFromGroup operation.
// Remove members
type RemoveMembersFromGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// RemoveMembersFromGroup starts building a removeMembersFromGroup request.
func (c *Client) RemoveMembersFromGroup(gid float32) *RemoveMembersFromGroupBuilder {
	b := &RemoveMembersFromGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the removeMembersFromGroup request and returns the response data directly.
func (b *RemoveMembersFromGroupBuilder) Run(ctx context.Context) (*RemoveMembersFromGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RemoveMembersFromGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().RemoveMembersFromGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &RemoveMembersFromGroupResult{resp.JSON200}, nil
}



// RemoveSubgroupsFromGroupBuilder provides a fluent API for the removeSubgroupsFromGroup operation.
// Remove child groups
type RemoveSubgroupsFromGroupBuilder struct {
	client  *Client
	gid float32
	params  map[string]any
	err     error
}

// RemoveSubgroupsFromGroup starts building a removeSubgroupsFromGroup request.
func (c *Client) RemoveSubgroupsFromGroup(gid float32) *RemoveSubgroupsFromGroupBuilder {
	b := &RemoveSubgroupsFromGroupBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.gid = gid
	return b
}



// Run executes the removeSubgroupsFromGroup request and returns the response data directly.
func (b *RemoveSubgroupsFromGroupBuilder) Run(ctx context.Context) (*RemoveSubgroupsFromGroupResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RemoveSubgroupsFromGroupJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().RemoveSubgroupsFromGroupWithResponse(ctx, b.gid, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &RemoveSubgroupsFromGroupResult{resp.JSON200}, nil
}



// RemoveTrusteesBuilder provides a fluent API for the removeTrustees operation.
// Remove trustees from an app
type RemoveTrusteesBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// RemoveTrustees starts building a removeTrustees request.
func (c *Client) RemoveTrustees(appId string) *RemoveTrusteesBuilder {
	b := &RemoveTrusteesBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}



// Run executes the removeTrustees request and returns the response data directly.
func (b *RemoveTrusteesBuilder) Run(ctx context.Context) (*RemoveTrusteesResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RemoveTrusteesJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().RemoveTrusteesWithResponse(ctx, b.appId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &RemoveTrusteesResult{resp.JSON200}, nil
}



// RunFormulaBuilder provides a fluent API for the runFormula operation.
// Run a formula
type RunFormulaBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// RunFormula starts building a runFormula request.
func (c *Client) RunFormula() *RunFormulaBuilder {
	b := &RunFormulaBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Formula The formula to run. This must be a valid Quickbase formula.
func (b *RunFormulaBuilder) Formula(value string) *RunFormulaBuilder {
	if b.err != nil {
		return b
	}
	b.params["formula"] = value
	return b
}


// Rid The record ID to run the formula against. Only necessary for formulas that are run in the context of a record. For example, the formula User() does not need a record ID.
func (b *RunFormulaBuilder) Rid(value int) *RunFormulaBuilder {
	if b.err != nil {
		return b
	}
	b.params["rid"] = value
	return b
}


// From The unique identifier (dbid) of the table.
func (b *RunFormulaBuilder) From(value string) *RunFormulaBuilder {
	if b.err != nil {
		return b
	}
	b.params["from"] = value
	return b
}



// Run executes the runFormula request and returns the response data directly.
func (b *RunFormulaBuilder) Run(ctx context.Context) (*RunFormulaResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if _, ok := b.params["formula"]; !ok {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "formula is required for runFormula",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RunFormulaJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().RunFormulaWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &RunFormulaResult{resp.JSON200}, nil
}



// RunReportBuilder provides a fluent API for the runReport operation.
// Run a report
type RunReportBuilder struct {
	client  *Client
	table   string
	tableID string
	reportId string
	qpSkip *int
	qpTop *int
	params  map[string]any
	err     error
}

// RunReport starts building a runReport request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) RunReport(reportId string, table string) *RunReportBuilder {
	b := &RunReportBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.reportId = reportId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// Skip The number of records to skip. You can set this value when paginating through a set of results.
func (b *RunReportBuilder) Skip(value int) *RunReportBuilder {
	if b.err != nil {
		return b
	}
	b.qpSkip = &value
	return b
}


// Top The maximum number of records to return. You can override the default Quickbase pagination to get more or fewer results. If your requested value here exceeds the dynamic maximums, we will return a subset of results and the rest can be gathered in subsequent API calls.
func (b *RunReportBuilder) Top(value int) *RunReportBuilder {
	if b.err != nil {
		return b
	}
	b.qpTop = &value
	return b
}


// Run executes the runReport request and returns the response data directly.
func (b *RunReportBuilder) Run(ctx context.Context) (*RunReportResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.RunReportJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.RunReportParams{}
	params.TableId = b.tableID
	if b.qpSkip != nil {
		params.Skip = b.qpSkip
	}
	if b.qpTop != nil {
		params.Top = b.qpTop
	}

	resp, err := b.client.API().RunReportWithResponse(ctx, b.reportId, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &RunReportResult{resp.JSON200}, nil
}



// TransferUserTokenBuilder provides a fluent API for the transferUserToken operation.
// Transfer a user token
type TransferUserTokenBuilder struct {
	client  *Client
	params  map[string]any
	err     error
}

// TransferUserToken starts building a transferUserToken request.
func (c *Client) TransferUserToken() *TransferUserTokenBuilder {
	b := &TransferUserTokenBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}


// Id The id of the user token to transfer
func (b *TransferUserTokenBuilder) Id(value float64) *TransferUserTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["id"] = value
	return b
}


// From The id of the user to transfer the user token from
func (b *TransferUserTokenBuilder) From(value string) *TransferUserTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["from"] = value
	return b
}


// To The id of the user to transfer the user token to
func (b *TransferUserTokenBuilder) To(value string) *TransferUserTokenBuilder {
	if b.err != nil {
		return b
	}
	b.params["to"] = value
	return b
}



// Run executes the transferUserToken request and returns the response data directly.
func (b *TransferUserTokenBuilder) Run(ctx context.Context) (*TransferUserTokenResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.TransferUserTokenJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().TransferUserTokenWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &TransferUserTokenResult{resp.JSON200}, nil
}



// UndenyUsersBuilder provides a fluent API for the undenyUsers operation.
// Undeny users
type UndenyUsersBuilder struct {
	client  *Client
	qpAccountId *float32
	params  map[string]any
	err     error
}

// UndenyUsers starts building a undenyUsers request.
func (c *Client) UndenyUsers() *UndenyUsersBuilder {
	b := &UndenyUsersBuilder{
		client: c,
		params: make(map[string]any),
	}
	return b
}



// AccountId The account id being used to undeny users. If no value is specified, the first account associated with the requesting user token is chosen.
func (b *UndenyUsersBuilder) AccountId(value float32) *UndenyUsersBuilder {
	if b.err != nil {
		return b
	}
	b.qpAccountId = &value
	return b
}


// Run executes the undenyUsers request and returns the response data directly.
func (b *UndenyUsersBuilder) Run(ctx context.Context) (*UndenyUsersResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UndenyUsersJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.UndenyUsersParams{}
	if b.qpAccountId != nil {
		params.AccountId = b.qpAccountId
	}

	resp, err := b.client.API().UndenyUsersWithResponse(ctx, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &UndenyUsersResult{resp.JSON200}, nil
}



// UpdateAppBuilder provides a fluent API for the updateApp operation.
// Update an app
type UpdateAppBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// UpdateApp starts building a updateApp request.
func (c *Client) UpdateApp(appId string) *UpdateAppBuilder {
	b := &UpdateAppBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}


// Variables The app variables. A maximum of 10 variables can be updated at a time. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
func (b *UpdateAppBuilder) Variables(values ...map[string]any) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["variables"] = values
	return b
}


// Name The name for the app.
func (b *UpdateAppBuilder) Name(value string) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}


// HideFromPublic Hide from public application searches
func (b *UpdateAppBuilder) HideFromPublic(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hideFromPublic"] = value
	b.params["securityProperties"] = nested
	return b
}


// MustBeRealmApproved Only "approved" users may access this application
func (b *UpdateAppBuilder) MustBeRealmApproved(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["mustBeRealmApproved"] = value
	b.params["securityProperties"] = nested
	return b
}


// AllowClone Allow users who are not administrators to copy
func (b *UpdateAppBuilder) AllowClone(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowClone"] = value
	b.params["securityProperties"] = nested
	return b
}


// UseIPFilter Only users logging in from "approved" IP addresses may access this application
func (b *UpdateAppBuilder) UseIPFilter(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useIPFilter"] = value
	b.params["securityProperties"] = nested
	return b
}


// AllowExport Allow users who are not administrators to export data
func (b *UpdateAppBuilder) AllowExport(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowExport"] = value
	b.params["securityProperties"] = nested
	return b
}


// EnableAppTokens Require Application Tokens
func (b *UpdateAppBuilder) EnableAppTokens(value bool) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["securityProperties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["enableAppTokens"] = value
	b.params["securityProperties"] = nested
	return b
}


// Description The description for the app.
func (b *UpdateAppBuilder) Description(value string) *UpdateAppBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}



// Run executes the updateApp request and returns the response data directly.
func (b *UpdateAppBuilder) Run(ctx context.Context) (*UpdateAppResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateAppJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().UpdateAppWithResponse(ctx, b.appId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &UpdateAppResult{resp.JSON200}, nil
}



// UpdateFieldBuilder provides a fluent API for the updateField operation.
// Update a field
type UpdateFieldBuilder struct {
	client  *Client
	table   string
	tableID string
	fieldId int
	params  map[string]any
	err     error
}

// UpdateField starts building a updateField request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) UpdateField(fieldId int, table string) *UpdateFieldBuilder {
	b := &UpdateFieldBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.fieldId = fieldId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// Label The label (name) of the field.
func (b *UpdateFieldBuilder) Label(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["label"] = value
	return b
}


// NoWrap Indicates if the field is configured to not wrap when displayed in the product.
func (b *UpdateFieldBuilder) NoWrap(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["noWrap"] = value
	return b
}


// Bold Indicates if the field is configured to display in bold in the product.
func (b *UpdateFieldBuilder) Bold(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["bold"] = value
	return b
}


// Width The field's html input width in the product.
func (b *UpdateFieldBuilder) Width(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["width"] = value
	b.params["properties"] = nested
	return b
}


// DefaultValue The default value configured for a field when a new record is added.
func (b *UpdateFieldBuilder) DefaultValue(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultValue"] = value
	b.params["properties"] = nested
	return b
}


// AppearsAs The link text, if empty, the url will be used as link text.
func (b *UpdateFieldBuilder) AppearsAs(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["appearsAs"] = value
	b.params["properties"] = nested
	return b
}


// DoesAverage Whether this field averages in reports within the product.
func (b *UpdateFieldBuilder) DoesAverage(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["doesAverage"] = value
	b.params["properties"] = nested
	return b
}


// SeeVersions Indicates if the user can see other versions, aside from the most recent, of a file attachment within the product.
func (b *UpdateFieldBuilder) SeeVersions(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["seeVersions"] = value
	b.params["properties"] = nested
	return b
}


// BlankIsZero Whether a blank value is treated the same as 0 in calculations within the product.
func (b *UpdateFieldBuilder) BlankIsZero(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["blankIsZero"] = value
	b.params["properties"] = nested
	return b
}


// SnapFieldId The id of the field that is used to snapshot values from, when applicable.
func (b *UpdateFieldBuilder) SnapFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["snapFieldId"] = value
	b.params["properties"] = nested
	return b
}


// VersionMode Version modes for files. Keep all versions vs keep last version.
func (b *UpdateFieldBuilder) VersionMode(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["versionMode"] = value
	b.params["properties"] = nested
	return b
}


// UseI18NFormat Whether phone numbers should be in E.164 standard international format
func (b *UpdateFieldBuilder) UseI18NFormat(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useI18NFormat"] = value
	b.params["properties"] = nested
	return b
}


// DefaultToday Indicates if the field value is defaulted today for new records.
func (b *UpdateFieldBuilder) DefaultToday(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultToday"] = value
	b.params["properties"] = nested
	return b
}


// DisplayMonth How to display months.
func (b *UpdateFieldBuilder) DisplayMonth(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayMonth"] = value
	b.params["properties"] = nested
	return b
}


// TargetTableName The field's target table name.
func (b *UpdateFieldBuilder) TargetTableName(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetTableName"] = value
	b.params["properties"] = nested
	return b
}


// AllowMentions If someone can @mention users in the rich text field to generate an email notification.
func (b *UpdateFieldBuilder) AllowMentions(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowMentions"] = value
	b.params["properties"] = nested
	return b
}


// LinkText The configured text value that replaces the URL that users see within the product.
func (b *UpdateFieldBuilder) LinkText(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["linkText"] = value
	b.params["properties"] = nested
	return b
}


// AllowNewChoices Indicates if users can add new choices to a selection list.
func (b *UpdateFieldBuilder) AllowNewChoices(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["allowNewChoices"] = value
	b.params["properties"] = nested
	return b
}


// SummaryFunction The accumulation type for the summary field.
func (b *UpdateFieldBuilder) SummaryFunction(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["summaryFunction"] = value
	b.params["properties"] = nested
	return b
}


// Formula The formula of the field as configured in Quickbase.
func (b *UpdateFieldBuilder) Formula(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["formula"] = value
	b.params["properties"] = nested
	return b
}


// DisplayEmail How the email is displayed.
func (b *UpdateFieldBuilder) DisplayEmail(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayEmail"] = value
	b.params["properties"] = nested
	return b
}


// SummaryTableId The table the summary field references fields from.
func (b *UpdateFieldBuilder) SummaryTableId(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["summaryTableId"] = value
	b.params["properties"] = nested
	return b
}


// CarryChoices Whether the field should carry its multiple choice fields when copied.
func (b *UpdateFieldBuilder) CarryChoices(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["carryChoices"] = value
	b.params["properties"] = nested
	return b
}


// SummaryTargetFieldId The id of the field that is used to aggregate values from the child, when applicable. This displays 0 if the summary function doesn't require a field selection (like count).
func (b *UpdateFieldBuilder) SummaryTargetFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["summaryTargetFieldId"] = value
	b.params["properties"] = nested
	return b
}


// DefaultDomain Default email domain.
func (b *UpdateFieldBuilder) DefaultDomain(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultDomain"] = value
	b.params["properties"] = nested
	return b
}


// DoesTotal Whether this field totals in reports within the product.
func (b *UpdateFieldBuilder) DoesTotal(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["doesTotal"] = value
	b.params["properties"] = nested
	return b
}


// Exact Whether an exact match is required for a report link.
func (b *UpdateFieldBuilder) Exact(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["exact"] = value
	b.params["properties"] = nested
	return b
}


// NumberFormat The format used for displaying numeric values in the product (decimal, separators, digit group).
func (b *UpdateFieldBuilder) NumberFormat(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["numberFormat"] = value
	b.params["properties"] = nested
	return b
}


// DisplayDayOfWeek Indicates whether to display the day of the week within the product.
func (b *UpdateFieldBuilder) DisplayDayOfWeek(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayDayOfWeek"] = value
	b.params["properties"] = nested
	return b
}


// SortAsGiven Indicates if the listed entries sort as entered vs alphabetically.
func (b *UpdateFieldBuilder) SortAsGiven(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sortAsGiven"] = value
	b.params["properties"] = nested
	return b
}


// UseNewWindow Indicates if the file should open a new window when a user clicks it within the product.
func (b *UpdateFieldBuilder) UseNewWindow(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["useNewWindow"] = value
	b.params["properties"] = nested
	return b
}


// DefaultValueLuid Default user id value.
func (b *UpdateFieldBuilder) DefaultValueLuid(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultValueLuid"] = value
	b.params["properties"] = nested
	return b
}


// MaxVersions The maximum number of versions configured for a file attachment.
func (b *UpdateFieldBuilder) MaxVersions(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["maxVersions"] = value
	b.params["properties"] = nested
	return b
}


// DisplayUser The configured option for how users display within the product.
func (b *UpdateFieldBuilder) DisplayUser(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayUser"] = value
	b.params["properties"] = nested
	return b
}


// DisplayCheckboxAsText Indicates whether the checkbox values will be shown as text in reports.
func (b *UpdateFieldBuilder) DisplayCheckboxAsText(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayCheckboxAsText"] = value
	b.params["properties"] = nested
	return b
}


// SortAlpha Whether to sort alphabetically, default sort is by record ID.
func (b *UpdateFieldBuilder) SortAlpha(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sortAlpha"] = value
	b.params["properties"] = nested
	return b
}


// ParentFieldId The id of the parent composite field, when applicable.
func (b *UpdateFieldBuilder) ParentFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["parentFieldId"] = value
	b.params["properties"] = nested
	return b
}


// SourceFieldId The id of the source field.
func (b *UpdateFieldBuilder) SourceFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["sourceFieldId"] = value
	b.params["properties"] = nested
	return b
}


// DecimalPlaces The number of decimal places displayed in the product for this field.
func (b *UpdateFieldBuilder) DecimalPlaces(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["decimalPlaces"] = value
	b.params["properties"] = nested
	return b
}


// CurrencySymbol The current symbol used when displaying field values within the product.
func (b *UpdateFieldBuilder) CurrencySymbol(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["currencySymbol"] = value
	b.params["properties"] = nested
	return b
}


// Choices An array of entries that exist for a field that offers choices to the user. Note that these choices refer to the valid values of any records added in the future. You are allowed to remove values from the list of choices even if there are existing records with those values in this field. They will be displayed in red when users look at the data in the browser but there is no other effect. While updating a field with this property, the old choices are removed and replaced by the new choices.
func (b *UpdateFieldBuilder) Choices(value []string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["choices"] = value
	b.params["properties"] = nested
	return b
}


// DisplayRelative Whether to display time as relative.
func (b *UpdateFieldBuilder) DisplayRelative(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayRelative"] = value
	b.params["properties"] = nested
	return b
}


// AutoSave Whether the link field will auto save.
func (b *UpdateFieldBuilder) AutoSave(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["autoSave"] = value
	b.params["properties"] = nested
	return b
}


// OpenTargetIn Indicates which target the URL should open in when a user clicks it within the product.
func (b *UpdateFieldBuilder) OpenTargetIn(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["openTargetIn"] = value
	b.params["properties"] = nested
	return b
}


// LookupTargetFieldId The id of the field that is the target on the parent table for this lookup.
func (b *UpdateFieldBuilder) LookupTargetFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["lookupTargetFieldId"] = value
	b.params["properties"] = nested
	return b
}


// Hours24 Indicates whether or not to display time in the 24-hour format within the product.
func (b *UpdateFieldBuilder) Hours24(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hours24"] = value
	b.params["properties"] = nested
	return b
}


// AppendOnly Whether this field is append only.
func (b *UpdateFieldBuilder) AppendOnly(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["appendOnly"] = value
	b.params["properties"] = nested
	return b
}


// MaxLength The maximum number of characters allowed for entry in Quickbase for this field.
func (b *UpdateFieldBuilder) MaxLength(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["maxLength"] = value
	b.params["properties"] = nested
	return b
}


// DefaultCountryCode Controls the default country shown on international phone widgets on forms. Country code should be entered in the ISO 3166-1 alpha-2 format.
func (b *UpdateFieldBuilder) DefaultCountryCode(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultCountryCode"] = value
	b.params["properties"] = nested
	return b
}


// CoverText An alternate user friendly text that can be used to display a link in the browser.
func (b *UpdateFieldBuilder) CoverText(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["coverText"] = value
	b.params["properties"] = nested
	return b
}


// DisplayAsLink Indicates if a field that is part of the relationship should be shown as a hyperlink to the parent record within the product.
func (b *UpdateFieldBuilder) DisplayAsLink(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayAsLink"] = value
	b.params["properties"] = nested
	return b
}


// TargetTableId The id of the target table.
func (b *UpdateFieldBuilder) TargetTableId(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetTableId"] = value
	b.params["properties"] = nested
	return b
}


// Comments The comments entered on the field properties by an administrator.
func (b *UpdateFieldBuilder) Comments(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["comments"] = value
	b.params["properties"] = nested
	return b
}


// DefaultKind The user default type.
func (b *UpdateFieldBuilder) DefaultKind(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["defaultKind"] = value
	b.params["properties"] = nested
	return b
}


// Abbreviate Don't show the URL protocol when showing the URL.
func (b *UpdateFieldBuilder) Abbreviate(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["abbreviate"] = value
	b.params["properties"] = nested
	return b
}


// SummaryReferenceFieldId The id of the field that is the reference in the relationship for this summary.
func (b *UpdateFieldBuilder) SummaryReferenceFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["summaryReferenceFieldId"] = value
	b.params["properties"] = nested
	return b
}


// LookupReferenceFieldId The id of the field that is the reference in the relationship for this lookup.
func (b *UpdateFieldBuilder) LookupReferenceFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["lookupReferenceFieldId"] = value
	b.params["properties"] = nested
	return b
}


// Units The units label.
func (b *UpdateFieldBuilder) Units(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["units"] = value
	b.params["properties"] = nested
	return b
}


// NumLines The number of lines shown in Quickbase for this text field.
func (b *UpdateFieldBuilder) NumLines(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["numLines"] = value
	b.params["properties"] = nested
	return b
}


// TargetFieldId The id of the target field.
func (b *UpdateFieldBuilder) TargetFieldId(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["targetFieldId"] = value
	b.params["properties"] = nested
	return b
}


// CommaStart The number of digits before commas display in the product, when applicable.
func (b *UpdateFieldBuilder) CommaStart(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["commaStart"] = value
	b.params["properties"] = nested
	return b
}


// HasExtension Whether this field has a phone extension.
func (b *UpdateFieldBuilder) HasExtension(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["hasExtension"] = value
	b.params["properties"] = nested
	return b
}


// CurrencyFormat The currency format used when displaying field values within the product.
func (b *UpdateFieldBuilder) CurrencyFormat(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["currencyFormat"] = value
	b.params["properties"] = nested
	return b
}


// CompositeFields An array of the fields that make up a composite field (e.g., address).
func (b *UpdateFieldBuilder) CompositeFields(value []any) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["compositeFields"] = value
	b.params["properties"] = nested
	return b
}


// Format The format to display time.
func (b *UpdateFieldBuilder) Format(value int) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["format"] = value
	b.params["properties"] = nested
	return b
}


// SummaryQuery The summary query.
func (b *UpdateFieldBuilder) SummaryQuery(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["summaryQuery"] = value
	b.params["properties"] = nested
	return b
}


// DisplayTime Indicates whether to display the time, in addition to the date.
func (b *UpdateFieldBuilder) DisplayTime(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayTime"] = value
	b.params["properties"] = nested
	return b
}


// PostTempToken POSTs a temporary token to the first URL when clicked by a user. [Learn more](https://help.quickbase.com/docs/post-temporary-token-from-a-quickbase-field)
func (b *UpdateFieldBuilder) PostTempToken(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["postTempToken"] = value
	b.params["properties"] = nested
	return b
}


// DisplayTimezone Indicates whether to display the timezone within the product.
func (b *UpdateFieldBuilder) DisplayTimezone(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	nested, _ := b.params["properties"].(map[string]any)
	if nested == nil {
		nested = make(map[string]any)
	}
	nested["displayTimezone"] = value
	b.params["properties"] = nested
	return b
}


// Permissions Field Permissions for different roles.
func (b *UpdateFieldBuilder) Permissions(values ...map[string]any) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["permissions"] = values
	return b
}


// AddToForms Whether the field you are adding should appear on forms.
func (b *UpdateFieldBuilder) AddToForms(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["addToForms"] = value
	return b
}


// FindEnabled Indicates if the field is marked as searchable.
func (b *UpdateFieldBuilder) FindEnabled(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["findEnabled"] = value
	return b
}


// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs. You can only set this property to "true" if the app has audit logs enabled. See Enable data change logs under [Quickbase Audit Logs](https://help.quickbase.com/user-assistance/audit_logs.html).
func (b *UpdateFieldBuilder) Audited(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["audited"] = value
	return b
}


// FieldHelp The configured help text shown to users within the product.
func (b *UpdateFieldBuilder) FieldHelp(value string) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldHelp"] = value
	return b
}


// Required Indicates if the field is required (i.e. if every record must have a non-null value in this field). If you attempt to change a field from not-required to required, and the table currently contains records that have null values in that field, you will get an error indicating that there are null values of the field. In this case you need to find and update those records with null values of the field before changing the field to required.
func (b *UpdateFieldBuilder) Required(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["required"] = value
	return b
}


// AppearsByDefault Indicates if the field is marked as a default in reports.
func (b *UpdateFieldBuilder) AppearsByDefault(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["appearsByDefault"] = value
	return b
}


// Unique Indicates if every record in the table must contain a unique value of this field. If you attempt to change a field from not-unique to unique, and the table currently contains records with the same value of this field, you will get an error. In this case you need to find and update those records with duplicate values of the field before changing the field to unique.
func (b *UpdateFieldBuilder) Unique(value bool) *UpdateFieldBuilder {
	if b.err != nil {
		return b
	}
	b.params["unique"] = value
	return b
}



// Run executes the updateField request and returns the response data directly.
func (b *UpdateFieldBuilder) Run(ctx context.Context) (*UpdateFieldResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateFieldJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.UpdateFieldParams{}
	params.TableId = b.tableID

	resp, err := b.client.API().UpdateFieldWithResponse(ctx, b.fieldId, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &UpdateFieldResult{resp.JSON200}, nil
}



// UpdateRelationshipBuilder provides a fluent API for the updateRelationship operation.
// Update a relationship
type UpdateRelationshipBuilder struct {
	client  *Client
	table   string
	tableID string
	relationshipId float32
	params  map[string]any
	err     error
}

// UpdateRelationship starts building a updateRelationship request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) UpdateRelationship(table string, relationshipId float32) *UpdateRelationshipBuilder {
	b := &UpdateRelationshipBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.relationshipId = relationshipId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// SummaryFields An array of objects, each representing a configuration of one field from the child table, that will become summary fields on the parent table. When you specify the 'COUNT' accumulation type, you have to specify 0 as the summaryFid (or not set it in the request). 'DISTINCT-COUNT' requires that summaryFid be set to an actual fid.
func (b *UpdateRelationshipBuilder) SummaryFields(values ...map[string]any) *UpdateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	b.params["summaryFields"] = values
	return b
}


// LookupFieldIds An array of field IDs on the parent table that will become lookup fields on the child table.
func (b *UpdateRelationshipBuilder) LookupFieldIds(values ...int) *UpdateRelationshipBuilder {
	if b.err != nil {
		return b
	}
	b.params["lookupFieldIds"] = values
	return b
}



// Run executes the updateRelationship request and returns the response data directly.
func (b *UpdateRelationshipBuilder) Run(ctx context.Context) (*UpdateRelationshipResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	body["tableId"] = b.tableID
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateRelationshipJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().UpdateRelationshipWithResponse(ctx, b.tableID, b.relationshipId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &UpdateRelationshipResult{resp.JSON200}, nil
}



// UpdateSolutionBuilder provides a fluent API for the updateSolution operation.
// Update a solution
type UpdateSolutionBuilder struct {
	client  *Client
	solutionId string
	params  map[string]any
	err     error
}

// UpdateSolution starts building a updateSolution request.
func (c *Client) UpdateSolution(solutionId string) *UpdateSolutionBuilder {
	b := &UpdateSolutionBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	return b
}



// Run executes the updateSolution request and returns the response data directly.
func (b *UpdateSolutionBuilder) Run(ctx context.Context) (*generated.UpdateSolutionResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateSolutionJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.UpdateSolutionParams{}

	resp, err := b.client.API().UpdateSolutionWithResponse(ctx, b.solutionId, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// UpdateSolutionToRecordBuilder provides a fluent API for the updateSolutionToRecord operation.
// Update solution from record
type UpdateSolutionToRecordBuilder struct {
	client  *Client
	table   string
	tableID string
	solutionId string
	qpFieldId *int
	qpRecordId *int
	params  map[string]any
	err     error
}

// UpdateSolutionToRecord starts building a updateSolutionToRecord request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) UpdateSolutionToRecord(solutionId string, table string) *UpdateSolutionToRecordBuilder {
	b := &UpdateSolutionToRecordBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.solutionId = solutionId
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}



// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
func (b *UpdateSolutionToRecordBuilder) FieldId(value int) *UpdateSolutionToRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpFieldId = &value
	return b
}


// RecordId The unique identifier of the record.
func (b *UpdateSolutionToRecordBuilder) RecordId(value int) *UpdateSolutionToRecordBuilder {
	if b.err != nil {
		return b
	}
	b.qpRecordId = &value
	return b
}


// Run executes the updateSolutionToRecord request and returns the response data directly.
func (b *UpdateSolutionToRecordBuilder) Run(ctx context.Context) (*generated.UpdateSolutionToRecordResponse, error) {
	if b.err != nil {
		return nil, b.err
	}
	// tableId is validated via table resolution
	if b.qpFieldId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "fieldId is required for updateSolutionToRecord",
			},
		}
	}
	if b.qpRecordId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "recordId is required for updateSolutionToRecord",
			},
		}
	}
	// Build query params
	params := &generated.UpdateSolutionToRecordParams{}
	params.TableId = b.tableID
	if b.qpFieldId != nil {
		params.FieldId = *b.qpFieldId
	}
	if b.qpRecordId != nil {
		params.RecordId = *b.qpRecordId
	}

	resp, err := b.client.API().UpdateSolutionToRecordWithResponse(ctx, b.solutionId, params)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return resp, nil
}



// UpdateTableBuilder provides a fluent API for the updateTable operation.
// Update a table
type UpdateTableBuilder struct {
	client  *Client
	table   string
	tableID string
	qpAppId *string
	params  map[string]any
	err     error
}

// UpdateTable starts building a updateTable request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) UpdateTable(table string) *UpdateTableBuilder {
	b := &UpdateTableBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// Description The description for the table. If this value is not passed the default value is blank.
func (b *UpdateTableBuilder) Description(value string) *UpdateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["description"] = value
	return b
}


// Name The name for the table.
func (b *UpdateTableBuilder) Name(value string) *UpdateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["name"] = value
	return b
}


// PluralRecordName The plural noun for records in the table. If this value is not passed the default value is 'Records'.
func (b *UpdateTableBuilder) PluralRecordName(value string) *UpdateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["pluralRecordName"] = value
	return b
}


// SingleRecordName The singular noun for records in the table. If this value is not passed the default value is 'Record'.
func (b *UpdateTableBuilder) SingleRecordName(value string) *UpdateTableBuilder {
	if b.err != nil {
		return b
	}
	b.params["singleRecordName"] = value
	return b
}



// AppId The unique identifier of an app
func (b *UpdateTableBuilder) AppId(value string) *UpdateTableBuilder {
	if b.err != nil {
		return b
	}
	b.qpAppId = &value
	return b
}


// Run executes the updateTable request and returns the response data directly.
func (b *UpdateTableBuilder) Run(ctx context.Context) (*UpdateTableResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	if b.qpAppId == nil {
		return nil, &core.ValidationError{
			QuickbaseError: core.QuickbaseError{
				Message: "appId is required for updateTable",
			},
		}
	}
	// Build request body from params
	body := make(map[string]any)
	body["tableId"] = b.tableID
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateTableJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}
	// Build query params
	params := &generated.UpdateTableParams{}
	if b.qpAppId != nil {
		params.AppId = *b.qpAppId
	}

	resp, err := b.client.API().UpdateTableWithResponse(ctx, b.tableID, params, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &UpdateTableResult{resp.JSON200}, nil
}



// UpdateTrusteesBuilder provides a fluent API for the updateTrustees operation.
// Update trustees of an app
type UpdateTrusteesBuilder struct {
	client  *Client
	appId string
	params  map[string]any
	err     error
}

// UpdateTrustees starts building a updateTrustees request.
func (c *Client) UpdateTrustees(appId string) *UpdateTrusteesBuilder {
	b := &UpdateTrusteesBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.appId = appId
	return b
}



// Run executes the updateTrustees request and returns the response data directly.
func (b *UpdateTrusteesBuilder) Run(ctx context.Context) (*UpdateTrusteesResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpdateTrusteesJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().UpdateTrusteesWithResponse(ctx, b.appId, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &UpdateTrusteesResult{resp.JSON200}, nil
}



// UpsertBuilder provides a fluent API for the upsert operation.
// Insert/Update record(s)
type UpsertBuilder struct {
	client  *Client
	table   string
	tableID string
	params  map[string]any
	err     error
}

// Upsert starts building a upsert request.
// The table parameter can be a table ID or an alias (if schema is configured).
func (c *Client) Upsert(table string) *UpsertBuilder {
	b := &UpsertBuilder{
		client: c,
		params: make(map[string]any),
	}
	b.table = table
	if c.schema != nil {
		tableID, err := core.ResolveTableAlias(c.schema, table)
		if err != nil {
			b.err = err
			return b
		}
		b.tableID = tableID
	} else {
		b.tableID = table
	}
	return b
}


// Data Record data array, where each record contains key-value mappings of fields to be defined/updated and their values.
func (b *UpsertBuilder) Data(values ...any) *UpsertBuilder {
	if b.err != nil {
		return b
	}
	b.params["data"] = values
	return b
}


// MergeFieldId The merge field id.
func (b *UpsertBuilder) MergeFieldId(value int) *UpsertBuilder {
	if b.err != nil {
		return b
	}
	b.params["mergeFieldId"] = value
	return b
}


// FieldsToReturn Specify an array of field IDs that will return data for any updates or added record. Record ID (FID 3) is always returned if any field ID is requested.
func (b *UpsertBuilder) FieldsToReturn(values ...int) *UpsertBuilder {
	if b.err != nil {
		return b
	}
	b.params["fieldsToReturn"] = values
	return b
}



// Run executes the upsert request and returns the response data directly.
func (b *UpsertBuilder) Run(ctx context.Context) (*UpsertResult, error) {
	if b.err != nil {
		return nil, b.err
	}
	// Build request body from params
	body := make(map[string]any)
	body["to"] = b.tableID
	for k, v := range b.params {
		body[k] = v
	}

	// Convert to JSON and back to the generated type
	jsonBytes, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}

	var reqBody generated.UpsertJSONRequestBody
	if err := json.Unmarshal(jsonBytes, &reqBody); err != nil {
		return nil, err
	}

	resp, err := b.client.API().UpsertWithResponse(ctx, reqBody)
	if err != nil {
		return nil, err
	}
	if resp.JSON200 == nil {
		return nil, parseAPIError(resp.StatusCode(), resp.Body, resp.HTTPResponse)
	}
	return &UpsertResult{resp.JSON200}, nil
}


// Ensure imports are used
var (
	_ = fmt.Sprintf
	_ = json.Marshal
	_ = strconv.Itoa
	_ = core.ValidationError{}
)

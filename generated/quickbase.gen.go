// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	UserTokenScopes = "userToken.Scopes"
)

// Defines values for SortFieldOrder.
const (
	SortFieldOrderASC         SortFieldOrder = "ASC"
	SortFieldOrderDESC        SortFieldOrder = "DESC"
	SortFieldOrderEqualValues SortFieldOrder = "equal-values"
)

// Defines values for PlatformAnalyticEventSummariesJSONBodyGroupBy.
const (
	PlatformAnalyticEventSummariesJSONBodyGroupByApp  PlatformAnalyticEventSummariesJSONBodyGroupBy = "app"
	PlatformAnalyticEventSummariesJSONBodyGroupByUser PlatformAnalyticEventSummariesJSONBodyGroupBy = "user"
)

// Defines values for PlatformAnalyticEventSummariesJSONBodyWhereType.
const (
	PlatformAnalyticEventSummariesJSONBodyWhereTypeApp  PlatformAnalyticEventSummariesJSONBodyWhereType = "app"
	PlatformAnalyticEventSummariesJSONBodyWhereTypeUser PlatformAnalyticEventSummariesJSONBodyWhereType = "user"
)

// Defines values for RemoveTrusteesJSONBodyType.
const (
	RemoveTrusteesJSONBodyTypeDomGroup RemoveTrusteesJSONBodyType = "dom-group"
	RemoveTrusteesJSONBodyTypeGroup    RemoveTrusteesJSONBodyType = "group"
	RemoveTrusteesJSONBodyTypeUser     RemoveTrusteesJSONBodyType = "user"
)

// Defines values for UpdateTrusteesJSONBodyType.
const (
	UpdateTrusteesJSONBodyTypeDomGroup UpdateTrusteesJSONBodyType = "dom-group"
	UpdateTrusteesJSONBodyTypeGroup    UpdateTrusteesJSONBodyType = "group"
	UpdateTrusteesJSONBodyTypeUser     UpdateTrusteesJSONBodyType = "user"
)

// Defines values for AddTrusteesJSONBodyType.
const (
	AddTrusteesJSONBodyTypeDomGroup AddTrusteesJSONBodyType = "dom-group"
	AddTrusteesJSONBodyTypeGroup    AddTrusteesJSONBodyType = "group"
	AddTrusteesJSONBodyTypeUser     AddTrusteesJSONBodyType = "user"
)

// Defines values for ExchangeSsoTokenJSONBodyGrantType.
const (
	UrnIetfParamsOauthGrantTypeTokenExchange ExchangeSsoTokenJSONBodyGrantType = "urn:ietf:params:oauth:grant-type:token-exchange"
)

// Defines values for ExchangeSsoTokenJSONBodyRequestedTokenType.
const (
	UrnQuickbaseParamsOauthTokenTypeTempTicket ExchangeSsoTokenJSONBodyRequestedTokenType = "urn:quickbase:params:oauth:token-type:temp_ticket"
	UrnQuickbaseParamsOauthTokenTypeTempToken  ExchangeSsoTokenJSONBodyRequestedTokenType = "urn:quickbase:params:oauth:token-type:temp_token"
)

// Defines values for ExchangeSsoTokenJSONBodySubjectTokenType.
const (
	UrnIetfParamsOauthTokenTypeSaml2 ExchangeSsoTokenJSONBodySubjectTokenType = "urn:ietf:params:oauth:token-type:saml2"
)

// Defines values for GenerateDocumentParamsFormat.
const (
	Docx GenerateDocumentParamsFormat = "docx"
	Html GenerateDocumentParamsFormat = "html"
	Pdf  GenerateDocumentParamsFormat = "pdf"
)

// Defines values for GenerateDocumentParamsUnit.
const (
	Cm GenerateDocumentParamsUnit = "cm"
	In GenerateDocumentParamsUnit = "in"
	Nm GenerateDocumentParamsUnit = "nm"
	Px GenerateDocumentParamsUnit = "px"
)

// Defines values for GenerateDocumentParamsPageSize.
const (
	A3      GenerateDocumentParamsPageSize = "A3"
	A4      GenerateDocumentParamsPageSize = "A4"
	A5      GenerateDocumentParamsPageSize = "A5"
	A6      GenerateDocumentParamsPageSize = "A6"
	Legal   GenerateDocumentParamsPageSize = "Legal"
	Letter  GenerateDocumentParamsPageSize = "Letter"
	Tabloid GenerateDocumentParamsPageSize = "Tabloid"
)

// Defines values for GenerateDocumentParamsOrientation.
const (
	Landscape GenerateDocumentParamsOrientation = "landscape"
	Portrait  GenerateDocumentParamsOrientation = "portrait"
)

// Defines values for GenerateDocumentParamsAccept.
const (
	Applicationjson        GenerateDocumentParamsAccept = "application/json"
	ApplicationoctetStream GenerateDocumentParamsAccept = "application/octet-stream"
)

// Defines values for CreateFieldJSONBodyFieldType.
const (
	CreateFieldJSONBodyFieldTypeAddress            CreateFieldJSONBodyFieldType = "address"
	CreateFieldJSONBodyFieldTypeCheckbox           CreateFieldJSONBodyFieldType = "checkbox"
	CreateFieldJSONBodyFieldTypeCurrency           CreateFieldJSONBodyFieldType = "currency"
	CreateFieldJSONBodyFieldTypeDate               CreateFieldJSONBodyFieldType = "date"
	CreateFieldJSONBodyFieldTypeDatetime           CreateFieldJSONBodyFieldType = "datetime"
	CreateFieldJSONBodyFieldTypeDuration           CreateFieldJSONBodyFieldType = "duration"
	CreateFieldJSONBodyFieldTypeEmail              CreateFieldJSONBodyFieldType = "email"
	CreateFieldJSONBodyFieldTypeFile               CreateFieldJSONBodyFieldType = "file"
	CreateFieldJSONBodyFieldTypeMultitext          CreateFieldJSONBodyFieldType = "multitext"
	CreateFieldJSONBodyFieldTypeMultiuser          CreateFieldJSONBodyFieldType = "multiuser"
	CreateFieldJSONBodyFieldTypeNumeric            CreateFieldJSONBodyFieldType = "numeric"
	CreateFieldJSONBodyFieldTypePercent            CreateFieldJSONBodyFieldType = "percent"
	CreateFieldJSONBodyFieldTypePhone              CreateFieldJSONBodyFieldType = "phone"
	CreateFieldJSONBodyFieldTypeRating             CreateFieldJSONBodyFieldType = "rating"
	CreateFieldJSONBodyFieldTypeRichText           CreateFieldJSONBodyFieldType = "rich-text"
	CreateFieldJSONBodyFieldTypeText               CreateFieldJSONBodyFieldType = "text"
	CreateFieldJSONBodyFieldTypeTextMultiLine      CreateFieldJSONBodyFieldType = "text-multi-line"
	CreateFieldJSONBodyFieldTypeTextMultipleChoice CreateFieldJSONBodyFieldType = "text-multiple-choice"
	CreateFieldJSONBodyFieldTypeTimeofday          CreateFieldJSONBodyFieldType = "timeofday"
	CreateFieldJSONBodyFieldTypeTimestamp          CreateFieldJSONBodyFieldType = "timestamp"
	CreateFieldJSONBodyFieldTypeUrl                CreateFieldJSONBodyFieldType = "url"
	CreateFieldJSONBodyFieldTypeUser               CreateFieldJSONBodyFieldType = "user"
)

// Defines values for CreateFieldJSONBodyPropertiesCurrencyFormat.
const (
	CreateFieldJSONBodyPropertiesCurrencyFormatLeft   CreateFieldJSONBodyPropertiesCurrencyFormat = "left"
	CreateFieldJSONBodyPropertiesCurrencyFormatMiddle CreateFieldJSONBodyPropertiesCurrencyFormat = "middle"
	CreateFieldJSONBodyPropertiesCurrencyFormatRight  CreateFieldJSONBodyPropertiesCurrencyFormat = "right"
)

// Defines values for CreateFieldJSONBodyPropertiesOpenTargetIn.
const (
	CreateFieldJSONBodyPropertiesOpenTargetInNewWindow  CreateFieldJSONBodyPropertiesOpenTargetIn = "newWindow"
	CreateFieldJSONBodyPropertiesOpenTargetInPopup      CreateFieldJSONBodyPropertiesOpenTargetIn = "popup"
	CreateFieldJSONBodyPropertiesOpenTargetInSameWindow CreateFieldJSONBodyPropertiesOpenTargetIn = "sameWindow"
)

// Defines values for CreateFieldJSONBodyPropertiesVersionMode.
const (
	CreateFieldJSONBodyPropertiesVersionModeKeepallversions  CreateFieldJSONBodyPropertiesVersionMode = "keepallversions"
	CreateFieldJSONBodyPropertiesVersionModeKeeplastversions CreateFieldJSONBodyPropertiesVersionMode = "keeplastversions"
)

// Defines values for UpdateFieldJSONBodyPropertiesCurrencyFormat.
const (
	UpdateFieldJSONBodyPropertiesCurrencyFormatLeft   UpdateFieldJSONBodyPropertiesCurrencyFormat = "left"
	UpdateFieldJSONBodyPropertiesCurrencyFormatMiddle UpdateFieldJSONBodyPropertiesCurrencyFormat = "middle"
	UpdateFieldJSONBodyPropertiesCurrencyFormatRight  UpdateFieldJSONBodyPropertiesCurrencyFormat = "right"
)

// Defines values for UpdateFieldJSONBodyPropertiesOpenTargetIn.
const (
	UpdateFieldJSONBodyPropertiesOpenTargetInNewWindow  UpdateFieldJSONBodyPropertiesOpenTargetIn = "newWindow"
	UpdateFieldJSONBodyPropertiesOpenTargetInPopup      UpdateFieldJSONBodyPropertiesOpenTargetIn = "popup"
	UpdateFieldJSONBodyPropertiesOpenTargetInSameWindow UpdateFieldJSONBodyPropertiesOpenTargetIn = "sameWindow"
)

// Defines values for UpdateFieldJSONBodyPropertiesSummaryFunction.
const (
	UpdateFieldJSONBodyPropertiesSummaryFunctionAVG           UpdateFieldJSONBodyPropertiesSummaryFunction = "AVG"
	UpdateFieldJSONBodyPropertiesSummaryFunctionCOMBINEDTEXT  UpdateFieldJSONBodyPropertiesSummaryFunction = "COMBINED-TEXT"
	UpdateFieldJSONBodyPropertiesSummaryFunctionCOMBINEDUSER  UpdateFieldJSONBodyPropertiesSummaryFunction = "COMBINED-USER"
	UpdateFieldJSONBodyPropertiesSummaryFunctionCOUNT         UpdateFieldJSONBodyPropertiesSummaryFunction = "COUNT"
	UpdateFieldJSONBodyPropertiesSummaryFunctionDISTINCTCOUNT UpdateFieldJSONBodyPropertiesSummaryFunction = "DISTINCT-COUNT"
	UpdateFieldJSONBodyPropertiesSummaryFunctionMAX           UpdateFieldJSONBodyPropertiesSummaryFunction = "MAX"
	UpdateFieldJSONBodyPropertiesSummaryFunctionMIN           UpdateFieldJSONBodyPropertiesSummaryFunction = "MIN"
	UpdateFieldJSONBodyPropertiesSummaryFunctionSTDDEV        UpdateFieldJSONBodyPropertiesSummaryFunction = "STD-DEV"
	UpdateFieldJSONBodyPropertiesSummaryFunctionSUM           UpdateFieldJSONBodyPropertiesSummaryFunction = "SUM"
)

// Defines values for UpdateFieldJSONBodyPropertiesVersionMode.
const (
	UpdateFieldJSONBodyPropertiesVersionModeKeepallversions  UpdateFieldJSONBodyPropertiesVersionMode = "keepallversions"
	UpdateFieldJSONBodyPropertiesVersionModeKeeplastversions UpdateFieldJSONBodyPropertiesVersionMode = "keeplastversions"
)

// Defines values for RunQueryJSONBodyGroupByGrouping.
const (
	RunQueryJSONBodyGroupByGroupingEqualValues RunQueryJSONBodyGroupByGrouping = "equal-values"
)

// Defines values for RunQueryJSONBodySortBy1.
const (
	False RunQueryJSONBodySortBy1 = false
)

// Defines values for CreateRelationshipJSONBodySummaryFieldsAccumulationType.
const (
	CreateRelationshipJSONBodySummaryFieldsAccumulationTypeAVG           CreateRelationshipJSONBodySummaryFieldsAccumulationType = "AVG"
	CreateRelationshipJSONBodySummaryFieldsAccumulationTypeCOMBINEDTEXT  CreateRelationshipJSONBodySummaryFieldsAccumulationType = "COMBINED-TEXT"
	CreateRelationshipJSONBodySummaryFieldsAccumulationTypeCOMBINEDUSER  CreateRelationshipJSONBodySummaryFieldsAccumulationType = "COMBINED-USER"
	CreateRelationshipJSONBodySummaryFieldsAccumulationTypeCOUNT         CreateRelationshipJSONBodySummaryFieldsAccumulationType = "COUNT"
	CreateRelationshipJSONBodySummaryFieldsAccumulationTypeDISTINCTCOUNT CreateRelationshipJSONBodySummaryFieldsAccumulationType = "DISTINCT-COUNT"
	CreateRelationshipJSONBodySummaryFieldsAccumulationTypeMAX           CreateRelationshipJSONBodySummaryFieldsAccumulationType = "MAX"
	CreateRelationshipJSONBodySummaryFieldsAccumulationTypeMIN           CreateRelationshipJSONBodySummaryFieldsAccumulationType = "MIN"
	CreateRelationshipJSONBodySummaryFieldsAccumulationTypeSTDDEV        CreateRelationshipJSONBodySummaryFieldsAccumulationType = "STD-DEV"
	CreateRelationshipJSONBodySummaryFieldsAccumulationTypeSUM           CreateRelationshipJSONBodySummaryFieldsAccumulationType = "SUM"
)

// Defines values for UpdateRelationshipJSONBodySummaryFieldsAccumulationType.
const (
	AVG           UpdateRelationshipJSONBodySummaryFieldsAccumulationType = "AVG"
	COMBINEDTEXT  UpdateRelationshipJSONBodySummaryFieldsAccumulationType = "COMBINED-TEXT"
	COMBINEDUSER  UpdateRelationshipJSONBodySummaryFieldsAccumulationType = "COMBINED-USER"
	COUNT         UpdateRelationshipJSONBodySummaryFieldsAccumulationType = "COUNT"
	DISTINCTCOUNT UpdateRelationshipJSONBodySummaryFieldsAccumulationType = "DISTINCT-COUNT"
	MAX           UpdateRelationshipJSONBodySummaryFieldsAccumulationType = "MAX"
	MIN           UpdateRelationshipJSONBodySummaryFieldsAccumulationType = "MIN"
	STDDEV        UpdateRelationshipJSONBodySummaryFieldsAccumulationType = "STD-DEV"
	SUM           UpdateRelationshipJSONBodySummaryFieldsAccumulationType = "SUM"
)

// FieldValue A field value in a QuickBase record. The value type depends on the field type.
type FieldValue struct {
	// Value The field value. Type depends on field type: string (text, email, URL, date), number (numeric fields), boolean (checkbox), string[] (multi-select), or object[] (file attachments).
	Value FieldValue_Value `json:"value"`
}

// FieldValueValue0 defines model for .
type FieldValueValue0 = string

// FieldValueValue1 defines model for .
type FieldValueValue1 = float32

// FieldValueValue2 defines model for .
type FieldValueValue2 = bool

// FieldValueValue3 defines model for .
type FieldValueValue3 = []string

// FieldValueValue4 defines model for .
type FieldValueValue4 = []struct {
	// Id File attachment ID
	Id *string `json:"id,omitempty"`
}

// FieldValue_Value The field value. Type depends on field type: string (text, email, URL, date), number (numeric fields), boolean (checkbox), string[] (multi-select), or object[] (file attachments).
type FieldValue_Value struct {
	union json.RawMessage
}

// QuickbaseRecord A QuickBase record where keys are field IDs (as strings) and values are FieldValue objects.
type QuickbaseRecord map[string]FieldValue

// SortField A field to sort by in a query.
type SortField struct {
	// FieldId The unique identifier of a field in a table.
	FieldId int `json:"fieldId"`

	// Order Sort based on ascending order (ASC), descending order (DESC) or equal values (equal-values).
	Order SortFieldOrder `json:"order"`
}

// SortFieldOrder Sort based on ascending order (ASC), descending order (DESC) or equal values (equal-values).
type SortFieldOrder string

// PlatformAnalyticEventSummariesJSONBody defines parameters for PlatformAnalyticEventSummaries.
type PlatformAnalyticEventSummariesJSONBody struct {
	// End The end date and time of the requested summaries in ISO 8601 time format.
	End time.Time `json:"end"`

	// GroupBy How the events should be grouped.
	GroupBy PlatformAnalyticEventSummariesJSONBodyGroupBy `json:"groupBy"`

	// NextToken A pagination token from a previous response made using the same parameters. Used to fetch the next page.
	NextToken *string `json:"nextToken,omitempty"`

	// Start The start date and time of the requested summaries in ISO 8601 time format.
	Start time.Time `json:"start"`

	// Where A list of items to filter events by. Only events which match ALL criteria will be included in the results.
	Where *[]struct {
		// Id Id of the item to filter by - the hash uid if filtering a user, or the app id if filtering an app.
		Id string `json:"id"`

		// Type The type of item to filter by.
		Type PlatformAnalyticEventSummariesJSONBodyWhereType `json:"type"`
	} `json:"where,omitempty"`
}

// PlatformAnalyticEventSummariesParams defines parameters for PlatformAnalyticEventSummaries.
type PlatformAnalyticEventSummariesParams struct {
	// AccountId The ID of the account to query. If no value is specified, the first account matching the provided domain is chosen.
	AccountId *float32 `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// PlatformAnalyticEventSummariesJSONBodyGroupBy defines parameters for PlatformAnalyticEventSummaries.
type PlatformAnalyticEventSummariesJSONBodyGroupBy string

// PlatformAnalyticEventSummariesJSONBodyWhereType defines parameters for PlatformAnalyticEventSummaries.
type PlatformAnalyticEventSummariesJSONBodyWhereType string

// PlatformAnalyticReadsParams defines parameters for PlatformAnalyticReads.
type PlatformAnalyticReadsParams struct {
	// Day The date for which read summaries need to be fetched. This must be date-time only, as YYYY-MM-DD, and a valid date in the past.
	Day *openapi_types.Date `form:"day,omitempty" json:"day,omitempty"`
}

// RemoveTrusteesJSONBody defines parameters for RemoveTrustees.
type RemoveTrusteesJSONBody = []struct {
	// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
	Id string `json:"id"`

	// RoleId The ID of the role to be assigned or currently assigned to the trustee.
	RoleId int `json:"roleId"`

	// Type The type of trustee being added. This can be a user, group, or email domain group.
	Type RemoveTrusteesJSONBodyType `json:"type"`
}

// RemoveTrusteesJSONBodyType defines parameters for RemoveTrustees.
type RemoveTrusteesJSONBodyType string

// UpdateTrusteesJSONBody defines parameters for UpdateTrustees.
type UpdateTrusteesJSONBody = []struct {
	// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
	Id string `json:"id"`

	// OldRoleId The ID of the role to be changed for the trustee. This is used to identify the current role before updating it.
	OldRoleId int `json:"oldRoleId"`

	// RoleId The ID of the role to be assigned or currently assigned to the trustee.
	RoleId int `json:"roleId"`

	// Type The type of trustee being added. This can be a user, group, or email domain group.
	Type UpdateTrusteesJSONBodyType `json:"type"`
}

// UpdateTrusteesJSONBodyType defines parameters for UpdateTrustees.
type UpdateTrusteesJSONBodyType string

// AddTrusteesJSONBody defines parameters for AddTrustees.
type AddTrusteesJSONBody = []struct {
	// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
	Id string `json:"id"`

	// RoleId The ID of the role to be assigned or currently assigned to the trustee.
	RoleId int `json:"roleId"`

	// Type The type of trustee being added. This can be a user, group, or email domain group.
	Type AddTrusteesJSONBodyType `json:"type"`
}

// AddTrusteesJSONBodyType defines parameters for AddTrustees.
type AddTrusteesJSONBodyType string

// CreateAppJSONBody defines parameters for CreateApp.
type CreateAppJSONBody struct {
	// AssignToken Set to true if you would like to assign the app to the user token you used to create the application. The default is false.
	AssignToken *bool `json:"assignToken,omitempty"`

	// Description The description for the app. If this property is left out, the app description will be blank.
	Description *string `json:"description,omitempty"`

	// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
	Name string `json:"name"`

	// SecurityProperties Application security properties.
	SecurityProperties *struct {
		// AllowClone Allow users who are not administrators to copy
		AllowClone *bool `json:"allowClone,omitempty"`

		// AllowExport Allow users who are not administrators to export data
		AllowExport *bool `json:"allowExport,omitempty"`

		// EnableAppTokens Require Application Tokens
		EnableAppTokens *bool `json:"enableAppTokens,omitempty"`

		// HideFromPublic Hide from public application searches
		HideFromPublic *bool `json:"hideFromPublic,omitempty"`

		// MustBeRealmApproved Only "approved" users may access this application
		MustBeRealmApproved *bool `json:"mustBeRealmApproved,omitempty"`

		// UseIPFilter Only users logging in from "approved" IP addresses may access this application
		UseIPFilter *bool `json:"useIPFilter,omitempty"`
	} `json:"securityProperties,omitempty"`

	// Variables The app variables. A maximum of 10 variables can be inserted at a time. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
	Variables *[]struct {
		// Name The name for the variable.
		Name string `json:"name"`

		// Value The value for the variable.
		Value string `json:"value"`
	} `json:"variables,omitempty"`
}

// DeleteAppJSONBody defines parameters for DeleteApp.
type DeleteAppJSONBody struct {
	// Name To confirm application deletion we ask for application name.
	Name string `json:"name"`
}

// UpdateAppJSONBody defines parameters for UpdateApp.
type UpdateAppJSONBody struct {
	// Description The description for the app.
	Description *string `json:"description,omitempty"`

	// Name The name for the app.
	Name *string `json:"name,omitempty"`

	// SecurityProperties Security properties of the application
	SecurityProperties *struct {
		// AllowClone Allow users who are not administrators to copy
		AllowClone *bool `json:"allowClone,omitempty"`

		// AllowExport Allow users who are not administrators to export data
		AllowExport *bool `json:"allowExport,omitempty"`

		// EnableAppTokens Require Application Tokens
		EnableAppTokens *bool `json:"enableAppTokens,omitempty"`

		// HideFromPublic Hide from public application searches
		HideFromPublic *bool `json:"hideFromPublic,omitempty"`

		// MustBeRealmApproved Only "approved" users may access this application
		MustBeRealmApproved *bool `json:"mustBeRealmApproved,omitempty"`

		// UseIPFilter Only users logging in from "approved" IP addresses may access this application
		UseIPFilter *bool `json:"useIPFilter,omitempty"`
	} `json:"securityProperties,omitempty"`

	// Variables The app variables. A maximum of 10 variables can be updated at a time. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
	Variables *[]struct {
		// Name The name for the variable.
		Name string `json:"name"`

		// Value The value for the variable.
		Value string `json:"value"`
	} `json:"variables,omitempty"`
}

// CopyAppJSONBody defines parameters for CopyApp.
type CopyAppJSONBody struct {
	// Description The description of the newly copied app
	Description *string `json:"description,omitempty"`

	// Name The name of the newly copied app
	Name string `json:"name"`

	// Properties The configuration properties for performing the app copy
	Properties *struct {
		// AssignUserToken Whether to add the user token used to make this request to the new app
		AssignUserToken *bool `json:"assignUserToken,omitempty"`

		// ExcludeFiles If keepData is true, whether to copy the file attachments as well. If keepData is false, this property is ignored
		ExcludeFiles *bool `json:"excludeFiles,omitempty"`

		// KeepData Whether to copy the app's data along with the schema
		KeepData *bool `json:"keepData,omitempty"`

		// UsersAndRoles If true, users will be copied along with their assigned roles. If false, users and roles will be copied but roles will not be assigned
		UsersAndRoles *bool `json:"usersAndRoles,omitempty"`
	} `json:"properties,omitempty"`
}

// AuditJSONBody defines parameters for Audit.
type AuditJSONBody struct {
	// Date The date for which audit logs need to be fetched. This must be date-time only, as YYYY-MM-DD, and a valid date in the past.
	Date *openapi_types.Date `json:"date,omitempty"`

	// NextToken Token specifying start of page. For first page don't supply this.
	NextToken *string `json:"nextToken,omitempty"`

	// NumRows Number of logs to return per page, default is 10000, minimum is 1000, max is 50000.
	NumRows *int `json:"numRows,omitempty"`

	// QueryId The query id of an audit log request. This id is needed to fetch subsequent paged results of a single query.
	QueryId *string `json:"queryId,omitempty"`

	// Topics An array that may contain up to 20 [topics](https://resources.quickbase.com/nav/app/budurkasx/action/showpage/2b2941e4-f34d-4d41-9b0e-db790d20e9ab?pageIdV2=quickbase.com-DashboardGroup-15760d74-2243-4ce9-9495-7cc8790f12e7) to filter by. If empty, all topics are returned.
	Topics *[]string `json:"topics,omitempty"`
}

// ExchangeSsoTokenJSONBody defines parameters for ExchangeSsoToken.
type ExchangeSsoTokenJSONBody struct {
	// GrantType The value `urn:ietf:params:oauth:grant-type:token-exchange` indicates that a token exchange is being performed.
	GrantType ExchangeSsoTokenJSONBodyGrantType `json:"grant_type"`

	// RequestedTokenType An identifier for the type of the requested security token. For the RESTful API, use `urn:quickbase:params:oauth:token-type:temp_token`. For the XML or SCIM APIs use `urn:quickbase:params:oauth:token-type:temp_ticket`.
	RequestedTokenType ExchangeSsoTokenJSONBodyRequestedTokenType `json:"requested_token_type"`

	// SubjectToken A security token that represents the identity of the party on behalf of whom the request is being made. For SAML 2.0, the value should be a base64url-encoded SAML 2.0 assertion.
	SubjectToken string `json:"subject_token"`

	// SubjectTokenType An identifier that indicates the type of the security token in the `subject_token` parameter.
	SubjectTokenType ExchangeSsoTokenJSONBodySubjectTokenType `json:"subject_token_type"`
}

// ExchangeSsoTokenJSONBodyGrantType defines parameters for ExchangeSsoToken.
type ExchangeSsoTokenJSONBodyGrantType string

// ExchangeSsoTokenJSONBodyRequestedTokenType defines parameters for ExchangeSsoToken.
type ExchangeSsoTokenJSONBodyRequestedTokenType string

// ExchangeSsoTokenJSONBodySubjectTokenType defines parameters for ExchangeSsoToken.
type ExchangeSsoTokenJSONBodySubjectTokenType string

// GetTempTokenDBIDParams defines parameters for GetTempTokenDBID.
type GetTempTokenDBIDParams struct {
	// QBAppToken Your Quickbase app token
	QBAppToken *string `json:"QB-App-Token,omitempty"`
}

// GenerateDocumentParams defines parameters for GenerateDocument.
type GenerateDocumentParams struct {
	// TableId The unique identifier of the table.
	TableId string `form:"tableId" json:"tableId"`

	// RecordId The ID of the record
	RecordId *float32 `form:"recordId,omitempty" json:"recordId,omitempty"`

	// Filename File name for the downloaded file
	Filename string `form:"filename" json:"filename"`

	// Format The format of the file that is returned. Default is "pdf".
	Format *GenerateDocumentParamsFormat `form:"format,omitempty" json:"format,omitempty"`

	// Margin Margin formatted as top right bottom left, separated by spaces. Add to override the value set in the template builder.
	Margin *string `form:"margin,omitempty" json:"margin,omitempty"`

	// Unit Unit of measurement for the margin. Default is "in". Add to override the value set in the template builder.
	Unit *GenerateDocumentParamsUnit `form:"unit,omitempty" json:"unit,omitempty"`

	// PageSize Page size. Default is "A4". Add to override the value set in the template builder.
	PageSize *GenerateDocumentParamsPageSize `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Orientation Page orientation. Default is "portrait". Add to override the value set in the template builder.
	Orientation *GenerateDocumentParamsOrientation `form:"orientation,omitempty" json:"orientation,omitempty"`

	// Realm Your Quickbase domain, for example demo.quickbase.com
	Realm *string `form:"realm,omitempty" json:"realm,omitempty"`

	// Accept The content-type of the response. application/json will return a JSON payload with a base64 encoded file. application/octet-stream will download the file directly.
	Accept *GenerateDocumentParamsAccept `json:"Accept,omitempty"`
}

// GenerateDocumentParamsFormat defines parameters for GenerateDocument.
type GenerateDocumentParamsFormat string

// GenerateDocumentParamsUnit defines parameters for GenerateDocument.
type GenerateDocumentParamsUnit string

// GenerateDocumentParamsPageSize defines parameters for GenerateDocument.
type GenerateDocumentParamsPageSize string

// GenerateDocumentParamsOrientation defines parameters for GenerateDocument.
type GenerateDocumentParamsOrientation string

// GenerateDocumentParamsAccept defines parameters for GenerateDocument.
type GenerateDocumentParamsAccept string

// DeleteFieldsJSONBody defines parameters for DeleteFields.
type DeleteFieldsJSONBody struct {
	// FieldIds List of field IDs to be deleted.
	FieldIds             []int                  `json:"fieldIds"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// DeleteFieldsParams defines parameters for DeleteFields.
type DeleteFieldsParams struct {
	// TableId The unique identifier of the table.
	TableId string `form:"tableId" json:"tableId"`
}

// GetFieldsParams defines parameters for GetFields.
type GetFieldsParams struct {
	// TableId The unique identifier (dbid) of the table.
	TableId string `form:"tableId" json:"tableId"`

	// IncludeFieldPerms Set to 'true' if you'd like to get back the custom permissions for the field(s).
	IncludeFieldPerms *bool `form:"includeFieldPerms,omitempty" json:"includeFieldPerms,omitempty"`
}

// CreateFieldJSONBody defines parameters for CreateField.
type CreateFieldJSONBody struct {
	// AddToForms Whether the field you are adding should appear on forms. Defaults to false.
	AddToForms *bool `json:"addToForms,omitempty"`

	// AppearsByDefault Indicates if the field is marked as a default in reports. Defaults to true.
	AppearsByDefault *bool `json:"appearsByDefault,omitempty"`

	// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs. You can only set this property to "true" if the app has audit logs enabled. See Enable data change logs under [Quickbase Audit Logs](https://help.quickbase.com/docs/audit-logs). Defaults to false.
	Audited *bool `json:"audited,omitempty"`

	// Bold Indicates if the field is configured to display in bold in the product. Defaults to false.
	Bold *bool `json:"bold,omitempty"`

	// FieldHelp The configured help text shown to users within the product.
	FieldHelp *string `json:"fieldHelp,omitempty"`

	// FieldType The [field types](https://help.quickbase.com/docs/field-types), click on any of the field type links for more info.
	FieldType CreateFieldJSONBodyFieldType `json:"fieldType"`

	// FindEnabled Indicates if the field is marked as searchable. Defaults to true.
	FindEnabled *bool `json:"findEnabled,omitempty"`

	// Label The label (name) of the field.
	Label string `json:"label"`

	// NoWrap Indicates if the field is configured to not wrap when displayed in the product. Defaults to false.
	NoWrap *bool `json:"noWrap,omitempty"`

	// Permissions Field Permissions for different roles.
	Permissions *[]struct {
		// PermissionType The permission given to the role for this field
		PermissionType *string `json:"permissionType,omitempty"`

		// Role The role associated with a given permission for the field
		Role *string `json:"role,omitempty"`

		// RoleId The Id of the given role
		RoleId *int `json:"roleId,omitempty"`
	} `json:"permissions,omitempty"`

	// Properties Specific field properties.
	Properties *struct {
		// Abbreviate Don't show the URL protocol when showing the URL.
		Abbreviate *bool `json:"abbreviate,omitempty"`

		// AllowMentions If someone can @mention users in the rich text field to generate an email notification.
		AllowMentions *bool `json:"allowMentions,omitempty"`

		// AllowNewChoices Indicates if users can add new choices to a selection list.
		AllowNewChoices *bool `json:"allowNewChoices,omitempty"`

		// AppearsAs The link text, if empty, the url will be used as link text.
		AppearsAs *string `json:"appearsAs,omitempty"`

		// AppendOnly Whether this field is append only.
		AppendOnly *bool `json:"appendOnly,omitempty"`

		// AutoSave Whether the link field will auto save.
		AutoSave *bool `json:"autoSave,omitempty"`

		// BlankIsZero Whether a blank value is treated the same as 0 in calculations within the product.
		BlankIsZero *bool `json:"blankIsZero,omitempty"`

		// CarryChoices Whether the field should carry its multiple choice fields when copied.
		CarryChoices *bool `json:"carryChoices,omitempty"`

		// Choices An array of entries that exist for a field that offers choices to the user. Note that these choices refer to the valid values of any records added in the future. You are allowed to remove values from the list of choices even if there are existing records with those values in this field. They will be displayed in red when users look at the data in the browser but there is no other effect. While updating a field with this property, the old choices are removed and replaced by the new choices.
		Choices *[]string `json:"choices,omitempty"`

		// CommaStart The number of digits before commas display in the product, when applicable.
		CommaStart *int `json:"commaStart,omitempty"`

		// Comments The comments entered on the field properties by an administrator.
		Comments *string `json:"comments,omitempty"`

		// CompositeFields An array of the fields that make up a composite field (e.g., address).
		CompositeFields *[]CreateFieldJSONBody_Properties_CompositeFields_Item `json:"compositeFields,omitempty"`

		// CoverText An alternate user friendly text that can be used to display a link in the browser.
		CoverText *string `json:"coverText,omitempty"`

		// CurrencyFormat The currency format used when displaying field values within the product.
		CurrencyFormat *CreateFieldJSONBodyPropertiesCurrencyFormat `json:"currencyFormat,omitempty"`

		// CurrencySymbol The current symbol used when displaying field values within the product.
		CurrencySymbol *string `json:"currencySymbol,omitempty"`

		// DecimalPlaces The number of decimal places displayed in the product for this field.
		DecimalPlaces *int `json:"decimalPlaces,omitempty"`

		// DefaultCountryCode Controls the default country shown on international phone widgets on forms. Country code should be entered in the ISO 3166-1 alpha-2 format.
		DefaultCountryCode *string `json:"defaultCountryCode,omitempty"`

		// DefaultDomain Default email domain.
		DefaultDomain *string `json:"defaultDomain,omitempty"`

		// DefaultKind The user default type.
		DefaultKind *string `json:"defaultKind,omitempty"`

		// DefaultToday Indicates if the field value is defaulted today for new records.
		DefaultToday *bool `json:"defaultToday,omitempty"`

		// DefaultValue The default value configured for a field when a new record is added.
		DefaultValue *string `json:"defaultValue,omitempty"`

		// DefaultValueLuid Default user id value.
		DefaultValueLuid *int `json:"defaultValueLuid,omitempty"`

		// DisplayAsLink Indicates if a field that is part of the relationship should be shown as a hyperlink to the parent record within the product.
		DisplayAsLink *bool `json:"displayAsLink,omitempty"`

		// DisplayCheckboxAsText Indicates whether the checkbox values will be shown as text in reports.
		DisplayCheckboxAsText *bool `json:"displayCheckboxAsText,omitempty"`

		// DisplayDayOfWeek Indicates whether to display the day of the week within the product.
		DisplayDayOfWeek *bool `json:"displayDayOfWeek,omitempty"`

		// DisplayEmail How the email is displayed.
		DisplayEmail *string `json:"displayEmail,omitempty"`

		// DisplayMonth How to display months.
		DisplayMonth *string `json:"displayMonth,omitempty"`

		// DisplayRelative Whether to display time as relative.
		DisplayRelative *bool `json:"displayRelative,omitempty"`

		// DisplayTime Indicates whether to display the time, in addition to the date.
		DisplayTime *bool `json:"displayTime,omitempty"`

		// DisplayTimezone Indicates whether to display the timezone within the product.
		DisplayTimezone *bool `json:"displayTimezone,omitempty"`

		// DisplayUser The configured option for how users display within the product.
		DisplayUser *string `json:"displayUser,omitempty"`

		// DoesAverage Whether this field averages in reports within the product.
		DoesAverage *bool `json:"doesAverage,omitempty"`

		// DoesTotal Whether this field totals in reports within the product.
		DoesTotal *bool `json:"doesTotal,omitempty"`

		// Exact Whether an exact match is required for a report link.
		Exact *bool `json:"exact,omitempty"`

		// Format The format to display time.
		Format *int `json:"format,omitempty"`

		// Formula The formula of the field as configured in Quickbase.
		Formula *string `json:"formula,omitempty"`

		// HasExtension Whether this field has a phone extension.
		HasExtension *bool `json:"hasExtension,omitempty"`

		// Hours24 Indicates whether or not to display time in the 24-hour format within the product.
		Hours24 *bool `json:"hours24,omitempty"`

		// LinkText The configured text value that replaces the URL that users see within the product.
		LinkText *string `json:"linkText,omitempty"`

		// MaxLength The maximum number of characters allowed for entry in Quickbase for this field.
		MaxLength *int `json:"maxLength,omitempty"`

		// MaxVersions The maximum number of versions configured for a file attachment.
		MaxVersions *int32 `json:"maxVersions,omitempty"`

		// NumLines The number of lines shown in Quickbase for this text field.
		NumLines *int `json:"numLines,omitempty"`

		// NumberFormat The format used for displaying numeric values in the product (decimal, separators, digit group).
		NumberFormat *int `json:"numberFormat,omitempty"`

		// OpenTargetIn Indicates which target the URL should open in when a user clicks it within the product.
		OpenTargetIn *CreateFieldJSONBodyPropertiesOpenTargetIn `json:"openTargetIn,omitempty"`

		// ParentFieldId The id of the parent composite field, when applicable.
		ParentFieldId *int `json:"parentFieldId,omitempty"`

		// PostTempToken POSTs a temporary token to the first URL when clicked by a user. [Learn more](https://help.quickbase.com/docs/post-temporary-token-from-a-quickbase-field)
		PostTempToken *bool `json:"postTempToken,omitempty"`

		// SeeVersions Indicates if the user can see other versions, aside from the most recent, of a file attachment within the product.
		SeeVersions *bool `json:"seeVersions,omitempty"`

		// SnapFieldId The id of the field that is used to snapshot values from, when applicable.
		SnapFieldId *int `json:"snapFieldId,omitempty"`

		// SortAlpha Whether to sort alphabetically, default sort is by record ID.
		SortAlpha *bool `json:"sortAlpha,omitempty"`

		// SortAsGiven Indicates if the listed entries sort as entered vs alphabetically.
		SortAsGiven *bool `json:"sortAsGiven,omitempty"`

		// SourceFieldId The id of the source field.
		SourceFieldId *int `json:"sourceFieldId,omitempty"`

		// TargetFieldId The id of the target field.
		TargetFieldId *int `json:"targetFieldId,omitempty"`

		// TargetTableId The id of the target table.
		TargetTableId *string `json:"targetTableId,omitempty"`

		// TargetTableName The field's target table name.
		TargetTableName *string `json:"targetTableName,omitempty"`

		// Units The units label.
		Units *string `json:"units,omitempty"`

		// UseI18NFormat Whether phone numbers should be in E.164 standard international format
		UseI18NFormat *bool `json:"useI18NFormat,omitempty"`

		// UseNewWindow Indicates if the file should open a new window when a user clicks it within the product.
		UseNewWindow *bool `json:"useNewWindow,omitempty"`

		// VersionMode Version modes for files. Keep all versions vs keep last version.
		VersionMode *CreateFieldJSONBodyPropertiesVersionMode `json:"versionMode,omitempty"`

		// Width The field's html input width in the product.
		Width *int `json:"width,omitempty"`
	} `json:"properties,omitempty"`
}

// CreateFieldParams defines parameters for CreateField.
type CreateFieldParams struct {
	// TableId The unique identifier of the table.
	TableId string `form:"tableId" json:"tableId"`
}

// CreateFieldJSONBodyFieldType defines parameters for CreateField.
type CreateFieldJSONBodyFieldType string

// CreateFieldJSONBodyPropertiesCompositeFields0 defines parameters for CreateField.
type CreateFieldJSONBodyPropertiesCompositeFields0 = int

// CreateFieldJSONBodyPropertiesCompositeFields1 defines parameters for CreateField.
type CreateFieldJSONBodyPropertiesCompositeFields1 = map[string]interface{}

// CreateFieldJSONBody_Properties_CompositeFields_Item defines parameters for CreateField.
type CreateFieldJSONBody_Properties_CompositeFields_Item struct {
	union json.RawMessage
}

// CreateFieldJSONBodyPropertiesCurrencyFormat defines parameters for CreateField.
type CreateFieldJSONBodyPropertiesCurrencyFormat string

// CreateFieldJSONBodyPropertiesOpenTargetIn defines parameters for CreateField.
type CreateFieldJSONBodyPropertiesOpenTargetIn string

// CreateFieldJSONBodyPropertiesVersionMode defines parameters for CreateField.
type CreateFieldJSONBodyPropertiesVersionMode string

// GetFieldsUsageParams defines parameters for GetFieldsUsage.
type GetFieldsUsageParams struct {
	// TableId The unique identifier (dbid) of the table.
	TableId string `form:"tableId" json:"tableId"`

	// Skip The number of fields to skip from the list.
	Skip *int `form:"skip,omitempty" json:"skip,omitempty"`

	// Top The maximum number of fields to return.
	Top *int `form:"top,omitempty" json:"top,omitempty"`
}

// GetFieldUsageParams defines parameters for GetFieldUsage.
type GetFieldUsageParams struct {
	// TableId The unique identifier (dbid) of the table.
	TableId string `form:"tableId" json:"tableId"`
}

// GetFieldParams defines parameters for GetField.
type GetFieldParams struct {
	// TableId The unique identifier (dbid) of the table.
	TableId string `form:"tableId" json:"tableId"`

	// IncludeFieldPerms Set to 'true' if you'd like to get back the custom permissions for the field(s).
	IncludeFieldPerms *bool `form:"includeFieldPerms,omitempty" json:"includeFieldPerms,omitempty"`
}

// UpdateFieldJSONBody defines parameters for UpdateField.
type UpdateFieldJSONBody struct {
	// AddToForms Whether the field you are adding should appear on forms.
	AddToForms *bool `json:"addToForms,omitempty"`

	// AppearsByDefault Indicates if the field is marked as a default in reports.
	AppearsByDefault *bool `json:"appearsByDefault,omitempty"`

	// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs. You can only set this property to "true" if the app has audit logs enabled. See Enable data change logs under [Quickbase Audit Logs](https://help.quickbase.com/user-assistance/audit_logs.html).
	Audited *bool `json:"audited,omitempty"`

	// Bold Indicates if the field is configured to display in bold in the product.
	Bold *bool `json:"bold,omitempty"`

	// FieldHelp The configured help text shown to users within the product.
	FieldHelp *string `json:"fieldHelp,omitempty"`

	// FindEnabled Indicates if the field is marked as searchable.
	FindEnabled *bool `json:"findEnabled,omitempty"`

	// Label The label (name) of the field.
	Label *string `json:"label,omitempty"`

	// NoWrap Indicates if the field is configured to not wrap when displayed in the product.
	NoWrap *bool `json:"noWrap,omitempty"`

	// Permissions Field Permissions for different roles.
	Permissions *[]struct {
		// PermissionType The permission given to the role for this field
		PermissionType *string `json:"permissionType,omitempty"`

		// Role The role associated with a given permission for the field
		Role *string `json:"role,omitempty"`

		// RoleId The Id of the given role
		RoleId *int `json:"roleId,omitempty"`
	} `json:"permissions,omitempty"`

	// Properties Specific field properties.
	Properties *struct {
		// Abbreviate Don't show the URL protocol when showing the URL.
		Abbreviate *bool `json:"abbreviate,omitempty"`

		// AllowMentions If someone can @mention users in the rich text field to generate an email notification.
		AllowMentions *bool `json:"allowMentions,omitempty"`

		// AllowNewChoices Indicates if users can add new choices to a selection list.
		AllowNewChoices *bool `json:"allowNewChoices,omitempty"`

		// AppearsAs The link text, if empty, the url will be used as link text.
		AppearsAs *string `json:"appearsAs,omitempty"`

		// AppendOnly Whether this field is append only.
		AppendOnly *bool `json:"appendOnly,omitempty"`

		// AutoSave Whether the link field will auto save.
		AutoSave *bool `json:"autoSave,omitempty"`

		// BlankIsZero Whether a blank value is treated the same as 0 in calculations within the product.
		BlankIsZero *bool `json:"blankIsZero,omitempty"`

		// CarryChoices Whether the field should carry its multiple choice fields when copied.
		CarryChoices *bool `json:"carryChoices,omitempty"`

		// Choices An array of entries that exist for a field that offers choices to the user. Note that these choices refer to the valid values of any records added in the future. You are allowed to remove values from the list of choices even if there are existing records with those values in this field. They will be displayed in red when users look at the data in the browser but there is no other effect. While updating a field with this property, the old choices are removed and replaced by the new choices.
		Choices *[]string `json:"choices,omitempty"`

		// CommaStart The number of digits before commas display in the product, when applicable.
		CommaStart *int `json:"commaStart,omitempty"`

		// Comments The comments entered on the field properties by an administrator.
		Comments *string `json:"comments,omitempty"`

		// CompositeFields An array of the fields that make up a composite field (e.g., address).
		CompositeFields *[]UpdateFieldJSONBody_Properties_CompositeFields_Item `json:"compositeFields,omitempty"`

		// CoverText An alternate user friendly text that can be used to display a link in the browser.
		CoverText *string `json:"coverText,omitempty"`

		// CurrencyFormat The currency format used when displaying field values within the product.
		CurrencyFormat *UpdateFieldJSONBodyPropertiesCurrencyFormat `json:"currencyFormat,omitempty"`

		// CurrencySymbol The current symbol used when displaying field values within the product.
		CurrencySymbol *string `json:"currencySymbol,omitempty"`

		// DecimalPlaces The number of decimal places displayed in the product for this field.
		DecimalPlaces *int `json:"decimalPlaces,omitempty"`

		// DefaultCountryCode Controls the default country shown on international phone widgets on forms. Country code should be entered in the ISO 3166-1 alpha-2 format.
		DefaultCountryCode *string `json:"defaultCountryCode,omitempty"`

		// DefaultDomain Default email domain.
		DefaultDomain *string `json:"defaultDomain,omitempty"`

		// DefaultKind The user default type.
		DefaultKind *string `json:"defaultKind,omitempty"`

		// DefaultToday Indicates if the field value is defaulted today for new records.
		DefaultToday *bool `json:"defaultToday,omitempty"`

		// DefaultValue The default value configured for a field when a new record is added.
		DefaultValue *string `json:"defaultValue,omitempty"`

		// DefaultValueLuid Default user id value.
		DefaultValueLuid *int `json:"defaultValueLuid,omitempty"`

		// DisplayAsLink Indicates if a field that is part of the relationship should be shown as a hyperlink to the parent record within the product.
		DisplayAsLink *bool `json:"displayAsLink,omitempty"`

		// DisplayCheckboxAsText Indicates whether the checkbox values will be shown as text in reports.
		DisplayCheckboxAsText *bool `json:"displayCheckboxAsText,omitempty"`

		// DisplayDayOfWeek Indicates whether to display the day of the week within the product.
		DisplayDayOfWeek *bool `json:"displayDayOfWeek,omitempty"`

		// DisplayEmail How the email is displayed.
		DisplayEmail *string `json:"displayEmail,omitempty"`

		// DisplayMonth How to display months.
		DisplayMonth *string `json:"displayMonth,omitempty"`

		// DisplayRelative Whether to display time as relative.
		DisplayRelative *bool `json:"displayRelative,omitempty"`

		// DisplayTime Indicates whether to display the time, in addition to the date.
		DisplayTime *bool `json:"displayTime,omitempty"`

		// DisplayTimezone Indicates whether to display the timezone within the product.
		DisplayTimezone *bool `json:"displayTimezone,omitempty"`

		// DisplayUser The configured option for how users display within the product.
		DisplayUser *string `json:"displayUser,omitempty"`

		// DoesAverage Whether this field averages in reports within the product.
		DoesAverage *bool `json:"doesAverage,omitempty"`

		// DoesTotal Whether this field totals in reports within the product.
		DoesTotal *bool `json:"doesTotal,omitempty"`

		// Exact Whether an exact match is required for a report link.
		Exact *bool `json:"exact,omitempty"`

		// Format The format to display time.
		Format *int `json:"format,omitempty"`

		// Formula The formula of the field as configured in Quickbase.
		Formula *string `json:"formula,omitempty"`

		// HasExtension Whether this field has a phone extension.
		HasExtension *bool `json:"hasExtension,omitempty"`

		// Hours24 Indicates whether or not to display time in the 24-hour format within the product.
		Hours24 *bool `json:"hours24,omitempty"`

		// LinkText The configured text value that replaces the URL that users see within the product.
		LinkText *string `json:"linkText,omitempty"`

		// LookupReferenceFieldId The id of the field that is the reference in the relationship for this lookup.
		LookupReferenceFieldId *int `json:"lookupReferenceFieldId,omitempty"`

		// LookupTargetFieldId The id of the field that is the target on the parent table for this lookup.
		LookupTargetFieldId *int `json:"lookupTargetFieldId,omitempty"`

		// MaxLength The maximum number of characters allowed for entry in Quickbase for this field.
		MaxLength *int `json:"maxLength,omitempty"`

		// MaxVersions The maximum number of versions configured for a file attachment.
		MaxVersions *int32 `json:"maxVersions,omitempty"`

		// NumLines The number of lines shown in Quickbase for this text field.
		NumLines *int `json:"numLines,omitempty"`

		// NumberFormat The format used for displaying numeric values in the product (decimal, separators, digit group).
		NumberFormat *int `json:"numberFormat,omitempty"`

		// OpenTargetIn Indicates which target the URL should open in when a user clicks it within the product.
		OpenTargetIn *UpdateFieldJSONBodyPropertiesOpenTargetIn `json:"openTargetIn,omitempty"`

		// ParentFieldId The id of the parent composite field, when applicable.
		ParentFieldId *int `json:"parentFieldId,omitempty"`

		// PostTempToken POSTs a temporary token to the first URL when clicked by a user. [Learn more](https://help.quickbase.com/docs/post-temporary-token-from-a-quickbase-field)
		PostTempToken *bool `json:"postTempToken,omitempty"`

		// SeeVersions Indicates if the user can see other versions, aside from the most recent, of a file attachment within the product.
		SeeVersions *bool `json:"seeVersions,omitempty"`

		// SnapFieldId The id of the field that is used to snapshot values from, when applicable.
		SnapFieldId *int `json:"snapFieldId,omitempty"`

		// SortAlpha Whether to sort alphabetically, default sort is by record ID.
		SortAlpha *bool `json:"sortAlpha,omitempty"`

		// SortAsGiven Indicates if the listed entries sort as entered vs alphabetically.
		SortAsGiven *bool `json:"sortAsGiven,omitempty"`

		// SourceFieldId The id of the source field.
		SourceFieldId *int `json:"sourceFieldId,omitempty"`

		// SummaryFunction The accumulation type for the summary field.
		SummaryFunction *UpdateFieldJSONBodyPropertiesSummaryFunction `json:"summaryFunction,omitempty"`

		// SummaryQuery The summary query.
		SummaryQuery *string `json:"summaryQuery,omitempty"`

		// SummaryReferenceFieldId The id of the field that is the reference in the relationship for this summary.
		SummaryReferenceFieldId *int `json:"summaryReferenceFieldId,omitempty"`

		// SummaryTableId The table the summary field references fields from.
		SummaryTableId *string `json:"summaryTableId,omitempty"`

		// SummaryTargetFieldId The id of the field that is used to aggregate values from the child, when applicable. This displays 0 if the summary function doesn't require a field selection (like count).
		SummaryTargetFieldId *int `json:"summaryTargetFieldId,omitempty"`

		// TargetFieldId The id of the target field.
		TargetFieldId *int `json:"targetFieldId,omitempty"`

		// TargetTableId The id of the target table.
		TargetTableId *string `json:"targetTableId,omitempty"`

		// TargetTableName The field's target table name.
		TargetTableName *string `json:"targetTableName,omitempty"`

		// Units The units label.
		Units *string `json:"units,omitempty"`

		// UseI18NFormat Whether phone numbers should be in E.164 standard international format
		UseI18NFormat *bool `json:"useI18NFormat,omitempty"`

		// UseNewWindow Indicates if the file should open a new window when a user clicks it within the product.
		UseNewWindow *bool `json:"useNewWindow,omitempty"`

		// VersionMode Version modes for files. Keep all versions vs keep last version.
		VersionMode *UpdateFieldJSONBodyPropertiesVersionMode `json:"versionMode,omitempty"`

		// Width The field's html input width in the product.
		Width *int `json:"width,omitempty"`
	} `json:"properties,omitempty"`

	// Required Indicates if the field is required (i.e. if every record must have a non-null value in this field). If you attempt to change a field from not-required to required, and the table currently contains records that have null values in that field, you will get an error indicating that there are null values of the field. In this case you need to find and update those records with null values of the field before changing the field to required.
	Required *bool `json:"required,omitempty"`

	// Unique Indicates if every record in the table must contain a unique value of this field. If you attempt to change a field from not-unique to unique, and the table currently contains records with the same value of this field, you will get an error. In this case you need to find and update those records with duplicate values of the field before changing the field to unique.
	Unique *bool `json:"unique,omitempty"`
}

// UpdateFieldParams defines parameters for UpdateField.
type UpdateFieldParams struct {
	// TableId The unique identifier of the table.
	TableId string `form:"tableId" json:"tableId"`
}

// UpdateFieldJSONBodyPropertiesCompositeFields0 defines parameters for UpdateField.
type UpdateFieldJSONBodyPropertiesCompositeFields0 = int

// UpdateFieldJSONBodyPropertiesCompositeFields1 defines parameters for UpdateField.
type UpdateFieldJSONBodyPropertiesCompositeFields1 = map[string]interface{}

// UpdateFieldJSONBody_Properties_CompositeFields_Item defines parameters for UpdateField.
type UpdateFieldJSONBody_Properties_CompositeFields_Item struct {
	union json.RawMessage
}

// UpdateFieldJSONBodyPropertiesCurrencyFormat defines parameters for UpdateField.
type UpdateFieldJSONBodyPropertiesCurrencyFormat string

// UpdateFieldJSONBodyPropertiesOpenTargetIn defines parameters for UpdateField.
type UpdateFieldJSONBodyPropertiesOpenTargetIn string

// UpdateFieldJSONBodyPropertiesSummaryFunction defines parameters for UpdateField.
type UpdateFieldJSONBodyPropertiesSummaryFunction string

// UpdateFieldJSONBodyPropertiesVersionMode defines parameters for UpdateField.
type UpdateFieldJSONBodyPropertiesVersionMode string

// RunFormulaJSONBody defines parameters for RunFormula.
type RunFormulaJSONBody struct {
	// Formula The formula to run. This must be a valid Quickbase formula.
	Formula string `json:"formula"`

	// From The unique identifier (dbid) of the table.
	From string `json:"from"`

	// Rid The record ID to run the formula against. Only necessary for formulas that are run in the context of a record. For example, the formula User() does not need a record ID.
	Rid *int `json:"rid,omitempty"`
}

// RemoveManagersFromGroupJSONBody defines parameters for RemoveManagersFromGroup.
type RemoveManagersFromGroupJSONBody = []string

// AddManagersToGroupJSONBody defines parameters for AddManagersToGroup.
type AddManagersToGroupJSONBody = []string

// RemoveMembersFromGroupJSONBody defines parameters for RemoveMembersFromGroup.
type RemoveMembersFromGroupJSONBody = []string

// AddMembersToGroupJSONBody defines parameters for AddMembersToGroup.
type AddMembersToGroupJSONBody = []string

// RemoveSubgroupsFromGroupJSONBody defines parameters for RemoveSubgroupsFromGroup.
type RemoveSubgroupsFromGroupJSONBody = []string

// AddSubgroupsToGroupJSONBody defines parameters for AddSubgroupsToGroup.
type AddSubgroupsToGroupJSONBody = []string

// DeleteRecordsJSONBody defines parameters for DeleteRecords.
type DeleteRecordsJSONBody struct {
	// From The unique identifier of the table.
	From string `json:"from"`

	// Where The filter to delete records. To delete all records specify a filter that will include all records, for example {3.GT.0} where 3 is the ID of the Record ID field. Or supply a JSON array of Record IDs.
	Where                DeleteRecordsJSONBody_Where `json:"where"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// DeleteRecordsJSONBodyWhere0 defines parameters for DeleteRecords.
type DeleteRecordsJSONBodyWhere0 = string

// DeleteRecordsJSONBodyWhere1 defines parameters for DeleteRecords.
type DeleteRecordsJSONBodyWhere1 = []int

// DeleteRecordsJSONBody_Where defines parameters for DeleteRecords.
type DeleteRecordsJSONBody_Where struct {
	union json.RawMessage
}

// UpsertJSONBody defines parameters for Upsert.
type UpsertJSONBody struct {
	// Data Record data array, where each record contains key-value mappings of fields to be defined/updated and their values.
	Data *[]QuickbaseRecord `json:"data,omitempty"`

	// FieldsToReturn Specify an array of field IDs that will return data for any updates or added record. Record ID (FID 3) is always returned if any field ID is requested.
	FieldsToReturn *[]int `json:"fieldsToReturn,omitempty"`

	// MergeFieldId The merge field id.
	MergeFieldId *int `json:"mergeFieldId,omitempty"`

	// To The table identifier.
	To                   string                 `json:"to"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RecordsModifiedSinceJSONBody defines parameters for RecordsModifiedSince.
type RecordsModifiedSinceJSONBody struct {
	// After A timestamp, formatted in ISO-8601 UTC, representing the date and time to search.
	After time.Time `json:"after"`

	// FieldList List of field IDs. Each field is crawled across the entire record dependency graph to find its source record's date modified. If one is not provided, only the current table will be referenced.
	FieldList *[]int `json:"fieldList,omitempty"`

	// From The table identifier.
	From string `json:"from"`

	// IncludeDetails When true, the individual record IDs and timestamps will be returned. If false, only the count of changes will be returned.
	IncludeDetails *bool `json:"includeDetails,omitempty"`
}

// RunQueryJSONBody defines parameters for RunQuery.
type RunQueryJSONBody struct {
	// From The table identifier.
	From string `json:"from"`

	// GroupBy An array that contains the fields to group the records by.
	GroupBy *[]RunQueryJSONBody_GroupBy_Item `json:"groupBy,omitempty"`

	// Options Additional query options.
	Options *RunQueryJSONBody_Options `json:"options,omitempty"`

	// Select An array of field IDs for the fields that should be returned in the response. If empty, the default columns on the table will be returned.
	Select *[]int `json:"select,omitempty"`

	// SortBy An array of field IDs and sort directions. If this attribute is not set or set to false, queries will be unsorted to improve performance.
	SortBy *RunQueryJSONBody_SortBy `json:"sortBy,omitempty"`

	// Where The filter, using the Quickbase query language, which determines the records to return. Or supply a JSON array of Record IDs. If this parameter is omitted, the query will return all records.
	Where                *RunQueryJSONBody_Where `json:"where,omitempty"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// RunQueryJSONBodyGroupByGrouping defines parameters for RunQuery.
type RunQueryJSONBodyGroupByGrouping string

// RunQueryJSONBody_GroupBy_Item defines parameters for RunQuery.
type RunQueryJSONBody_GroupBy_Item struct {
	// FieldId The unique identifier of a field in a table.
	FieldId *int `json:"fieldId,omitempty"`

	// Grouping Group by based on equal values (equal-values)
	Grouping             *RunQueryJSONBodyGroupByGrouping `json:"grouping,omitempty"`
	AdditionalProperties map[string]interface{}           `json:"-"`
}

// RunQueryJSONBody_Options defines parameters for RunQuery.
type RunQueryJSONBody_Options struct {
	// CompareWithAppLocalTime Whether to run the query against a date time field with respect to the application's local time. The query is run with UTC time by default.  This parameter is ignored when querying by ISO8601, which is always in UTC.
	CompareWithAppLocalTime *bool `json:"compareWithAppLocalTime,omitempty"`

	// Skip The number of records to skip.
	Skip *int `json:"skip,omitempty"`

	// Top The maximum number of records to display.
	Top                  *int                   `json:"top,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// RunQueryJSONBodySortBy0 defines parameters for RunQuery.
type RunQueryJSONBodySortBy0 = []SortField

// RunQueryJSONBodySortBy1 defines parameters for RunQuery.
type RunQueryJSONBodySortBy1 bool

// RunQueryJSONBody_SortBy defines parameters for RunQuery.
type RunQueryJSONBody_SortBy struct {
	union json.RawMessage
}

// RunQueryJSONBodyWhere0 defines parameters for RunQuery.
type RunQueryJSONBodyWhere0 = string

// RunQueryJSONBodyWhere1 defines parameters for RunQuery.
type RunQueryJSONBodyWhere1 = []int

// RunQueryJSONBody_Where defines parameters for RunQuery.
type RunQueryJSONBody_Where struct {
	union json.RawMessage
}

// GetTableReportsParams defines parameters for GetTableReports.
type GetTableReportsParams struct {
	// TableId The unique identifier of the table.
	TableId string `form:"tableId" json:"tableId"`
}

// GetReportParams defines parameters for GetReport.
type GetReportParams struct {
	// TableId The unique identifier of table.
	TableId string `form:"tableId" json:"tableId"`
}

// RunReportJSONBody defines parameters for RunReport.
type RunReportJSONBody = interface{}

// RunReportParams defines parameters for RunReport.
type RunReportParams struct {
	// TableId The identifier of the table for the report.
	TableId string `form:"tableId" json:"tableId"`

	// Skip The number of records to skip. You can set this value when paginating through a set of results.
	Skip *int `form:"skip,omitempty" json:"skip,omitempty"`

	// Top The maximum number of records to return. You can override the default Quickbase pagination to get more or fewer results. If your requested value here exceeds the dynamic maximums, we will return a subset of results and the rest can be gathered in subsequent API calls.
	Top *int `form:"top,omitempty" json:"top,omitempty"`
}

// CreateSolutionJSONBody defines parameters for CreateSolution.
type CreateSolutionJSONBody = interface{}

// CreateSolutionParams defines parameters for CreateSolution.
type CreateSolutionParams struct {
	// XQBLErrorsAsSuccess If this header is set to true, the API will return a 207 status code even if errors occur. The response will contain X-QBL-ORIGINAL-STATUS header with the original error code, and the response body will include the error details.
	XQBLErrorsAsSuccess *bool `json:"X-QBL-Errors-As-Success,omitempty"`
}

// CreateSolutionFromRecordParams defines parameters for CreateSolutionFromRecord.
type CreateSolutionFromRecordParams struct {
	// TableId The unique identifier (dbid) of the table.
	TableId string `form:"tableId" json:"tableId"`

	// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
	FieldId int `form:"fieldId" json:"fieldId"`

	// RecordId The unique identifier of the record.
	RecordId int `form:"recordId" json:"recordId"`

	// XQBLErrorsAsSuccess If this header is set to true, the API will return a 207 status code even if errors occur. The response will contain X-QBL-ORIGINAL-STATUS header with the original error code, and the response body will include the error details.
	XQBLErrorsAsSuccess *bool `json:"X-QBL-Errors-As-Success,omitempty"`
}

// ExportSolutionParams defines parameters for ExportSolution.
type ExportSolutionParams struct {
	// QBLVersion The QBL version to be used for the export. If not specified the default would be used.
	QBLVersion *string `json:"QBL-Version,omitempty"`
}

// UpdateSolutionJSONBody defines parameters for UpdateSolution.
type UpdateSolutionJSONBody = interface{}

// UpdateSolutionParams defines parameters for UpdateSolution.
type UpdateSolutionParams struct {
	// XQBLErrorsAsSuccess If this header is set to true, the API will return a 207 status code even if errors occur. The response will contain X-QBL-ORIGINAL-STATUS header with the original error code, and the response body will include the error details.
	XQBLErrorsAsSuccess *bool `json:"X-QBL-Errors-As-Success,omitempty"`
}

// ChangesetSolutionJSONBody defines parameters for ChangesetSolution.
type ChangesetSolutionJSONBody = interface{}

// ChangesetSolutionParams defines parameters for ChangesetSolution.
type ChangesetSolutionParams struct {
	// XQBLErrorsAsSuccess If this header is set to true, the API will return a 207 status code even if errors occur. The response will contain X-QBL-ORIGINAL-STATUS header with the original error code, and the response body will include the error details.
	XQBLErrorsAsSuccess *bool `json:"X-QBL-Errors-As-Success,omitempty"`
}

// ChangesetSolutionFromRecordParams defines parameters for ChangesetSolutionFromRecord.
type ChangesetSolutionFromRecordParams struct {
	// TableId The unique identifier (dbid) of the table.
	TableId string `form:"tableId" json:"tableId"`

	// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
	FieldId int `form:"fieldId" json:"fieldId"`

	// RecordId The unique identifier of the record.
	RecordId int `form:"recordId" json:"recordId"`

	// XQBLErrorsAsSuccess If this header is set to true, the API will return a 207 status code even if errors occur. The response will contain X-QBL-ORIGINAL-STATUS header with the original error code, and the response body will include the error details.
	XQBLErrorsAsSuccess *bool `json:"X-QBL-Errors-As-Success,omitempty"`
}

// UpdateSolutionToRecordParams defines parameters for UpdateSolutionToRecord.
type UpdateSolutionToRecordParams struct {
	// TableId The unique identifier (dbid) of the table.
	TableId string `form:"tableId" json:"tableId"`

	// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
	FieldId int `form:"fieldId" json:"fieldId"`

	// RecordId The unique identifier of the record.
	RecordId int `form:"recordId" json:"recordId"`

	// XQBLErrorsAsSuccess If this header is set to true, the API will return a 207 status code even if errors occur. The response will contain X-QBL-ORIGINAL-STATUS header with the original error code, and the response body will include the error details.
	XQBLErrorsAsSuccess *bool `json:"X-QBL-Errors-As-Success,omitempty"`
}

// GetSolutionPublicParams defines parameters for GetSolutionPublic.
type GetSolutionPublicParams struct {
	// XQBLErrorsAsSuccess If this header is set to true, the API will return a 207 status code even if errors occur. The response will contain X-QBL-Original-Status header with the original error code, and the response body will include the error details.
	XQBLErrorsAsSuccess *bool `json:"X-QBL-Errors-As-Success,omitempty"`
}

// ExportSolutionToRecordParams defines parameters for ExportSolutionToRecord.
type ExportSolutionToRecordParams struct {
	// TableId The unique identifier (dbid) of the table.
	TableId string `form:"tableId" json:"tableId"`

	// FieldId The unique identifier (fid) of the field. It needs to be a file attachment field.
	FieldId int `form:"fieldId" json:"fieldId"`

	// XQBLErrorsAsSuccess If this header is set to true, the API will return a 207 status code even if errors occur. The response will contain X-QBL-ORIGINAL-STATUS header with the original error code, and the response body will include the error details.
	XQBLErrorsAsSuccess *bool `json:"X-QBL-Errors-As-Success,omitempty"`

	// QBLVersion The QBL version to be used for the export. If not specified the default would be used.
	QBLVersion *string `json:"QBL-Version,omitempty"`
}

// GetAppTablesParams defines parameters for GetAppTables.
type GetAppTablesParams struct {
	// AppId The unique identifier of an app
	AppId string `form:"appId" json:"appId"`
}

// CreateTableJSONBody defines parameters for CreateTable.
type CreateTableJSONBody struct {
	// Description The description for the table. If this value is not passed the default value is blank.
	Description *string `json:"description,omitempty"`

	// Name The name for the table.
	Name string `json:"name"`

	// PluralRecordName The plural noun for records in the table. If this value is not passed the default value is 'Records'.
	PluralRecordName *string `json:"pluralRecordName,omitempty"`

	// SingleRecordName The singular noun for records in the table. If this value is not passed the default value is 'Record'.
	SingleRecordName     *string                `json:"singleRecordName,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateTableParams defines parameters for CreateTable.
type CreateTableParams struct {
	// AppId The unique identifier of an app
	AppId string `form:"appId" json:"appId"`
}

// DeleteTableParams defines parameters for DeleteTable.
type DeleteTableParams struct {
	// AppId The unique identifier of an app
	AppId string `form:"appId" json:"appId"`
}

// GetTableParams defines parameters for GetTable.
type GetTableParams struct {
	// AppId The unique identifier of an app
	AppId string `form:"appId" json:"appId"`
}

// UpdateTableJSONBody defines parameters for UpdateTable.
type UpdateTableJSONBody struct {
	// Description The description for the table. If this value is not passed the default value is blank.
	Description *string `json:"description,omitempty"`

	// Name The name for the table.
	Name *string `json:"name,omitempty"`

	// PluralRecordName The plural noun for records in the table. If this value is not passed the default value is 'Records'.
	PluralRecordName *string `json:"pluralRecordName,omitempty"`

	// SingleRecordName The singular noun for records in the table. If this value is not passed the default value is 'Record'.
	SingleRecordName     *string                `json:"singleRecordName,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateTableParams defines parameters for UpdateTable.
type UpdateTableParams struct {
	// AppId The unique identifier of an app
	AppId string `form:"appId" json:"appId"`
}

// CreateRelationshipJSONBody defines parameters for CreateRelationship.
type CreateRelationshipJSONBody struct {
	// ForeignKeyField This property is optional.  If it is not provided, the foreign key field will be created with the label Related <record>', where <record> is the name of a record in the parent table.
	ForeignKeyField *CreateRelationshipJSONBody_ForeignKeyField `json:"foreignKeyField,omitempty"`

	// LookupFieldIds Array of field IDs in the parent table that will become lookup fields in the child table.
	LookupFieldIds *[]int `json:"lookupFieldIds,omitempty"`

	// ParentTableId The parent table id for the relationship.
	ParentTableId string `json:"parentTableId"`

	// SummaryFields Array of summary field objects which will turn into summary fields in the parent table. When you specify the 'COUNT' accumulation type, you have to specify 0 as the summaryFid (or not set it in the request). 'DISTINCT-COUNT' requires that summaryFid be set to an actual fid.
	SummaryFields *[]CreateRelationshipJSONBody_SummaryFields_Item `json:"summaryFields,omitempty"`
}

// CreateRelationshipJSONBody_ForeignKeyField defines parameters for CreateRelationship.
type CreateRelationshipJSONBody_ForeignKeyField struct {
	// Label The label for the foreign key field.
	Label                *string                `json:"label,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateRelationshipJSONBodySummaryFieldsAccumulationType defines parameters for CreateRelationship.
type CreateRelationshipJSONBodySummaryFieldsAccumulationType string

// CreateRelationshipJSONBody_SummaryFields_Item defines parameters for CreateRelationship.
type CreateRelationshipJSONBody_SummaryFields_Item struct {
	// AccumulationType The accumulation type for the summary field.
	AccumulationType CreateRelationshipJSONBodySummaryFieldsAccumulationType `json:"accumulationType"`

	// Label The label for the summary field.
	Label *string `json:"label,omitempty"`

	// SummaryFid The field id to summarize.
	SummaryFid *float32 `json:"summaryFid,omitempty"`

	// Where The filter, using the Quickbase query language, which determines the records to return.
	Where                *string                `json:"where,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateRelationshipJSONBody defines parameters for UpdateRelationship.
type UpdateRelationshipJSONBody struct {
	// LookupFieldIds An array of field IDs on the parent table that will become lookup fields on the child table.
	LookupFieldIds *[]int `json:"lookupFieldIds,omitempty"`

	// SummaryFields An array of objects, each representing a configuration of one field from the child table, that will become summary fields on the parent table. When you specify the 'COUNT' accumulation type, you have to specify 0 as the summaryFid (or not set it in the request). 'DISTINCT-COUNT' requires that summaryFid be set to an actual fid.
	SummaryFields *[]UpdateRelationshipJSONBody_SummaryFields_Item `json:"summaryFields,omitempty"`
}

// UpdateRelationshipJSONBodySummaryFieldsAccumulationType defines parameters for UpdateRelationship.
type UpdateRelationshipJSONBodySummaryFieldsAccumulationType string

// UpdateRelationshipJSONBody_SummaryFields_Item defines parameters for UpdateRelationship.
type UpdateRelationshipJSONBody_SummaryFields_Item struct {
	// AccumulationType The accumulation type for the summary field.
	AccumulationType UpdateRelationshipJSONBodySummaryFieldsAccumulationType `json:"accumulationType"`

	// Label The label for the summary field.
	Label *string `json:"label,omitempty"`

	// SummaryFid The field id to summarize.
	SummaryFid *float32 `json:"summaryFid,omitempty"`

	// Where The filter, using the Quickbase query language, which determines the records to return.
	Where                *string                `json:"where,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GetRelationshipsParams defines parameters for GetRelationships.
type GetRelationshipsParams struct {
	// Skip The number of relationships to skip.
	Skip *int `form:"skip,omitempty" json:"skip,omitempty"`
}

// GetUsersJSONBody defines parameters for GetUsers.
type GetUsersJSONBody struct {
	// AppIds When provided, the returned users will be narrowed down only to the users assigned to the app id's provided in this list. The provided app id's should belong to the same account.
	AppIds *[]string `json:"appIds,omitempty"`

	// Emails When provided, the returned users will be narrowed down only to the users included in this list.
	Emails *[]string `json:"emails,omitempty"`

	// NextPageToken Next page token used to get the next 'page' of results when available. When this field is empty, the first page is returned.
	NextPageToken        *string                `json:"nextPageToken,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// AccountId The account id being used to get users. If no value is specified, the first account associated with the requesting user token is chosen.
	AccountId *float32 `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// DenyUsersJSONBody defines parameters for DenyUsers.
type DenyUsersJSONBody = []string

// DenyUsersParams defines parameters for DenyUsers.
type DenyUsersParams struct {
	// AccountId The account id being used to deny users. If no value is specified, the first account associated with the requesting user token is chosen.
	AccountId *float32 `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// DenyUsersAndGroupsJSONBody defines parameters for DenyUsersAndGroups.
type DenyUsersAndGroupsJSONBody = []string

// DenyUsersAndGroupsParams defines parameters for DenyUsersAndGroups.
type DenyUsersAndGroupsParams struct {
	// AccountId The account id being used to deny users. If no value is specified, the first account associated with the requesting user token is chosen.
	AccountId *float32 `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// UndenyUsersJSONBody defines parameters for UndenyUsers.
type UndenyUsersJSONBody = []string

// UndenyUsersParams defines parameters for UndenyUsers.
type UndenyUsersParams struct {
	// AccountId The account id being used to undeny users. If no value is specified, the first account associated with the requesting user token is chosen.
	AccountId *float32 `form:"accountId,omitempty" json:"accountId,omitempty"`
}

// CloneUserTokenJSONBody defines parameters for CloneUserToken.
type CloneUserTokenJSONBody struct {
	// Description The description for the cloned user token.
	Description *string `json:"description,omitempty"`

	// Name The new name for the cloned user token.
	Name *string `json:"name,omitempty"`
}

// TransferUserTokenJSONBody defines parameters for TransferUserToken.
type TransferUserTokenJSONBody struct {
	// From The id of the user to transfer the user token from
	From *string `json:"from,omitempty"`

	// Id The id of the user token to transfer
	Id *float32 `json:"id,omitempty"`

	// To The id of the user to transfer the user token to
	To *string `json:"to,omitempty"`
}

// PlatformAnalyticEventSummariesJSONRequestBody defines body for PlatformAnalyticEventSummaries for application/json ContentType.
type PlatformAnalyticEventSummariesJSONRequestBody PlatformAnalyticEventSummariesJSONBody

// RemoveTrusteesJSONRequestBody defines body for RemoveTrustees for application/json ContentType.
type RemoveTrusteesJSONRequestBody = RemoveTrusteesJSONBody

// UpdateTrusteesJSONRequestBody defines body for UpdateTrustees for application/json ContentType.
type UpdateTrusteesJSONRequestBody = UpdateTrusteesJSONBody

// AddTrusteesJSONRequestBody defines body for AddTrustees for application/json ContentType.
type AddTrusteesJSONRequestBody = AddTrusteesJSONBody

// CreateAppJSONRequestBody defines body for CreateApp for application/json ContentType.
type CreateAppJSONRequestBody CreateAppJSONBody

// DeleteAppJSONRequestBody defines body for DeleteApp for application/json ContentType.
type DeleteAppJSONRequestBody DeleteAppJSONBody

// UpdateAppJSONRequestBody defines body for UpdateApp for application/json ContentType.
type UpdateAppJSONRequestBody UpdateAppJSONBody

// CopyAppJSONRequestBody defines body for CopyApp for application/json ContentType.
type CopyAppJSONRequestBody CopyAppJSONBody

// AuditJSONRequestBody defines body for Audit for application/json ContentType.
type AuditJSONRequestBody AuditJSONBody

// ExchangeSsoTokenJSONRequestBody defines body for ExchangeSsoToken for application/json ContentType.
type ExchangeSsoTokenJSONRequestBody ExchangeSsoTokenJSONBody

// DeleteFieldsJSONRequestBody defines body for DeleteFields for application/json ContentType.
type DeleteFieldsJSONRequestBody DeleteFieldsJSONBody

// CreateFieldJSONRequestBody defines body for CreateField for application/json ContentType.
type CreateFieldJSONRequestBody CreateFieldJSONBody

// UpdateFieldJSONRequestBody defines body for UpdateField for application/json ContentType.
type UpdateFieldJSONRequestBody UpdateFieldJSONBody

// RunFormulaJSONRequestBody defines body for RunFormula for application/json ContentType.
type RunFormulaJSONRequestBody RunFormulaJSONBody

// RemoveManagersFromGroupJSONRequestBody defines body for RemoveManagersFromGroup for application/json ContentType.
type RemoveManagersFromGroupJSONRequestBody = RemoveManagersFromGroupJSONBody

// AddManagersToGroupJSONRequestBody defines body for AddManagersToGroup for application/json ContentType.
type AddManagersToGroupJSONRequestBody = AddManagersToGroupJSONBody

// RemoveMembersFromGroupJSONRequestBody defines body for RemoveMembersFromGroup for application/json ContentType.
type RemoveMembersFromGroupJSONRequestBody = RemoveMembersFromGroupJSONBody

// AddMembersToGroupJSONRequestBody defines body for AddMembersToGroup for application/json ContentType.
type AddMembersToGroupJSONRequestBody = AddMembersToGroupJSONBody

// RemoveSubgroupsFromGroupJSONRequestBody defines body for RemoveSubgroupsFromGroup for application/json ContentType.
type RemoveSubgroupsFromGroupJSONRequestBody = RemoveSubgroupsFromGroupJSONBody

// AddSubgroupsToGroupJSONRequestBody defines body for AddSubgroupsToGroup for application/json ContentType.
type AddSubgroupsToGroupJSONRequestBody = AddSubgroupsToGroupJSONBody

// DeleteRecordsJSONRequestBody defines body for DeleteRecords for application/json ContentType.
type DeleteRecordsJSONRequestBody DeleteRecordsJSONBody

// UpsertJSONRequestBody defines body for Upsert for application/json ContentType.
type UpsertJSONRequestBody UpsertJSONBody

// RecordsModifiedSinceJSONRequestBody defines body for RecordsModifiedSince for application/json ContentType.
type RecordsModifiedSinceJSONRequestBody RecordsModifiedSinceJSONBody

// RunQueryJSONRequestBody defines body for RunQuery for application/json ContentType.
type RunQueryJSONRequestBody RunQueryJSONBody

// RunReportJSONRequestBody defines body for RunReport for application/json ContentType.
type RunReportJSONRequestBody = RunReportJSONBody

// CreateSolutionJSONRequestBody defines body for CreateSolution for application/json ContentType.
type CreateSolutionJSONRequestBody = CreateSolutionJSONBody

// UpdateSolutionJSONRequestBody defines body for UpdateSolution for application/json ContentType.
type UpdateSolutionJSONRequestBody = UpdateSolutionJSONBody

// ChangesetSolutionJSONRequestBody defines body for ChangesetSolution for application/json ContentType.
type ChangesetSolutionJSONRequestBody = ChangesetSolutionJSONBody

// CreateTableJSONRequestBody defines body for CreateTable for application/json ContentType.
type CreateTableJSONRequestBody CreateTableJSONBody

// UpdateTableJSONRequestBody defines body for UpdateTable for application/json ContentType.
type UpdateTableJSONRequestBody UpdateTableJSONBody

// CreateRelationshipJSONRequestBody defines body for CreateRelationship for application/json ContentType.
type CreateRelationshipJSONRequestBody CreateRelationshipJSONBody

// UpdateRelationshipJSONRequestBody defines body for UpdateRelationship for application/json ContentType.
type UpdateRelationshipJSONRequestBody UpdateRelationshipJSONBody

// GetUsersJSONRequestBody defines body for GetUsers for application/json ContentType.
type GetUsersJSONRequestBody GetUsersJSONBody

// DenyUsersJSONRequestBody defines body for DenyUsers for application/json ContentType.
type DenyUsersJSONRequestBody = DenyUsersJSONBody

// DenyUsersAndGroupsJSONRequestBody defines body for DenyUsersAndGroups for application/json ContentType.
type DenyUsersAndGroupsJSONRequestBody = DenyUsersAndGroupsJSONBody

// UndenyUsersJSONRequestBody defines body for UndenyUsers for application/json ContentType.
type UndenyUsersJSONRequestBody = UndenyUsersJSONBody

// CloneUserTokenJSONRequestBody defines body for CloneUserToken for application/json ContentType.
type CloneUserTokenJSONRequestBody CloneUserTokenJSONBody

// TransferUserTokenJSONRequestBody defines body for TransferUserToken for application/json ContentType.
type TransferUserTokenJSONRequestBody TransferUserTokenJSONBody

// Getter for additional properties for DeleteFieldsJSONBody. Returns the specified
// element and whether it was found
func (a DeleteFieldsJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DeleteFieldsJSONBody
func (a *DeleteFieldsJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DeleteFieldsJSONBody to handle AdditionalProperties
func (a *DeleteFieldsJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["fieldIds"]; found {
		err = json.Unmarshal(raw, &a.FieldIds)
		if err != nil {
			return fmt.Errorf("error reading 'fieldIds': %w", err)
		}
		delete(object, "fieldIds")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DeleteFieldsJSONBody to handle AdditionalProperties
func (a DeleteFieldsJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.FieldIds != nil {
		object["fieldIds"], err = json.Marshal(a.FieldIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fieldIds': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DeleteRecordsJSONBody. Returns the specified
// element and whether it was found
func (a DeleteRecordsJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DeleteRecordsJSONBody
func (a *DeleteRecordsJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DeleteRecordsJSONBody to handle AdditionalProperties
func (a *DeleteRecordsJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["from"]; found {
		err = json.Unmarshal(raw, &a.From)
		if err != nil {
			return fmt.Errorf("error reading 'from': %w", err)
		}
		delete(object, "from")
	}

	if raw, found := object["where"]; found {
		err = json.Unmarshal(raw, &a.Where)
		if err != nil {
			return fmt.Errorf("error reading 'where': %w", err)
		}
		delete(object, "where")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DeleteRecordsJSONBody to handle AdditionalProperties
func (a DeleteRecordsJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["from"], err = json.Marshal(a.From)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'from': %w", err)
	}

	object["where"], err = json.Marshal(a.Where)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'where': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpsertJSONBody. Returns the specified
// element and whether it was found
func (a UpsertJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpsertJSONBody
func (a *UpsertJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpsertJSONBody to handle AdditionalProperties
func (a *UpsertJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["data"]; found {
		err = json.Unmarshal(raw, &a.Data)
		if err != nil {
			return fmt.Errorf("error reading 'data': %w", err)
		}
		delete(object, "data")
	}

	if raw, found := object["fieldsToReturn"]; found {
		err = json.Unmarshal(raw, &a.FieldsToReturn)
		if err != nil {
			return fmt.Errorf("error reading 'fieldsToReturn': %w", err)
		}
		delete(object, "fieldsToReturn")
	}

	if raw, found := object["mergeFieldId"]; found {
		err = json.Unmarshal(raw, &a.MergeFieldId)
		if err != nil {
			return fmt.Errorf("error reading 'mergeFieldId': %w", err)
		}
		delete(object, "mergeFieldId")
	}

	if raw, found := object["to"]; found {
		err = json.Unmarshal(raw, &a.To)
		if err != nil {
			return fmt.Errorf("error reading 'to': %w", err)
		}
		delete(object, "to")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpsertJSONBody to handle AdditionalProperties
func (a UpsertJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Data != nil {
		object["data"], err = json.Marshal(a.Data)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'data': %w", err)
		}
	}

	if a.FieldsToReturn != nil {
		object["fieldsToReturn"], err = json.Marshal(a.FieldsToReturn)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fieldsToReturn': %w", err)
		}
	}

	if a.MergeFieldId != nil {
		object["mergeFieldId"], err = json.Marshal(a.MergeFieldId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mergeFieldId': %w", err)
		}
	}

	object["to"], err = json.Marshal(a.To)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'to': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RunQueryJSONBody. Returns the specified
// element and whether it was found
func (a RunQueryJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RunQueryJSONBody
func (a *RunQueryJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RunQueryJSONBody to handle AdditionalProperties
func (a *RunQueryJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["from"]; found {
		err = json.Unmarshal(raw, &a.From)
		if err != nil {
			return fmt.Errorf("error reading 'from': %w", err)
		}
		delete(object, "from")
	}

	if raw, found := object["groupBy"]; found {
		err = json.Unmarshal(raw, &a.GroupBy)
		if err != nil {
			return fmt.Errorf("error reading 'groupBy': %w", err)
		}
		delete(object, "groupBy")
	}

	if raw, found := object["options"]; found {
		err = json.Unmarshal(raw, &a.Options)
		if err != nil {
			return fmt.Errorf("error reading 'options': %w", err)
		}
		delete(object, "options")
	}

	if raw, found := object["select"]; found {
		err = json.Unmarshal(raw, &a.Select)
		if err != nil {
			return fmt.Errorf("error reading 'select': %w", err)
		}
		delete(object, "select")
	}

	if raw, found := object["sortBy"]; found {
		err = json.Unmarshal(raw, &a.SortBy)
		if err != nil {
			return fmt.Errorf("error reading 'sortBy': %w", err)
		}
		delete(object, "sortBy")
	}

	if raw, found := object["where"]; found {
		err = json.Unmarshal(raw, &a.Where)
		if err != nil {
			return fmt.Errorf("error reading 'where': %w", err)
		}
		delete(object, "where")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RunQueryJSONBody to handle AdditionalProperties
func (a RunQueryJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["from"], err = json.Marshal(a.From)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'from': %w", err)
	}

	if a.GroupBy != nil {
		object["groupBy"], err = json.Marshal(a.GroupBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'groupBy': %w", err)
		}
	}

	if a.Options != nil {
		object["options"], err = json.Marshal(a.Options)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'options': %w", err)
		}
	}

	if a.Select != nil {
		object["select"], err = json.Marshal(a.Select)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'select': %w", err)
		}
	}

	if a.SortBy != nil {
		object["sortBy"], err = json.Marshal(a.SortBy)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sortBy': %w", err)
		}
	}

	if a.Where != nil {
		object["where"], err = json.Marshal(a.Where)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'where': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RunQueryJSONBody_GroupBy_Item. Returns the specified
// element and whether it was found
func (a RunQueryJSONBody_GroupBy_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RunQueryJSONBody_GroupBy_Item
func (a *RunQueryJSONBody_GroupBy_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RunQueryJSONBody_GroupBy_Item to handle AdditionalProperties
func (a *RunQueryJSONBody_GroupBy_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["fieldId"]; found {
		err = json.Unmarshal(raw, &a.FieldId)
		if err != nil {
			return fmt.Errorf("error reading 'fieldId': %w", err)
		}
		delete(object, "fieldId")
	}

	if raw, found := object["grouping"]; found {
		err = json.Unmarshal(raw, &a.Grouping)
		if err != nil {
			return fmt.Errorf("error reading 'grouping': %w", err)
		}
		delete(object, "grouping")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RunQueryJSONBody_GroupBy_Item to handle AdditionalProperties
func (a RunQueryJSONBody_GroupBy_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.FieldId != nil {
		object["fieldId"], err = json.Marshal(a.FieldId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fieldId': %w", err)
		}
	}

	if a.Grouping != nil {
		object["grouping"], err = json.Marshal(a.Grouping)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'grouping': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for RunQueryJSONBody_Options. Returns the specified
// element and whether it was found
func (a RunQueryJSONBody_Options) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for RunQueryJSONBody_Options
func (a *RunQueryJSONBody_Options) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for RunQueryJSONBody_Options to handle AdditionalProperties
func (a *RunQueryJSONBody_Options) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["compareWithAppLocalTime"]; found {
		err = json.Unmarshal(raw, &a.CompareWithAppLocalTime)
		if err != nil {
			return fmt.Errorf("error reading 'compareWithAppLocalTime': %w", err)
		}
		delete(object, "compareWithAppLocalTime")
	}

	if raw, found := object["skip"]; found {
		err = json.Unmarshal(raw, &a.Skip)
		if err != nil {
			return fmt.Errorf("error reading 'skip': %w", err)
		}
		delete(object, "skip")
	}

	if raw, found := object["top"]; found {
		err = json.Unmarshal(raw, &a.Top)
		if err != nil {
			return fmt.Errorf("error reading 'top': %w", err)
		}
		delete(object, "top")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for RunQueryJSONBody_Options to handle AdditionalProperties
func (a RunQueryJSONBody_Options) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.CompareWithAppLocalTime != nil {
		object["compareWithAppLocalTime"], err = json.Marshal(a.CompareWithAppLocalTime)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compareWithAppLocalTime': %w", err)
		}
	}

	if a.Skip != nil {
		object["skip"], err = json.Marshal(a.Skip)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'skip': %w", err)
		}
	}

	if a.Top != nil {
		object["top"], err = json.Marshal(a.Top)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'top': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateTableJSONBody. Returns the specified
// element and whether it was found
func (a CreateTableJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateTableJSONBody
func (a *CreateTableJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateTableJSONBody to handle AdditionalProperties
func (a *CreateTableJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["pluralRecordName"]; found {
		err = json.Unmarshal(raw, &a.PluralRecordName)
		if err != nil {
			return fmt.Errorf("error reading 'pluralRecordName': %w", err)
		}
		delete(object, "pluralRecordName")
	}

	if raw, found := object["singleRecordName"]; found {
		err = json.Unmarshal(raw, &a.SingleRecordName)
		if err != nil {
			return fmt.Errorf("error reading 'singleRecordName': %w", err)
		}
		delete(object, "singleRecordName")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateTableJSONBody to handle AdditionalProperties
func (a CreateTableJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.PluralRecordName != nil {
		object["pluralRecordName"], err = json.Marshal(a.PluralRecordName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pluralRecordName': %w", err)
		}
	}

	if a.SingleRecordName != nil {
		object["singleRecordName"], err = json.Marshal(a.SingleRecordName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'singleRecordName': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateTableJSONBody. Returns the specified
// element and whether it was found
func (a UpdateTableJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateTableJSONBody
func (a *UpdateTableJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateTableJSONBody to handle AdditionalProperties
func (a *UpdateTableJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["pluralRecordName"]; found {
		err = json.Unmarshal(raw, &a.PluralRecordName)
		if err != nil {
			return fmt.Errorf("error reading 'pluralRecordName': %w", err)
		}
		delete(object, "pluralRecordName")
	}

	if raw, found := object["singleRecordName"]; found {
		err = json.Unmarshal(raw, &a.SingleRecordName)
		if err != nil {
			return fmt.Errorf("error reading 'singleRecordName': %w", err)
		}
		delete(object, "singleRecordName")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateTableJSONBody to handle AdditionalProperties
func (a UpdateTableJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.PluralRecordName != nil {
		object["pluralRecordName"], err = json.Marshal(a.PluralRecordName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'pluralRecordName': %w", err)
		}
	}

	if a.SingleRecordName != nil {
		object["singleRecordName"], err = json.Marshal(a.SingleRecordName)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'singleRecordName': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateRelationshipJSONBody_ForeignKeyField. Returns the specified
// element and whether it was found
func (a CreateRelationshipJSONBody_ForeignKeyField) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateRelationshipJSONBody_ForeignKeyField
func (a *CreateRelationshipJSONBody_ForeignKeyField) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateRelationshipJSONBody_ForeignKeyField to handle AdditionalProperties
func (a *CreateRelationshipJSONBody_ForeignKeyField) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateRelationshipJSONBody_ForeignKeyField to handle AdditionalProperties
func (a CreateRelationshipJSONBody_ForeignKeyField) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateRelationshipJSONBody_SummaryFields_Item. Returns the specified
// element and whether it was found
func (a CreateRelationshipJSONBody_SummaryFields_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateRelationshipJSONBody_SummaryFields_Item
func (a *CreateRelationshipJSONBody_SummaryFields_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateRelationshipJSONBody_SummaryFields_Item to handle AdditionalProperties
func (a *CreateRelationshipJSONBody_SummaryFields_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accumulationType"]; found {
		err = json.Unmarshal(raw, &a.AccumulationType)
		if err != nil {
			return fmt.Errorf("error reading 'accumulationType': %w", err)
		}
		delete(object, "accumulationType")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["summaryFid"]; found {
		err = json.Unmarshal(raw, &a.SummaryFid)
		if err != nil {
			return fmt.Errorf("error reading 'summaryFid': %w", err)
		}
		delete(object, "summaryFid")
	}

	if raw, found := object["where"]; found {
		err = json.Unmarshal(raw, &a.Where)
		if err != nil {
			return fmt.Errorf("error reading 'where': %w", err)
		}
		delete(object, "where")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateRelationshipJSONBody_SummaryFields_Item to handle AdditionalProperties
func (a CreateRelationshipJSONBody_SummaryFields_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["accumulationType"], err = json.Marshal(a.AccumulationType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'accumulationType': %w", err)
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.SummaryFid != nil {
		object["summaryFid"], err = json.Marshal(a.SummaryFid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'summaryFid': %w", err)
		}
	}

	if a.Where != nil {
		object["where"], err = json.Marshal(a.Where)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'where': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateRelationshipJSONBody_SummaryFields_Item. Returns the specified
// element and whether it was found
func (a UpdateRelationshipJSONBody_SummaryFields_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateRelationshipJSONBody_SummaryFields_Item
func (a *UpdateRelationshipJSONBody_SummaryFields_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateRelationshipJSONBody_SummaryFields_Item to handle AdditionalProperties
func (a *UpdateRelationshipJSONBody_SummaryFields_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["accumulationType"]; found {
		err = json.Unmarshal(raw, &a.AccumulationType)
		if err != nil {
			return fmt.Errorf("error reading 'accumulationType': %w", err)
		}
		delete(object, "accumulationType")
	}

	if raw, found := object["label"]; found {
		err = json.Unmarshal(raw, &a.Label)
		if err != nil {
			return fmt.Errorf("error reading 'label': %w", err)
		}
		delete(object, "label")
	}

	if raw, found := object["summaryFid"]; found {
		err = json.Unmarshal(raw, &a.SummaryFid)
		if err != nil {
			return fmt.Errorf("error reading 'summaryFid': %w", err)
		}
		delete(object, "summaryFid")
	}

	if raw, found := object["where"]; found {
		err = json.Unmarshal(raw, &a.Where)
		if err != nil {
			return fmt.Errorf("error reading 'where': %w", err)
		}
		delete(object, "where")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateRelationshipJSONBody_SummaryFields_Item to handle AdditionalProperties
func (a UpdateRelationshipJSONBody_SummaryFields_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["accumulationType"], err = json.Marshal(a.AccumulationType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'accumulationType': %w", err)
	}

	if a.Label != nil {
		object["label"], err = json.Marshal(a.Label)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'label': %w", err)
		}
	}

	if a.SummaryFid != nil {
		object["summaryFid"], err = json.Marshal(a.SummaryFid)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'summaryFid': %w", err)
		}
	}

	if a.Where != nil {
		object["where"], err = json.Marshal(a.Where)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'where': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for GetUsersJSONBody. Returns the specified
// element and whether it was found
func (a GetUsersJSONBody) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for GetUsersJSONBody
func (a *GetUsersJSONBody) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for GetUsersJSONBody to handle AdditionalProperties
func (a *GetUsersJSONBody) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["appIds"]; found {
		err = json.Unmarshal(raw, &a.AppIds)
		if err != nil {
			return fmt.Errorf("error reading 'appIds': %w", err)
		}
		delete(object, "appIds")
	}

	if raw, found := object["emails"]; found {
		err = json.Unmarshal(raw, &a.Emails)
		if err != nil {
			return fmt.Errorf("error reading 'emails': %w", err)
		}
		delete(object, "emails")
	}

	if raw, found := object["nextPageToken"]; found {
		err = json.Unmarshal(raw, &a.NextPageToken)
		if err != nil {
			return fmt.Errorf("error reading 'nextPageToken': %w", err)
		}
		delete(object, "nextPageToken")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for GetUsersJSONBody to handle AdditionalProperties
func (a GetUsersJSONBody) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AppIds != nil {
		object["appIds"], err = json.Marshal(a.AppIds)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'appIds': %w", err)
		}
	}

	if a.Emails != nil {
		object["emails"], err = json.Marshal(a.Emails)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'emails': %w", err)
		}
	}

	if a.NextPageToken != nil {
		object["nextPageToken"], err = json.Marshal(a.NextPageToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'nextPageToken': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsFieldValueValue0 returns the union data inside the FieldValue_Value as a FieldValueValue0
func (t FieldValue_Value) AsFieldValueValue0() (FieldValueValue0, error) {
	var body FieldValueValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueValue0 overwrites any union data inside the FieldValue_Value as the provided FieldValueValue0
func (t *FieldValue_Value) FromFieldValueValue0(v FieldValueValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueValue0 performs a merge with any union data inside the FieldValue_Value, using the provided FieldValueValue0
func (t *FieldValue_Value) MergeFieldValueValue0(v FieldValueValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueValue1 returns the union data inside the FieldValue_Value as a FieldValueValue1
func (t FieldValue_Value) AsFieldValueValue1() (FieldValueValue1, error) {
	var body FieldValueValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueValue1 overwrites any union data inside the FieldValue_Value as the provided FieldValueValue1
func (t *FieldValue_Value) FromFieldValueValue1(v FieldValueValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueValue1 performs a merge with any union data inside the FieldValue_Value, using the provided FieldValueValue1
func (t *FieldValue_Value) MergeFieldValueValue1(v FieldValueValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueValue2 returns the union data inside the FieldValue_Value as a FieldValueValue2
func (t FieldValue_Value) AsFieldValueValue2() (FieldValueValue2, error) {
	var body FieldValueValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueValue2 overwrites any union data inside the FieldValue_Value as the provided FieldValueValue2
func (t *FieldValue_Value) FromFieldValueValue2(v FieldValueValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueValue2 performs a merge with any union data inside the FieldValue_Value, using the provided FieldValueValue2
func (t *FieldValue_Value) MergeFieldValueValue2(v FieldValueValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueValue3 returns the union data inside the FieldValue_Value as a FieldValueValue3
func (t FieldValue_Value) AsFieldValueValue3() (FieldValueValue3, error) {
	var body FieldValueValue3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueValue3 overwrites any union data inside the FieldValue_Value as the provided FieldValueValue3
func (t *FieldValue_Value) FromFieldValueValue3(v FieldValueValue3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueValue3 performs a merge with any union data inside the FieldValue_Value, using the provided FieldValueValue3
func (t *FieldValue_Value) MergeFieldValueValue3(v FieldValueValue3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFieldValueValue4 returns the union data inside the FieldValue_Value as a FieldValueValue4
func (t FieldValue_Value) AsFieldValueValue4() (FieldValueValue4, error) {
	var body FieldValueValue4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFieldValueValue4 overwrites any union data inside the FieldValue_Value as the provided FieldValueValue4
func (t *FieldValue_Value) FromFieldValueValue4(v FieldValueValue4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFieldValueValue4 performs a merge with any union data inside the FieldValue_Value, using the provided FieldValueValue4
func (t *FieldValue_Value) MergeFieldValueValue4(v FieldValueValue4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FieldValue_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FieldValue_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PlatformAnalyticEventSummariesWithBody request with any body
	PlatformAnalyticEventSummariesWithBody(ctx context.Context, params *PlatformAnalyticEventSummariesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PlatformAnalyticEventSummaries(ctx context.Context, params *PlatformAnalyticEventSummariesParams, body PlatformAnalyticEventSummariesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PlatformAnalyticReads request
	PlatformAnalyticReads(ctx context.Context, params *PlatformAnalyticReadsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveTrusteesWithBody request with any body
	RemoveTrusteesWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveTrustees(ctx context.Context, appId string, body RemoveTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTrustees request
	GetTrustees(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTrusteesWithBody request with any body
	UpdateTrusteesWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTrustees(ctx context.Context, appId string, body UpdateTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddTrusteesWithBody request with any body
	AddTrusteesWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddTrustees(ctx context.Context, appId string, body AddTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppWithBody request with any body
	CreateAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApp(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppWithBody request with any body
	DeleteAppWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteApp(ctx context.Context, appId string, body DeleteAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApp request
	GetApp(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAppWithBody request with any body
	UpdateAppWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApp(ctx context.Context, appId string, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CopyAppWithBody request with any body
	CopyAppWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CopyApp(ctx context.Context, appId string, body CopyAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppEvents request
	GetAppEvents(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoles request
	GetRoles(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AuditWithBody request with any body
	AuditWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Audit(ctx context.Context, body AuditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExchangeSsoTokenWithBody request with any body
	ExchangeSsoTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExchangeSsoToken(ctx context.Context, body ExchangeSsoTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTempTokenDBID request
	GetTempTokenDBID(ctx context.Context, dbid string, params *GetTempTokenDBIDParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateDocument request
	GenerateDocument(ctx context.Context, templateId float32, params *GenerateDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFieldsWithBody request with any body
	DeleteFieldsWithBody(ctx context.Context, params *DeleteFieldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteFields(ctx context.Context, params *DeleteFieldsParams, body DeleteFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFields request
	GetFields(ctx context.Context, params *GetFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFieldWithBody request with any body
	CreateFieldWithBody(ctx context.Context, params *CreateFieldParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateField(ctx context.Context, params *CreateFieldParams, body CreateFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFieldsUsage request
	GetFieldsUsage(ctx context.Context, params *GetFieldsUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFieldUsage request
	GetFieldUsage(ctx context.Context, fieldId int, params *GetFieldUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetField request
	GetField(ctx context.Context, fieldId int, params *GetFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFieldWithBody request with any body
	UpdateFieldWithBody(ctx context.Context, fieldId int, params *UpdateFieldParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateField(ctx context.Context, fieldId int, params *UpdateFieldParams, body UpdateFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFile request
	DeleteFile(ctx context.Context, tableId string, recordId int, fieldId int, versionNumber int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadFile request
	DownloadFile(ctx context.Context, tableId string, recordId int, fieldId int, versionNumber int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunFormulaWithBody request with any body
	RunFormulaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunFormula(ctx context.Context, body RunFormulaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveManagersFromGroupWithBody request with any body
	RemoveManagersFromGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveManagersFromGroup(ctx context.Context, gid float32, body RemoveManagersFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddManagersToGroupWithBody request with any body
	AddManagersToGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddManagersToGroup(ctx context.Context, gid float32, body AddManagersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveMembersFromGroupWithBody request with any body
	RemoveMembersFromGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveMembersFromGroup(ctx context.Context, gid float32, body RemoveMembersFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddMembersToGroupWithBody request with any body
	AddMembersToGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddMembersToGroup(ctx context.Context, gid float32, body AddMembersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveSubgroupsFromGroupWithBody request with any body
	RemoveSubgroupsFromGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RemoveSubgroupsFromGroup(ctx context.Context, gid float32, body RemoveSubgroupsFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddSubgroupsToGroupWithBody request with any body
	AddSubgroupsToGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddSubgroupsToGroup(ctx context.Context, gid float32, body AddSubgroupsToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRecordsWithBody request with any body
	DeleteRecordsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteRecords(ctx context.Context, body DeleteRecordsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpsertWithBody request with any body
	UpsertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Upsert(ctx context.Context, body UpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RecordsModifiedSinceWithBody request with any body
	RecordsModifiedSinceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RecordsModifiedSince(ctx context.Context, body RecordsModifiedSinceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunQueryWithBody request with any body
	RunQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunQuery(ctx context.Context, body RunQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTableReports request
	GetTableReports(ctx context.Context, params *GetTableReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReport request
	GetReport(ctx context.Context, reportId string, params *GetReportParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunReportWithBody request with any body
	RunReportWithBody(ctx context.Context, reportId string, params *RunReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunReport(ctx context.Context, reportId string, params *RunReportParams, body RunReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSolutionWithBody request with any body
	CreateSolutionWithBody(ctx context.Context, params *CreateSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSolution(ctx context.Context, params *CreateSolutionParams, body CreateSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSolutionFromRecord request
	CreateSolutionFromRecord(ctx context.Context, params *CreateSolutionFromRecordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSolution request
	ExportSolution(ctx context.Context, solutionId string, params *ExportSolutionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSolutionWithBody request with any body
	UpdateSolutionWithBody(ctx context.Context, solutionId string, params *UpdateSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSolution(ctx context.Context, solutionId string, params *UpdateSolutionParams, body UpdateSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangesetSolutionWithBody request with any body
	ChangesetSolutionWithBody(ctx context.Context, solutionId string, params *ChangesetSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangesetSolution(ctx context.Context, solutionId string, params *ChangesetSolutionParams, body ChangesetSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangesetSolutionFromRecord request
	ChangesetSolutionFromRecord(ctx context.Context, solutionId string, params *ChangesetSolutionFromRecordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSolutionToRecord request
	UpdateSolutionToRecord(ctx context.Context, solutionId string, params *UpdateSolutionToRecordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSolutionPublic request
	GetSolutionPublic(ctx context.Context, solutionId string, params *GetSolutionPublicParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportSolutionToRecord request
	ExportSolutionToRecord(ctx context.Context, solutionId string, params *ExportSolutionToRecordParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppTables request
	GetAppTables(ctx context.Context, params *GetAppTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTableWithBody request with any body
	CreateTableWithBody(ctx context.Context, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTable(ctx context.Context, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTable request
	DeleteTable(ctx context.Context, tableId string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTable request
	GetTable(ctx context.Context, tableId string, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTableWithBody request with any body
	UpdateTableWithBody(ctx context.Context, tableId string, params *UpdateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTable(ctx context.Context, tableId string, params *UpdateTableParams, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRelationshipWithBody request with any body
	CreateRelationshipWithBody(ctx context.Context, tableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRelationship(ctx context.Context, tableId string, body CreateRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRelationship request
	DeleteRelationship(ctx context.Context, tableId string, relationshipId float32, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRelationshipWithBody request with any body
	UpdateRelationshipWithBody(ctx context.Context, tableId string, relationshipId float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRelationship(ctx context.Context, tableId string, relationshipId float32, body UpdateRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRelationships request
	GetRelationships(ctx context.Context, tableId string, params *GetRelationshipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersWithBody request with any body
	GetUsersWithBody(ctx context.Context, params *GetUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetUsers(ctx context.Context, params *GetUsersParams, body GetUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DenyUsersWithBody request with any body
	DenyUsersWithBody(ctx context.Context, params *DenyUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DenyUsers(ctx context.Context, params *DenyUsersParams, body DenyUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DenyUsersAndGroupsWithBody request with any body
	DenyUsersAndGroupsWithBody(ctx context.Context, shouldDeleteFromGroups bool, params *DenyUsersAndGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DenyUsersAndGroups(ctx context.Context, shouldDeleteFromGroups bool, params *DenyUsersAndGroupsParams, body DenyUsersAndGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UndenyUsersWithBody request with any body
	UndenyUsersWithBody(ctx context.Context, params *UndenyUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UndenyUsers(ctx context.Context, params *UndenyUsersParams, body UndenyUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserToken request
	DeleteUserToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CloneUserTokenWithBody request with any body
	CloneUserTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CloneUserToken(ctx context.Context, body CloneUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeactivateUserToken request
	DeactivateUserToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferUserTokenWithBody request with any body
	TransferUserTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TransferUserToken(ctx context.Context, body TransferUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PlatformAnalyticEventSummariesWithBody(ctx context.Context, params *PlatformAnalyticEventSummariesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlatformAnalyticEventSummariesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlatformAnalyticEventSummaries(ctx context.Context, params *PlatformAnalyticEventSummariesParams, body PlatformAnalyticEventSummariesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlatformAnalyticEventSummariesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PlatformAnalyticReads(ctx context.Context, params *PlatformAnalyticReadsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPlatformAnalyticReadsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTrusteesWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTrusteesRequestWithBody(c.Server, appId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveTrustees(ctx context.Context, appId string, body RemoveTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveTrusteesRequest(c.Server, appId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTrustees(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTrusteesRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTrusteesWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTrusteesRequestWithBody(c.Server, appId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTrustees(ctx context.Context, appId string, body UpdateTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTrusteesRequest(c.Server, appId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTrusteesWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTrusteesRequestWithBody(c.Server, appId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddTrustees(ctx context.Context, appId string, body AddTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddTrusteesRequest(c.Server, appId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApp(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppRequestWithBody(c.Server, appId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApp(ctx context.Context, appId string, body DeleteAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppRequest(c.Server, appId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApp(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAppWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequestWithBody(c.Server, appId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApp(ctx context.Context, appId string, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAppRequest(c.Server, appId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyAppWithBody(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyAppRequestWithBody(c.Server, appId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CopyApp(ctx context.Context, appId string, body CopyAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCopyAppRequest(c.Server, appId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppEvents(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppEventsRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoles(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesRequest(c.Server, appId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AuditWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuditRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Audit(ctx context.Context, body AuditJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAuditRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeSsoTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeSsoTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExchangeSsoToken(ctx context.Context, body ExchangeSsoTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExchangeSsoTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTempTokenDBID(ctx context.Context, dbid string, params *GetTempTokenDBIDParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTempTokenDBIDRequest(c.Server, dbid, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateDocument(ctx context.Context, templateId float32, params *GenerateDocumentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateDocumentRequest(c.Server, templateId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFieldsWithBody(ctx context.Context, params *DeleteFieldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFieldsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFields(ctx context.Context, params *DeleteFieldsParams, body DeleteFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFieldsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFields(ctx context.Context, params *GetFieldsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFieldsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFieldWithBody(ctx context.Context, params *CreateFieldParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFieldRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateField(ctx context.Context, params *CreateFieldParams, body CreateFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFieldRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFieldsUsage(ctx context.Context, params *GetFieldsUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFieldsUsageRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFieldUsage(ctx context.Context, fieldId int, params *GetFieldUsageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFieldUsageRequest(c.Server, fieldId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetField(ctx context.Context, fieldId int, params *GetFieldParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFieldRequest(c.Server, fieldId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFieldWithBody(ctx context.Context, fieldId int, params *UpdateFieldParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFieldRequestWithBody(c.Server, fieldId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateField(ctx context.Context, fieldId int, params *UpdateFieldParams, body UpdateFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFieldRequest(c.Server, fieldId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFile(ctx context.Context, tableId string, recordId int, fieldId int, versionNumber int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFileRequest(c.Server, tableId, recordId, fieldId, versionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadFile(ctx context.Context, tableId string, recordId int, fieldId int, versionNumber int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadFileRequest(c.Server, tableId, recordId, fieldId, versionNumber)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFormulaWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFormulaRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunFormula(ctx context.Context, body RunFormulaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunFormulaRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveManagersFromGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveManagersFromGroupRequestWithBody(c.Server, gid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveManagersFromGroup(ctx context.Context, gid float32, body RemoveManagersFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveManagersFromGroupRequest(c.Server, gid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddManagersToGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddManagersToGroupRequestWithBody(c.Server, gid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddManagersToGroup(ctx context.Context, gid float32, body AddManagersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddManagersToGroupRequest(c.Server, gid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMembersFromGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMembersFromGroupRequestWithBody(c.Server, gid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveMembersFromGroup(ctx context.Context, gid float32, body RemoveMembersFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveMembersFromGroupRequest(c.Server, gid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMembersToGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMembersToGroupRequestWithBody(c.Server, gid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddMembersToGroup(ctx context.Context, gid float32, body AddMembersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddMembersToGroupRequest(c.Server, gid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubgroupsFromGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubgroupsFromGroupRequestWithBody(c.Server, gid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveSubgroupsFromGroup(ctx context.Context, gid float32, body RemoveSubgroupsFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveSubgroupsFromGroupRequest(c.Server, gid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSubgroupsToGroupWithBody(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSubgroupsToGroupRequestWithBody(c.Server, gid, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddSubgroupsToGroup(ctx context.Context, gid float32, body AddSubgroupsToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddSubgroupsToGroupRequest(c.Server, gid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecordsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRecords(ctx context.Context, body DeleteRecordsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRecordsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpsertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Upsert(ctx context.Context, body UpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpsertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordsModifiedSinceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordsModifiedSinceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RecordsModifiedSince(ctx context.Context, body RecordsModifiedSinceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRecordsModifiedSinceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunQueryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunQueryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunQuery(ctx context.Context, body RunQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunQueryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTableReports(ctx context.Context, params *GetTableReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableReportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReport(ctx context.Context, reportId string, params *GetReportParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportRequest(c.Server, reportId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunReportWithBody(ctx context.Context, reportId string, params *RunReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunReportRequestWithBody(c.Server, reportId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunReport(ctx context.Context, reportId string, params *RunReportParams, body RunReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunReportRequest(c.Server, reportId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSolutionWithBody(ctx context.Context, params *CreateSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolutionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSolution(ctx context.Context, params *CreateSolutionParams, body CreateSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolutionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSolutionFromRecord(ctx context.Context, params *CreateSolutionFromRecordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSolutionFromRecordRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportSolution(ctx context.Context, solutionId string, params *ExportSolutionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolutionRequest(c.Server, solutionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSolutionWithBody(ctx context.Context, solutionId string, params *UpdateSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSolutionRequestWithBody(c.Server, solutionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSolution(ctx context.Context, solutionId string, params *UpdateSolutionParams, body UpdateSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSolutionRequest(c.Server, solutionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangesetSolutionWithBody(ctx context.Context, solutionId string, params *ChangesetSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangesetSolutionRequestWithBody(c.Server, solutionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangesetSolution(ctx context.Context, solutionId string, params *ChangesetSolutionParams, body ChangesetSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangesetSolutionRequest(c.Server, solutionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangesetSolutionFromRecord(ctx context.Context, solutionId string, params *ChangesetSolutionFromRecordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangesetSolutionFromRecordRequest(c.Server, solutionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSolutionToRecord(ctx context.Context, solutionId string, params *UpdateSolutionToRecordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSolutionToRecordRequest(c.Server, solutionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSolutionPublic(ctx context.Context, solutionId string, params *GetSolutionPublicParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSolutionPublicRequest(c.Server, solutionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportSolutionToRecord(ctx context.Context, solutionId string, params *ExportSolutionToRecordParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportSolutionToRecordRequest(c.Server, solutionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppTables(ctx context.Context, params *GetAppTablesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppTablesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTableWithBody(ctx context.Context, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTable(ctx context.Context, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTableRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTable(ctx context.Context, tableId string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTableRequest(c.Server, tableId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTable(ctx context.Context, tableId string, params *GetTableParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableRequest(c.Server, tableId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTableWithBody(ctx context.Context, tableId string, params *UpdateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTableRequestWithBody(c.Server, tableId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTable(ctx context.Context, tableId string, params *UpdateTableParams, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTableRequest(c.Server, tableId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRelationshipWithBody(ctx context.Context, tableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRelationshipRequestWithBody(c.Server, tableId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRelationship(ctx context.Context, tableId string, body CreateRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRelationshipRequest(c.Server, tableId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRelationship(ctx context.Context, tableId string, relationshipId float32, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRelationshipRequest(c.Server, tableId, relationshipId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRelationshipWithBody(ctx context.Context, tableId string, relationshipId float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRelationshipRequestWithBody(c.Server, tableId, relationshipId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRelationship(ctx context.Context, tableId string, relationshipId float32, body UpdateRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRelationshipRequest(c.Server, tableId, relationshipId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRelationships(ctx context.Context, tableId string, params *GetRelationshipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRelationshipsRequest(c.Server, tableId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersWithBody(ctx context.Context, params *GetUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, body GetUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DenyUsersWithBody(ctx context.Context, params *DenyUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDenyUsersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DenyUsers(ctx context.Context, params *DenyUsersParams, body DenyUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDenyUsersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DenyUsersAndGroupsWithBody(ctx context.Context, shouldDeleteFromGroups bool, params *DenyUsersAndGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDenyUsersAndGroupsRequestWithBody(c.Server, shouldDeleteFromGroups, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DenyUsersAndGroups(ctx context.Context, shouldDeleteFromGroups bool, params *DenyUsersAndGroupsParams, body DenyUsersAndGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDenyUsersAndGroupsRequest(c.Server, shouldDeleteFromGroups, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UndenyUsersWithBody(ctx context.Context, params *UndenyUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUndenyUsersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UndenyUsers(ctx context.Context, params *UndenyUsersParams, body UndenyUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUndenyUsersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneUserTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneUserTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CloneUserToken(ctx context.Context, body CloneUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCloneUserTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeactivateUserToken(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeactivateUserTokenRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferUserTokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferUserTokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferUserToken(ctx context.Context, body TransferUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferUserTokenRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPlatformAnalyticEventSummariesRequest calls the generic PlatformAnalyticEventSummaries builder with application/json body
func NewPlatformAnalyticEventSummariesRequest(server string, params *PlatformAnalyticEventSummariesParams, body PlatformAnalyticEventSummariesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPlatformAnalyticEventSummariesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPlatformAnalyticEventSummariesRequestWithBody generates requests for PlatformAnalyticEventSummaries with any type of body
func NewPlatformAnalyticEventSummariesRequestWithBody(server string, params *PlatformAnalyticEventSummariesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/events/summaries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPlatformAnalyticReadsRequest generates requests for PlatformAnalyticReads
func NewPlatformAnalyticReadsRequest(server string, params *PlatformAnalyticReadsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/reads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Day != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "day", runtime.ParamLocationQuery, *params.Day); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveTrusteesRequest calls the generic RemoveTrustees builder with application/json body
func NewRemoveTrusteesRequest(server string, appId string, body RemoveTrusteesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveTrusteesRequestWithBody(server, appId, "application/json", bodyReader)
}

// NewRemoveTrusteesRequestWithBody generates requests for RemoveTrustees with any type of body
func NewRemoveTrusteesRequestWithBody(server string, appId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/trustees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTrusteesRequest generates requests for GetTrustees
func NewGetTrusteesRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/trustees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTrusteesRequest calls the generic UpdateTrustees builder with application/json body
func NewUpdateTrusteesRequest(server string, appId string, body UpdateTrusteesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTrusteesRequestWithBody(server, appId, "application/json", bodyReader)
}

// NewUpdateTrusteesRequestWithBody generates requests for UpdateTrustees with any type of body
func NewUpdateTrusteesRequestWithBody(server string, appId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/trustees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddTrusteesRequest calls the generic AddTrustees builder with application/json body
func NewAddTrusteesRequest(server string, appId string, body AddTrusteesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddTrusteesRequestWithBody(server, appId, "application/json", bodyReader)
}

// NewAddTrusteesRequestWithBody generates requests for AddTrustees with any type of body
func NewAddTrusteesRequestWithBody(server string, appId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/app/%s/trustees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAppRequest calls the generic CreateApp builder with application/json body
func NewCreateAppRequest(server string, body CreateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAppRequestWithBody generates requests for CreateApp with any type of body
func NewCreateAppRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAppRequest calls the generic DeleteApp builder with application/json body
func NewDeleteAppRequest(server string, appId string, body DeleteAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteAppRequestWithBody(server, appId, "application/json", bodyReader)
}

// NewDeleteAppRequestWithBody generates requests for DeleteApp with any type of body
func NewDeleteAppRequestWithBody(server string, appId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppRequest generates requests for GetApp
func NewGetAppRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAppRequest calls the generic UpdateApp builder with application/json body
func NewUpdateAppRequest(server string, appId string, body UpdateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAppRequestWithBody(server, appId, "application/json", bodyReader)
}

// NewUpdateAppRequestWithBody generates requests for UpdateApp with any type of body
func NewUpdateAppRequestWithBody(server string, appId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCopyAppRequest calls the generic CopyApp builder with application/json body
func NewCopyAppRequest(server string, appId string, body CopyAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCopyAppRequestWithBody(server, appId, "application/json", bodyReader)
}

// NewCopyAppRequestWithBody generates requests for CopyApp with any type of body
func NewCopyAppRequestWithBody(server string, appId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/copy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppEventsRequest generates requests for GetAppEvents
func NewGetAppEventsRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRolesRequest generates requests for GetRoles
func NewGetRolesRequest(server string, appId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "appId", runtime.ParamLocationPath, appId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/apps/%s/roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAuditRequest calls the generic Audit builder with application/json body
func NewAuditRequest(server string, body AuditJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAuditRequestWithBody(server, "application/json", bodyReader)
}

// NewAuditRequestWithBody generates requests for Audit with any type of body
func NewAuditRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/audit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewExchangeSsoTokenRequest calls the generic ExchangeSsoToken builder with application/json body
func NewExchangeSsoTokenRequest(server string, body ExchangeSsoTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExchangeSsoTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewExchangeSsoTokenRequestWithBody generates requests for ExchangeSsoToken with any type of body
func NewExchangeSsoTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/oauth/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTempTokenDBIDRequest generates requests for GetTempTokenDBID
func NewGetTempTokenDBIDRequest(server string, dbid string, params *GetTempTokenDBIDParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "dbid", runtime.ParamLocationPath, dbid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/temporary/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.QBAppToken != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "QB-App-Token", runtime.ParamLocationHeader, *params.QBAppToken)
			if err != nil {
				return nil, err
			}

			req.Header.Set("QB-App-Token", headerParam0)
		}

	}

	return req, nil
}

// NewGenerateDocumentRequest generates requests for GenerateDocument
func NewGenerateDocumentRequest(server string, templateId float32, params *GenerateDocumentParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "templateId", runtime.ParamLocationPath, templateId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/docTemplates/%s/generate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.RecordId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recordId", runtime.ParamLocationQuery, *params.RecordId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filename", runtime.ParamLocationQuery, params.Filename); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Margin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "margin", runtime.ParamLocationQuery, *params.Margin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unit", runtime.ParamLocationQuery, *params.Unit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Orientation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orientation", runtime.ParamLocationQuery, *params.Orientation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Realm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "realm", runtime.ParamLocationQuery, *params.Realm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.Accept != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Accept", runtime.ParamLocationHeader, *params.Accept)
			if err != nil {
				return nil, err
			}

			req.Header.Set("Accept", headerParam0)
		}

	}

	return req, nil
}

// NewDeleteFieldsRequest calls the generic DeleteFields builder with application/json body
func NewDeleteFieldsRequest(server string, params *DeleteFieldsParams, body DeleteFieldsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteFieldsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeleteFieldsRequestWithBody generates requests for DeleteFields with any type of body
func NewDeleteFieldsRequestWithBody(server string, params *DeleteFieldsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFieldsRequest generates requests for GetFields
func NewGetFieldsRequest(server string, params *GetFieldsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IncludeFieldPerms != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFieldPerms", runtime.ParamLocationQuery, *params.IncludeFieldPerms); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFieldRequest calls the generic CreateField builder with application/json body
func NewCreateFieldRequest(server string, params *CreateFieldParams, body CreateFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFieldRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateFieldRequestWithBody generates requests for CreateField with any type of body
func NewCreateFieldRequestWithBody(server string, params *CreateFieldParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fields")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFieldsUsageRequest generates requests for GetFieldsUsage
func NewGetFieldsUsageRequest(server string, params *GetFieldsUsageParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fields/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Top != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "top", runtime.ParamLocationQuery, *params.Top); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFieldUsageRequest generates requests for GetFieldUsage
func NewGetFieldUsageRequest(server string, fieldId int, params *GetFieldUsageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fieldId", runtime.ParamLocationPath, fieldId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fields/usage/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFieldRequest generates requests for GetField
func NewGetFieldRequest(server string, fieldId int, params *GetFieldParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fieldId", runtime.ParamLocationPath, fieldId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IncludeFieldPerms != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFieldPerms", runtime.ParamLocationQuery, *params.IncludeFieldPerms); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFieldRequest calls the generic UpdateField builder with application/json body
func NewUpdateFieldRequest(server string, fieldId int, params *UpdateFieldParams, body UpdateFieldJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFieldRequestWithBody(server, fieldId, params, "application/json", bodyReader)
}

// NewUpdateFieldRequestWithBody generates requests for UpdateField with any type of body
func NewUpdateFieldRequestWithBody(server string, fieldId int, params *UpdateFieldParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fieldId", runtime.ParamLocationPath, fieldId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/fields/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFileRequest generates requests for DeleteFile
func NewDeleteFileRequest(server string, tableId string, recordId int, fieldId int, versionNumber int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableId", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recordId", runtime.ParamLocationPath, recordId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "fieldId", runtime.ParamLocationPath, fieldId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "versionNumber", runtime.ParamLocationPath, versionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadFileRequest generates requests for DownloadFile
func NewDownloadFileRequest(server string, tableId string, recordId int, fieldId int, versionNumber int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableId", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "recordId", runtime.ParamLocationPath, recordId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "fieldId", runtime.ParamLocationPath, fieldId)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "versionNumber", runtime.ParamLocationPath, versionNumber)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/files/%s/%s/%s/%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunFormulaRequest calls the generic RunFormula builder with application/json body
func NewRunFormulaRequest(server string, body RunFormulaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunFormulaRequestWithBody(server, "application/json", bodyReader)
}

// NewRunFormulaRequestWithBody generates requests for RunFormula with any type of body
func NewRunFormulaRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/formula/run")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveManagersFromGroupRequest calls the generic RemoveManagersFromGroup builder with application/json body
func NewRemoveManagersFromGroupRequest(server string, gid float32, body RemoveManagersFromGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveManagersFromGroupRequestWithBody(server, gid, "application/json", bodyReader)
}

// NewRemoveManagersFromGroupRequestWithBody generates requests for RemoveManagersFromGroup with any type of body
func NewRemoveManagersFromGroupRequestWithBody(server string, gid float32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gid", runtime.ParamLocationPath, gid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/managers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddManagersToGroupRequest calls the generic AddManagersToGroup builder with application/json body
func NewAddManagersToGroupRequest(server string, gid float32, body AddManagersToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddManagersToGroupRequestWithBody(server, gid, "application/json", bodyReader)
}

// NewAddManagersToGroupRequestWithBody generates requests for AddManagersToGroup with any type of body
func NewAddManagersToGroupRequestWithBody(server string, gid float32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gid", runtime.ParamLocationPath, gid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/managers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveMembersFromGroupRequest calls the generic RemoveMembersFromGroup builder with application/json body
func NewRemoveMembersFromGroupRequest(server string, gid float32, body RemoveMembersFromGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveMembersFromGroupRequestWithBody(server, gid, "application/json", bodyReader)
}

// NewRemoveMembersFromGroupRequestWithBody generates requests for RemoveMembersFromGroup with any type of body
func NewRemoveMembersFromGroupRequestWithBody(server string, gid float32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gid", runtime.ParamLocationPath, gid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddMembersToGroupRequest calls the generic AddMembersToGroup builder with application/json body
func NewAddMembersToGroupRequest(server string, gid float32, body AddMembersToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddMembersToGroupRequestWithBody(server, gid, "application/json", bodyReader)
}

// NewAddMembersToGroupRequestWithBody generates requests for AddMembersToGroup with any type of body
func NewAddMembersToGroupRequestWithBody(server string, gid float32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gid", runtime.ParamLocationPath, gid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveSubgroupsFromGroupRequest calls the generic RemoveSubgroupsFromGroup builder with application/json body
func NewRemoveSubgroupsFromGroupRequest(server string, gid float32, body RemoveSubgroupsFromGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRemoveSubgroupsFromGroupRequestWithBody(server, gid, "application/json", bodyReader)
}

// NewRemoveSubgroupsFromGroupRequestWithBody generates requests for RemoveSubgroupsFromGroup with any type of body
func NewRemoveSubgroupsFromGroupRequestWithBody(server string, gid float32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gid", runtime.ParamLocationPath, gid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/subgroups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddSubgroupsToGroupRequest calls the generic AddSubgroupsToGroup builder with application/json body
func NewAddSubgroupsToGroupRequest(server string, gid float32, body AddSubgroupsToGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddSubgroupsToGroupRequestWithBody(server, gid, "application/json", bodyReader)
}

// NewAddSubgroupsToGroupRequestWithBody generates requests for AddSubgroupsToGroup with any type of body
func NewAddSubgroupsToGroupRequestWithBody(server string, gid float32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "gid", runtime.ParamLocationPath, gid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/groups/%s/subgroups", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRecordsRequest calls the generic DeleteRecords builder with application/json body
func NewDeleteRecordsRequest(server string, body DeleteRecordsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteRecordsRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteRecordsRequestWithBody generates requests for DeleteRecords with any type of body
func NewDeleteRecordsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/records")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpsertRequest calls the generic Upsert builder with application/json body
func NewUpsertRequest(server string, body UpsertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpsertRequestWithBody(server, "application/json", bodyReader)
}

// NewUpsertRequestWithBody generates requests for Upsert with any type of body
func NewUpsertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/records")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRecordsModifiedSinceRequest calls the generic RecordsModifiedSince builder with application/json body
func NewRecordsModifiedSinceRequest(server string, body RecordsModifiedSinceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRecordsModifiedSinceRequestWithBody(server, "application/json", bodyReader)
}

// NewRecordsModifiedSinceRequestWithBody generates requests for RecordsModifiedSince with any type of body
func NewRecordsModifiedSinceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/records/modifiedSince")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRunQueryRequest calls the generic RunQuery builder with application/json body
func NewRunQueryRequest(server string, body RunQueryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunQueryRequestWithBody(server, "application/json", bodyReader)
}

// NewRunQueryRequestWithBody generates requests for RunQuery with any type of body
func NewRunQueryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/records/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTableReportsRequest generates requests for GetTableReports
func NewGetTableReportsRequest(server string, params *GetTableReportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReportRequest generates requests for GetReport
func NewGetReportRequest(server string, reportId string, params *GetReportParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reportId", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRunReportRequest calls the generic RunReport builder with application/json body
func NewRunReportRequest(server string, reportId string, params *RunReportParams, body RunReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunReportRequestWithBody(server, reportId, params, "application/json", bodyReader)
}

// NewRunReportRequestWithBody generates requests for RunReport with any type of body
func NewRunReportRequestWithBody(server string, reportId string, params *RunReportParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reportId", runtime.ParamLocationPath, reportId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reports/%s/run", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Top != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "top", runtime.ParamLocationQuery, *params.Top); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSolutionRequest calls the generic CreateSolution builder with application/json body
func NewCreateSolutionRequest(server string, params *CreateSolutionParams, body CreateSolutionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSolutionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateSolutionRequestWithBody generates requests for CreateSolution with any type of body
func NewCreateSolutionRequestWithBody(server string, params *CreateSolutionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solutions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XQBLErrorsAsSuccess != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-QBL-Errors-As-Success", runtime.ParamLocationHeader, *params.XQBLErrorsAsSuccess)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-QBL-Errors-As-Success", headerParam0)
		}

	}

	return req, nil
}

// NewCreateSolutionFromRecordRequest generates requests for CreateSolutionFromRecord
func NewCreateSolutionFromRecordRequest(server string, params *CreateSolutionFromRecordParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solutions/fromrecord")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fieldId", runtime.ParamLocationQuery, params.FieldId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recordId", runtime.ParamLocationQuery, params.RecordId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XQBLErrorsAsSuccess != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-QBL-Errors-As-Success", runtime.ParamLocationHeader, *params.XQBLErrorsAsSuccess)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-QBL-Errors-As-Success", headerParam0)
		}

	}

	return req, nil
}

// NewExportSolutionRequest generates requests for ExportSolution
func NewExportSolutionRequest(server string, solutionId string, params *ExportSolutionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "solutionId", runtime.ParamLocationPath, solutionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solutions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.QBLVersion != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "QBL-Version", runtime.ParamLocationHeader, *params.QBLVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("QBL-Version", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateSolutionRequest calls the generic UpdateSolution builder with application/json body
func NewUpdateSolutionRequest(server string, solutionId string, params *UpdateSolutionParams, body UpdateSolutionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSolutionRequestWithBody(server, solutionId, params, "application/json", bodyReader)
}

// NewUpdateSolutionRequestWithBody generates requests for UpdateSolution with any type of body
func NewUpdateSolutionRequestWithBody(server string, solutionId string, params *UpdateSolutionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "solutionId", runtime.ParamLocationPath, solutionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solutions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XQBLErrorsAsSuccess != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-QBL-Errors-As-Success", runtime.ParamLocationHeader, *params.XQBLErrorsAsSuccess)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-QBL-Errors-As-Success", headerParam0)
		}

	}

	return req, nil
}

// NewChangesetSolutionRequest calls the generic ChangesetSolution builder with application/json body
func NewChangesetSolutionRequest(server string, solutionId string, params *ChangesetSolutionParams, body ChangesetSolutionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangesetSolutionRequestWithBody(server, solutionId, params, "application/json", bodyReader)
}

// NewChangesetSolutionRequestWithBody generates requests for ChangesetSolution with any type of body
func NewChangesetSolutionRequestWithBody(server string, solutionId string, params *ChangesetSolutionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "solutionId", runtime.ParamLocationPath, solutionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solutions/%s/changeset", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XQBLErrorsAsSuccess != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-QBL-Errors-As-Success", runtime.ParamLocationHeader, *params.XQBLErrorsAsSuccess)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-QBL-Errors-As-Success", headerParam0)
		}

	}

	return req, nil
}

// NewChangesetSolutionFromRecordRequest generates requests for ChangesetSolutionFromRecord
func NewChangesetSolutionFromRecordRequest(server string, solutionId string, params *ChangesetSolutionFromRecordParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "solutionId", runtime.ParamLocationPath, solutionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solutions/%s/changeset/fromrecord", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fieldId", runtime.ParamLocationQuery, params.FieldId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recordId", runtime.ParamLocationQuery, params.RecordId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XQBLErrorsAsSuccess != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-QBL-Errors-As-Success", runtime.ParamLocationHeader, *params.XQBLErrorsAsSuccess)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-QBL-Errors-As-Success", headerParam0)
		}

	}

	return req, nil
}

// NewUpdateSolutionToRecordRequest generates requests for UpdateSolutionToRecord
func NewUpdateSolutionToRecordRequest(server string, solutionId string, params *UpdateSolutionToRecordParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "solutionId", runtime.ParamLocationPath, solutionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solutions/%s/fromrecord", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fieldId", runtime.ParamLocationQuery, params.FieldId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "recordId", runtime.ParamLocationQuery, params.RecordId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XQBLErrorsAsSuccess != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-QBL-Errors-As-Success", runtime.ParamLocationHeader, *params.XQBLErrorsAsSuccess)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-QBL-Errors-As-Success", headerParam0)
		}

	}

	return req, nil
}

// NewGetSolutionPublicRequest generates requests for GetSolutionPublic
func NewGetSolutionPublicRequest(server string, solutionId string, params *GetSolutionPublicParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "solutionId", runtime.ParamLocationPath, solutionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solutions/%s/resources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XQBLErrorsAsSuccess != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-QBL-Errors-As-Success", runtime.ParamLocationHeader, *params.XQBLErrorsAsSuccess)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-QBL-Errors-As-Success", headerParam0)
		}

	}

	return req, nil
}

// NewExportSolutionToRecordRequest generates requests for ExportSolutionToRecord
func NewExportSolutionToRecordRequest(server string, solutionId string, params *ExportSolutionToRecordParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "solutionId", runtime.ParamLocationPath, solutionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/solutions/%s/torecord", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tableId", runtime.ParamLocationQuery, params.TableId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fieldId", runtime.ParamLocationQuery, params.FieldId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.XQBLErrorsAsSuccess != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-QBL-Errors-As-Success", runtime.ParamLocationHeader, *params.XQBLErrorsAsSuccess)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-QBL-Errors-As-Success", headerParam0)
		}

		if params.QBLVersion != nil {
			var headerParam1 string

			headerParam1, err = runtime.StyleParamWithLocation("simple", false, "QBL-Version", runtime.ParamLocationHeader, *params.QBLVersion)
			if err != nil {
				return nil, err
			}

			req.Header.Set("QBL-Version", headerParam1)
		}

	}

	return req, nil
}

// NewGetAppTablesRequest generates requests for GetAppTables
func NewGetAppTablesRequest(server string, params *GetAppTablesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appId", runtime.ParamLocationQuery, params.AppId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTableRequest calls the generic CreateTable builder with application/json body
func NewCreateTableRequest(server string, params *CreateTableParams, body CreateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTableRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateTableRequestWithBody generates requests for CreateTable with any type of body
func NewCreateTableRequestWithBody(server string, params *CreateTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appId", runtime.ParamLocationQuery, params.AppId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTableRequest generates requests for DeleteTable
func NewDeleteTableRequest(server string, tableId string, params *DeleteTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableId", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appId", runtime.ParamLocationQuery, params.AppId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTableRequest generates requests for GetTable
func NewGetTableRequest(server string, tableId string, params *GetTableParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableId", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appId", runtime.ParamLocationQuery, params.AppId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTableRequest calls the generic UpdateTable builder with application/json body
func NewUpdateTableRequest(server string, tableId string, params *UpdateTableParams, body UpdateTableJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTableRequestWithBody(server, tableId, params, "application/json", bodyReader)
}

// NewUpdateTableRequestWithBody generates requests for UpdateTable with any type of body
func NewUpdateTableRequestWithBody(server string, tableId string, params *UpdateTableParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableId", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "appId", runtime.ParamLocationQuery, params.AppId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateRelationshipRequest calls the generic CreateRelationship builder with application/json body
func NewCreateRelationshipRequest(server string, tableId string, body CreateRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRelationshipRequestWithBody(server, tableId, "application/json", bodyReader)
}

// NewCreateRelationshipRequestWithBody generates requests for CreateRelationship with any type of body
func NewCreateRelationshipRequestWithBody(server string, tableId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableId", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/relationship", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRelationshipRequest generates requests for DeleteRelationship
func NewDeleteRelationshipRequest(server string, tableId string, relationshipId float32) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableId", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "relationshipId", runtime.ParamLocationPath, relationshipId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/relationship/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRelationshipRequest calls the generic UpdateRelationship builder with application/json body
func NewUpdateRelationshipRequest(server string, tableId string, relationshipId float32, body UpdateRelationshipJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRelationshipRequestWithBody(server, tableId, relationshipId, "application/json", bodyReader)
}

// NewUpdateRelationshipRequestWithBody generates requests for UpdateRelationship with any type of body
func NewUpdateRelationshipRequestWithBody(server string, tableId string, relationshipId float32, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableId", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "relationshipId", runtime.ParamLocationPath, relationshipId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/relationship/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetRelationshipsRequest generates requests for GetRelationships
func NewGetRelationshipsRequest(server string, tableId string, params *GetRelationshipsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableId", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tables/%s/relationships", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Skip != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest calls the generic GetUsers builder with application/json body
func NewGetUsersRequest(server string, params *GetUsersParams, body GetUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetUsersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetUsersRequestWithBody generates requests for GetUsers with any type of body
func NewGetUsersRequestWithBody(server string, params *GetUsersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDenyUsersRequest calls the generic DenyUsers builder with application/json body
func NewDenyUsersRequest(server string, params *DenyUsersParams, body DenyUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDenyUsersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDenyUsersRequestWithBody generates requests for DenyUsers with any type of body
func NewDenyUsersRequestWithBody(server string, params *DenyUsersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/deny")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDenyUsersAndGroupsRequest calls the generic DenyUsersAndGroups builder with application/json body
func NewDenyUsersAndGroupsRequest(server string, shouldDeleteFromGroups bool, params *DenyUsersAndGroupsParams, body DenyUsersAndGroupsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDenyUsersAndGroupsRequestWithBody(server, shouldDeleteFromGroups, params, "application/json", bodyReader)
}

// NewDenyUsersAndGroupsRequestWithBody generates requests for DenyUsersAndGroups with any type of body
func NewDenyUsersAndGroupsRequestWithBody(server string, shouldDeleteFromGroups bool, params *DenyUsersAndGroupsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "shouldDeleteFromGroups", runtime.ParamLocationPath, shouldDeleteFromGroups)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/deny/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUndenyUsersRequest calls the generic UndenyUsers builder with application/json body
func NewUndenyUsersRequest(server string, params *UndenyUsersParams, body UndenyUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUndenyUsersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUndenyUsersRequestWithBody generates requests for UndenyUsers with any type of body
func NewUndenyUsersRequestWithBody(server string, params *UndenyUsersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/undeny")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AccountId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, *params.AccountId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserTokenRequest generates requests for DeleteUserToken
func NewDeleteUserTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usertoken")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCloneUserTokenRequest calls the generic CloneUserToken builder with application/json body
func NewCloneUserTokenRequest(server string, body CloneUserTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCloneUserTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewCloneUserTokenRequestWithBody generates requests for CloneUserToken with any type of body
func NewCloneUserTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usertoken/clone")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeactivateUserTokenRequest generates requests for DeactivateUserToken
func NewDeactivateUserTokenRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usertoken/deactivate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferUserTokenRequest calls the generic TransferUserToken builder with application/json body
func NewTransferUserTokenRequest(server string, body TransferUserTokenJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTransferUserTokenRequestWithBody(server, "application/json", bodyReader)
}

// NewTransferUserTokenRequestWithBody generates requests for TransferUserToken with any type of body
func NewTransferUserTokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usertoken/transfer")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PlatformAnalyticEventSummariesWithBodyWithResponse request with any body
	PlatformAnalyticEventSummariesWithBodyWithResponse(ctx context.Context, params *PlatformAnalyticEventSummariesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlatformAnalyticEventSummariesResponse, error)

	PlatformAnalyticEventSummariesWithResponse(ctx context.Context, params *PlatformAnalyticEventSummariesParams, body PlatformAnalyticEventSummariesJSONRequestBody, reqEditors ...RequestEditorFn) (*PlatformAnalyticEventSummariesResponse, error)

	// PlatformAnalyticReadsWithResponse request
	PlatformAnalyticReadsWithResponse(ctx context.Context, params *PlatformAnalyticReadsParams, reqEditors ...RequestEditorFn) (*PlatformAnalyticReadsResponse, error)

	// RemoveTrusteesWithBodyWithResponse request with any body
	RemoveTrusteesWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTrusteesResponse, error)

	RemoveTrusteesWithResponse(ctx context.Context, appId string, body RemoveTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTrusteesResponse, error)

	// GetTrusteesWithResponse request
	GetTrusteesWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetTrusteesResponse, error)

	// UpdateTrusteesWithBodyWithResponse request with any body
	UpdateTrusteesWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTrusteesResponse, error)

	UpdateTrusteesWithResponse(ctx context.Context, appId string, body UpdateTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTrusteesResponse, error)

	// AddTrusteesWithBodyWithResponse request with any body
	AddTrusteesWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTrusteesResponse, error)

	AddTrusteesWithResponse(ctx context.Context, appId string, body AddTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTrusteesResponse, error)

	// CreateAppWithBodyWithResponse request with any body
	CreateAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

	CreateAppWithResponse(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error)

	// DeleteAppWithBodyWithResponse request with any body
	DeleteAppWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error)

	DeleteAppWithResponse(ctx context.Context, appId string, body DeleteAppJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error)

	// GetAppWithResponse request
	GetAppWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetAppResponse, error)

	// UpdateAppWithBodyWithResponse request with any body
	UpdateAppWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	UpdateAppWithResponse(ctx context.Context, appId string, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error)

	// CopyAppWithBodyWithResponse request with any body
	CopyAppWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyAppResponse, error)

	CopyAppWithResponse(ctx context.Context, appId string, body CopyAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyAppResponse, error)

	// GetAppEventsWithResponse request
	GetAppEventsWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetAppEventsResponse, error)

	// GetRolesWithResponse request
	GetRolesWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetRolesResponse, error)

	// AuditWithBodyWithResponse request with any body
	AuditWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuditResponse, error)

	AuditWithResponse(ctx context.Context, body AuditJSONRequestBody, reqEditors ...RequestEditorFn) (*AuditResponse, error)

	// ExchangeSsoTokenWithBodyWithResponse request with any body
	ExchangeSsoTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExchangeSsoTokenResponse, error)

	ExchangeSsoTokenWithResponse(ctx context.Context, body ExchangeSsoTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*ExchangeSsoTokenResponse, error)

	// GetTempTokenDBIDWithResponse request
	GetTempTokenDBIDWithResponse(ctx context.Context, dbid string, params *GetTempTokenDBIDParams, reqEditors ...RequestEditorFn) (*GetTempTokenDBIDResponse, error)

	// GenerateDocumentWithResponse request
	GenerateDocumentWithResponse(ctx context.Context, templateId float32, params *GenerateDocumentParams, reqEditors ...RequestEditorFn) (*GenerateDocumentResponse, error)

	// DeleteFieldsWithBodyWithResponse request with any body
	DeleteFieldsWithBodyWithResponse(ctx context.Context, params *DeleteFieldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteFieldsResponse, error)

	DeleteFieldsWithResponse(ctx context.Context, params *DeleteFieldsParams, body DeleteFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteFieldsResponse, error)

	// GetFieldsWithResponse request
	GetFieldsWithResponse(ctx context.Context, params *GetFieldsParams, reqEditors ...RequestEditorFn) (*GetFieldsResponse, error)

	// CreateFieldWithBodyWithResponse request with any body
	CreateFieldWithBodyWithResponse(ctx context.Context, params *CreateFieldParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFieldResponse, error)

	CreateFieldWithResponse(ctx context.Context, params *CreateFieldParams, body CreateFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFieldResponse, error)

	// GetFieldsUsageWithResponse request
	GetFieldsUsageWithResponse(ctx context.Context, params *GetFieldsUsageParams, reqEditors ...RequestEditorFn) (*GetFieldsUsageResponse, error)

	// GetFieldUsageWithResponse request
	GetFieldUsageWithResponse(ctx context.Context, fieldId int, params *GetFieldUsageParams, reqEditors ...RequestEditorFn) (*GetFieldUsageResponse, error)

	// GetFieldWithResponse request
	GetFieldWithResponse(ctx context.Context, fieldId int, params *GetFieldParams, reqEditors ...RequestEditorFn) (*GetFieldResponse, error)

	// UpdateFieldWithBodyWithResponse request with any body
	UpdateFieldWithBodyWithResponse(ctx context.Context, fieldId int, params *UpdateFieldParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFieldResponse, error)

	UpdateFieldWithResponse(ctx context.Context, fieldId int, params *UpdateFieldParams, body UpdateFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFieldResponse, error)

	// DeleteFileWithResponse request
	DeleteFileWithResponse(ctx context.Context, tableId string, recordId int, fieldId int, versionNumber int, reqEditors ...RequestEditorFn) (*DeleteFileResponse, error)

	// DownloadFileWithResponse request
	DownloadFileWithResponse(ctx context.Context, tableId string, recordId int, fieldId int, versionNumber int, reqEditors ...RequestEditorFn) (*DownloadFileResponse, error)

	// RunFormulaWithBodyWithResponse request with any body
	RunFormulaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFormulaResponse, error)

	RunFormulaWithResponse(ctx context.Context, body RunFormulaJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFormulaResponse, error)

	// RemoveManagersFromGroupWithBodyWithResponse request with any body
	RemoveManagersFromGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveManagersFromGroupResponse, error)

	RemoveManagersFromGroupWithResponse(ctx context.Context, gid float32, body RemoveManagersFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveManagersFromGroupResponse, error)

	// AddManagersToGroupWithBodyWithResponse request with any body
	AddManagersToGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddManagersToGroupResponse, error)

	AddManagersToGroupWithResponse(ctx context.Context, gid float32, body AddManagersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddManagersToGroupResponse, error)

	// RemoveMembersFromGroupWithBodyWithResponse request with any body
	RemoveMembersFromGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveMembersFromGroupResponse, error)

	RemoveMembersFromGroupWithResponse(ctx context.Context, gid float32, body RemoveMembersFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveMembersFromGroupResponse, error)

	// AddMembersToGroupWithBodyWithResponse request with any body
	AddMembersToGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMembersToGroupResponse, error)

	AddMembersToGroupWithResponse(ctx context.Context, gid float32, body AddMembersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMembersToGroupResponse, error)

	// RemoveSubgroupsFromGroupWithBodyWithResponse request with any body
	RemoveSubgroupsFromGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSubgroupsFromGroupResponse, error)

	RemoveSubgroupsFromGroupWithResponse(ctx context.Context, gid float32, body RemoveSubgroupsFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveSubgroupsFromGroupResponse, error)

	// AddSubgroupsToGroupWithBodyWithResponse request with any body
	AddSubgroupsToGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSubgroupsToGroupResponse, error)

	AddSubgroupsToGroupWithResponse(ctx context.Context, gid float32, body AddSubgroupsToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSubgroupsToGroupResponse, error)

	// DeleteRecordsWithBodyWithResponse request with any body
	DeleteRecordsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRecordsResponse, error)

	DeleteRecordsWithResponse(ctx context.Context, body DeleteRecordsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRecordsResponse, error)

	// UpsertWithBodyWithResponse request with any body
	UpsertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertResponse, error)

	UpsertWithResponse(ctx context.Context, body UpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertResponse, error)

	// RecordsModifiedSinceWithBodyWithResponse request with any body
	RecordsModifiedSinceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecordsModifiedSinceResponse, error)

	RecordsModifiedSinceWithResponse(ctx context.Context, body RecordsModifiedSinceJSONRequestBody, reqEditors ...RequestEditorFn) (*RecordsModifiedSinceResponse, error)

	// RunQueryWithBodyWithResponse request with any body
	RunQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunQueryResponse, error)

	RunQueryWithResponse(ctx context.Context, body RunQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunQueryResponse, error)

	// GetTableReportsWithResponse request
	GetTableReportsWithResponse(ctx context.Context, params *GetTableReportsParams, reqEditors ...RequestEditorFn) (*GetTableReportsResponse, error)

	// GetReportWithResponse request
	GetReportWithResponse(ctx context.Context, reportId string, params *GetReportParams, reqEditors ...RequestEditorFn) (*GetReportResponse, error)

	// RunReportWithBodyWithResponse request with any body
	RunReportWithBodyWithResponse(ctx context.Context, reportId string, params *RunReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunReportResponse, error)

	RunReportWithResponse(ctx context.Context, reportId string, params *RunReportParams, body RunReportJSONRequestBody, reqEditors ...RequestEditorFn) (*RunReportResponse, error)

	// CreateSolutionWithBodyWithResponse request with any body
	CreateSolutionWithBodyWithResponse(ctx context.Context, params *CreateSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSolutionResponse, error)

	CreateSolutionWithResponse(ctx context.Context, params *CreateSolutionParams, body CreateSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSolutionResponse, error)

	// CreateSolutionFromRecordWithResponse request
	CreateSolutionFromRecordWithResponse(ctx context.Context, params *CreateSolutionFromRecordParams, reqEditors ...RequestEditorFn) (*CreateSolutionFromRecordResponse, error)

	// ExportSolutionWithResponse request
	ExportSolutionWithResponse(ctx context.Context, solutionId string, params *ExportSolutionParams, reqEditors ...RequestEditorFn) (*ExportSolutionResponse, error)

	// UpdateSolutionWithBodyWithResponse request with any body
	UpdateSolutionWithBodyWithResponse(ctx context.Context, solutionId string, params *UpdateSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSolutionResponse, error)

	UpdateSolutionWithResponse(ctx context.Context, solutionId string, params *UpdateSolutionParams, body UpdateSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSolutionResponse, error)

	// ChangesetSolutionWithBodyWithResponse request with any body
	ChangesetSolutionWithBodyWithResponse(ctx context.Context, solutionId string, params *ChangesetSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangesetSolutionResponse, error)

	ChangesetSolutionWithResponse(ctx context.Context, solutionId string, params *ChangesetSolutionParams, body ChangesetSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangesetSolutionResponse, error)

	// ChangesetSolutionFromRecordWithResponse request
	ChangesetSolutionFromRecordWithResponse(ctx context.Context, solutionId string, params *ChangesetSolutionFromRecordParams, reqEditors ...RequestEditorFn) (*ChangesetSolutionFromRecordResponse, error)

	// UpdateSolutionToRecordWithResponse request
	UpdateSolutionToRecordWithResponse(ctx context.Context, solutionId string, params *UpdateSolutionToRecordParams, reqEditors ...RequestEditorFn) (*UpdateSolutionToRecordResponse, error)

	// GetSolutionPublicWithResponse request
	GetSolutionPublicWithResponse(ctx context.Context, solutionId string, params *GetSolutionPublicParams, reqEditors ...RequestEditorFn) (*GetSolutionPublicResponse, error)

	// ExportSolutionToRecordWithResponse request
	ExportSolutionToRecordWithResponse(ctx context.Context, solutionId string, params *ExportSolutionToRecordParams, reqEditors ...RequestEditorFn) (*ExportSolutionToRecordResponse, error)

	// GetAppTablesWithResponse request
	GetAppTablesWithResponse(ctx context.Context, params *GetAppTablesParams, reqEditors ...RequestEditorFn) (*GetAppTablesResponse, error)

	// CreateTableWithBodyWithResponse request with any body
	CreateTableWithBodyWithResponse(ctx context.Context, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	CreateTableWithResponse(ctx context.Context, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error)

	// DeleteTableWithResponse request
	DeleteTableWithResponse(ctx context.Context, tableId string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error)

	// GetTableWithResponse request
	GetTableWithResponse(ctx context.Context, tableId string, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error)

	// UpdateTableWithBodyWithResponse request with any body
	UpdateTableWithBodyWithResponse(ctx context.Context, tableId string, params *UpdateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error)

	UpdateTableWithResponse(ctx context.Context, tableId string, params *UpdateTableParams, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error)

	// CreateRelationshipWithBodyWithResponse request with any body
	CreateRelationshipWithBodyWithResponse(ctx context.Context, tableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRelationshipResponse, error)

	CreateRelationshipWithResponse(ctx context.Context, tableId string, body CreateRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRelationshipResponse, error)

	// DeleteRelationshipWithResponse request
	DeleteRelationshipWithResponse(ctx context.Context, tableId string, relationshipId float32, reqEditors ...RequestEditorFn) (*DeleteRelationshipResponse, error)

	// UpdateRelationshipWithBodyWithResponse request with any body
	UpdateRelationshipWithBodyWithResponse(ctx context.Context, tableId string, relationshipId float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRelationshipResponse, error)

	UpdateRelationshipWithResponse(ctx context.Context, tableId string, relationshipId float32, body UpdateRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRelationshipResponse, error)

	// GetRelationshipsWithResponse request
	GetRelationshipsWithResponse(ctx context.Context, tableId string, params *GetRelationshipsParams, reqEditors ...RequestEditorFn) (*GetRelationshipsResponse, error)

	// GetUsersWithBodyWithResponse request with any body
	GetUsersWithBodyWithResponse(ctx context.Context, params *GetUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, body GetUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// DenyUsersWithBodyWithResponse request with any body
	DenyUsersWithBodyWithResponse(ctx context.Context, params *DenyUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DenyUsersResponse, error)

	DenyUsersWithResponse(ctx context.Context, params *DenyUsersParams, body DenyUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*DenyUsersResponse, error)

	// DenyUsersAndGroupsWithBodyWithResponse request with any body
	DenyUsersAndGroupsWithBodyWithResponse(ctx context.Context, shouldDeleteFromGroups bool, params *DenyUsersAndGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DenyUsersAndGroupsResponse, error)

	DenyUsersAndGroupsWithResponse(ctx context.Context, shouldDeleteFromGroups bool, params *DenyUsersAndGroupsParams, body DenyUsersAndGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*DenyUsersAndGroupsResponse, error)

	// UndenyUsersWithBodyWithResponse request with any body
	UndenyUsersWithBodyWithResponse(ctx context.Context, params *UndenyUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UndenyUsersResponse, error)

	UndenyUsersWithResponse(ctx context.Context, params *UndenyUsersParams, body UndenyUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*UndenyUsersResponse, error)

	// DeleteUserTokenWithResponse request
	DeleteUserTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserTokenResponse, error)

	// CloneUserTokenWithBodyWithResponse request with any body
	CloneUserTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneUserTokenResponse, error)

	CloneUserTokenWithResponse(ctx context.Context, body CloneUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneUserTokenResponse, error)

	// DeactivateUserTokenWithResponse request
	DeactivateUserTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeactivateUserTokenResponse, error)

	// TransferUserTokenWithBodyWithResponse request with any body
	TransferUserTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferUserTokenResponse, error)

	TransferUserTokenWithResponse(ctx context.Context, body TransferUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*TransferUserTokenResponse, error)
}

type PlatformAnalyticEventSummariesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			EventsSummaries struct {
				// AccountId The ID of the account the events are associated with.
				AccountId string `json:"accountId"`

				// End The end date and time of the requested summaries in ISO 8601 time format.
				End time.Time `json:"end"`

				// GroupBy How the events should be grouped.
				GroupBy PlatformAnalyticEventSummaries200DataEventsSummariesGroupBy `json:"groupBy"`

				// Metadata Additional information about the results that may be helpful.
				Metadata struct {
					// NextToken Supply this token in a subsequent request to fetch the next page of results.
					NextToken string `json:"nextToken"`
				} `json:"metadata"`

				// Results An array of objects that contains Application/User information and an events object with summaries by event type.
				Results []struct {
					// EventTypes An array of events that contains specific information associated with an Application/User broken down by event type.
					EventTypes []struct {
						// BillingCategory Billing category of the event type.
						BillingCategory *PlatformAnalyticEventSummaries200DataEventsSummariesResultsEventTypesBillingCategory `json:"billingCategory,omitempty"`

						// Count Count of events associated with that event type and Application/User.
						Count *int `json:"count,omitempty"`

						// EventType Event type
						EventType *string `json:"eventType,omitempty"`
					} `json:"eventTypes"`

					// Id Id of the Application/User.
					Id string `json:"id"`

					// Name Name of the Application/User.
					Name string `json:"name"`

					// Totals Totals by billing category for the event grouping.
					Totals struct {
						All         *float32 `json:"all,omitempty"`
						Integration *float32 `json:"integration,omitempty"`
						User        *float32 `json:"user,omitempty"`
					} `json:"totals"`
				} `json:"results"`

				// Start The start date and time of the requested summaries in ISO 8601 time format.
				Start time.Time `json:"start"`

				// Totals Totals by billing category for all queried events.
				Totals struct {
					All         *float32 `json:"all,omitempty"`
					Integration *float32 `json:"integration,omitempty"`
					User        *float32 `json:"user,omitempty"`
				} `json:"totals"`
				Where []struct {
					// Id Id of the item to filter by.
					Id string `json:"id"`

					// Type The type of item to filter by.
					Type PlatformAnalyticEventSummaries200DataEventsSummariesWhereType `json:"type"`
				} `json:"where"`
			} `json:"eventsSummaries"`
		} `json:"data"`
	}
}
type PlatformAnalyticEventSummaries200DataEventsSummariesGroupBy string
type PlatformAnalyticEventSummaries200DataEventsSummariesResultsEventTypesBillingCategory string
type PlatformAnalyticEventSummaries200DataEventsSummariesWhereType string

// Status returns HTTPResponse.Status
func (r PlatformAnalyticEventSummariesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlatformAnalyticEventSummariesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PlatformAnalyticReadsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The data object containing the read summaries.
		Data                 PlatformAnalyticReads_200_Data `json:"data"`
		AdditionalProperties map[string]interface{}         `json:"-"`
	}
}
type PlatformAnalyticReads_200_Data_DailyDetailedReads_Reads_Integrations struct {
	// Api Total API reads for the realm on the specified date.
	Api int `json:"api"`

	// Eoti Total reads by anonymous users for the realm on the specified date.
	Eoti int `json:"eoti"`

	// Pipelines Total pipeline reads for the realm on the specified date.
	Pipelines            int                    `json:"pipelines"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type PlatformAnalyticReads_200_Data_DailyDetailedReads_Reads struct {
	// Integrations Total integration reads for the realm on the specified date.
	Integrations PlatformAnalyticReads_200_Data_DailyDetailedReads_Reads_Integrations `json:"integrations"`

	// User Total user reads for the realm on the specified date.
	User                 int                    `json:"user"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type PlatformAnalyticReads_200_Data_DailyDetailedReads struct {
	// Date The date of the requested summary.
	Date openapi_types.Date `json:"date"`

	// Reads Total reads for the specified date.
	Reads                PlatformAnalyticReads_200_Data_DailyDetailedReads_Reads `json:"reads"`
	AdditionalProperties map[string]interface{}                                  `json:"-"`
}
type PlatformAnalyticReads_200_Data struct {
	// DailyDetailedReads Detailed read summaries for a specific date.
	DailyDetailedReads   PlatformAnalyticReads_200_Data_DailyDetailedReads `json:"dailyDetailedReads"`
	AdditionalProperties map[string]interface{}                            `json:"-"`
}

// Status returns HTTPResponse.Status
func (r PlatformAnalyticReadsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PlatformAnalyticReadsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveTrusteesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
		Failure []struct {
			// Error The error message associated with the trustee that could not be updated.
			Error *string `json:"error,omitempty"`

			// Trustee Object used for operations to read, create, or update trustees in an app.
			Trustee *struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type RemoveTrustees200FailureTrusteeType `json:"type"`
			} `json:"trustee,omitempty"`
		} `json:"failure"`

		// Success A list of trustees that have been successfully updated.
		Success []struct {
			// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
			Id string `json:"id"`

			// RoleId The ID of the role to be assigned or currently assigned to the trustee.
			RoleId int `json:"roleId"`

			// Type The type of trustee being added. This can be a user, group, or email domain group.
			Type RemoveTrustees200SuccessType `json:"type"`
		} `json:"success"`
	}
	JSON207 *struct {
		// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
		Failure []struct {
			// Error The error message associated with the trustee that could not be updated.
			Error *string `json:"error,omitempty"`

			// Trustee Object used for operations to read, create, or update trustees in an app.
			Trustee *struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type RemoveTrustees207FailureTrusteeType `json:"type"`
			} `json:"trustee,omitempty"`
		} `json:"failure"`

		// Success A list of trustees that have been successfully updated.
		Success []struct {
			// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
			Id string `json:"id"`

			// RoleId The ID of the role to be assigned or currently assigned to the trustee.
			RoleId int `json:"roleId"`

			// Type The type of trustee being added. This can be a user, group, or email domain group.
			Type RemoveTrustees207SuccessType `json:"type"`
		} `json:"success"`
	}
}
type RemoveTrustees200FailureTrusteeType string
type RemoveTrustees200SuccessType string
type RemoveTrustees207FailureTrusteeType string
type RemoveTrustees207SuccessType string

// Status returns HTTPResponse.Status
func (r RemoveTrusteesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveTrusteesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTrusteesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
		Id string `json:"id"`

		// RoleId The ID of the role to be assigned or currently assigned to the trustee.
		RoleId int `json:"roleId"`

		// Type The type of trustee being added. This can be a user, group, or email domain group.
		Type GetTrustees200Type `json:"type"`
	}
}
type GetTrustees200Type string

// Status returns HTTPResponse.Status
func (r GetTrusteesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTrusteesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTrusteesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
		Failure []struct {
			// Error The error message associated with the trustee that could not be updated.
			Error *string `json:"error,omitempty"`

			// Trustee Object used for operations to read, create, or update trustees in an app.
			Trustee *struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// OldRoleId The ID of the role to be changed for the trustee. This is used to identify the current role before updating it.
				OldRoleId int `json:"oldRoleId"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type UpdateTrustees200FailureTrusteeType `json:"type"`
			} `json:"trustee,omitempty"`
		} `json:"failure"`

		// Success A list of trustees that have been successfully updated.
		Success []struct {
			// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
			Id string `json:"id"`

			// OldRoleId The ID of the role to be changed for the trustee. This is used to identify the current role before updating it.
			OldRoleId int `json:"oldRoleId"`

			// RoleId The ID of the role to be assigned or currently assigned to the trustee.
			RoleId int `json:"roleId"`

			// Type The type of trustee being added. This can be a user, group, or email domain group.
			Type UpdateTrustees200SuccessType `json:"type"`
		} `json:"success"`
	}
	JSON207 *struct {
		// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
		Failure []struct {
			// Error The error message associated with the trustee that could not be updated.
			Error *string `json:"error,omitempty"`

			// Trustee Object used for operations to read, create, or update trustees in an app.
			Trustee *struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// OldRoleId The ID of the role to be changed for the trustee. This is used to identify the current role before updating it.
				OldRoleId int `json:"oldRoleId"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type UpdateTrustees207FailureTrusteeType `json:"type"`
			} `json:"trustee,omitempty"`
		} `json:"failure"`

		// Success A list of trustees that have been successfully updated.
		Success []struct {
			// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
			Id string `json:"id"`

			// OldRoleId The ID of the role to be changed for the trustee. This is used to identify the current role before updating it.
			OldRoleId int `json:"oldRoleId"`

			// RoleId The ID of the role to be assigned or currently assigned to the trustee.
			RoleId int `json:"roleId"`

			// Type The type of trustee being added. This can be a user, group, or email domain group.
			Type UpdateTrustees207SuccessType `json:"type"`
		} `json:"success"`
	}
}
type UpdateTrustees200FailureTrusteeType string
type UpdateTrustees200SuccessType string
type UpdateTrustees207FailureTrusteeType string
type UpdateTrustees207SuccessType string

// Status returns HTTPResponse.Status
func (r UpdateTrusteesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTrusteesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddTrusteesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
		Failure []struct {
			// Error The error message associated with the trustee that could not be updated.
			Error *string `json:"error,omitempty"`

			// Trustee Object used for operations to read, create, or update trustees in an app.
			Trustee *struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type AddTrustees200FailureTrusteeType `json:"type"`
			} `json:"trustee,omitempty"`
		} `json:"failure"`

		// Success A list of trustees that have been successfully updated.
		Success []struct {
			// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
			Id string `json:"id"`

			// RoleId The ID of the role to be assigned or currently assigned to the trustee.
			RoleId int `json:"roleId"`

			// Type The type of trustee being added. This can be a user, group, or email domain group.
			Type AddTrustees200SuccessType `json:"type"`
		} `json:"success"`
	}
	JSON207 *struct {
		// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
		Failure []struct {
			// Error The error message associated with the trustee that could not be updated.
			Error *string `json:"error,omitempty"`

			// Trustee Object used for operations to read, create, or update trustees in an app.
			Trustee *struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type AddTrustees207FailureTrusteeType `json:"type"`
			} `json:"trustee,omitempty"`
		} `json:"failure"`

		// Success A list of trustees that have been successfully updated.
		Success []struct {
			// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
			Id string `json:"id"`

			// RoleId The ID of the role to be assigned or currently assigned to the trustee.
			RoleId int `json:"roleId"`

			// Type The type of trustee being added. This can be a user, group, or email domain group.
			Type AddTrustees207SuccessType `json:"type"`
		} `json:"success"`
	}
}
type AddTrustees200FailureTrusteeType string
type AddTrustees200SuccessType string
type AddTrustees207FailureTrusteeType string
type AddTrustees207SuccessType string

// Status returns HTTPResponse.Status
func (r AddTrusteesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddTrusteesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Created *string `json:"created,omitempty"`

		// DataClassification The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
		DataClassification *string `json:"dataClassification,omitempty"`

		// DateFormat A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/docs/how-to-localize-dates) to set the app's date format.
		DateFormat *string `json:"dateFormat,omitempty"`

		// Description The description for the app. If this property is left out, the app description will be blank.
		Description *string `json:"description,omitempty"`

		// HasEveryoneOnTheInternet Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/docs/sharing-apps-publicly)
		HasEveryoneOnTheInternet *bool `json:"hasEveryoneOnTheInternet,omitempty"`

		// Id The unique identifier for this application.
		Id *string `json:"id,omitempty"`

		// MemoryInfo Application memory info
		MemoryInfo *struct {
			// EstMemory The estimated memory of this application in gigabytes
			EstMemory *float32 `json:"estMemory,omitempty"`

			// EstMemoryInclDependentApps The estimated memory of this application and all dependent applications in gigabytes
			EstMemoryInclDependentApps *float32 `json:"estMemoryInclDependentApps,omitempty"`
		} `json:"memoryInfo,omitempty"`

		// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
		Name string `json:"name"`

		// SecurityProperties Security properties of the application
		SecurityProperties *CreateApp_200_SecurityProperties `json:"securityProperties,omitempty"`

		// TimeZone A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/docs/set-the-time-zone-for-both-the-application-and-the-account) to set the application's time zone.
		TimeZone *string `json:"timeZone,omitempty"`

		// Updated The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Updated *string `json:"updated,omitempty"`

		// Variables The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
		Variables            *[]CreateApp_200_Variables_Item `json:"variables,omitempty"`
		AdditionalProperties map[string]interface{}          `json:"-"`
	}
}
type CreateApp_200_SecurityProperties struct {
	// AllowClone Allow users who are not administrators to copy
	AllowClone *bool `json:"allowClone,omitempty"`

	// AllowExport Allow users who are not administrators to export data
	AllowExport *bool `json:"allowExport,omitempty"`

	// EnableAppTokens Require Application Tokens
	EnableAppTokens *bool `json:"enableAppTokens,omitempty"`

	// HideFromPublic Hide from public application searches
	HideFromPublic *bool `json:"hideFromPublic,omitempty"`

	// MustBeRealmApproved Only "approved" users may access this application
	MustBeRealmApproved *bool `json:"mustBeRealmApproved,omitempty"`

	// UseIPFilter Only users logging in from "approved" IP addresses may access this application
	UseIPFilter          *bool                  `json:"useIPFilter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type CreateApp_200_Variables_Item struct {
	// Name Variable name.
	Name *string `json:"name,omitempty"`

	// Value Variable value.
	Value                *string                `json:"value,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r CreateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeletedAppId An ID of deleted application.
		DeletedAppId         *string                `json:"deletedAppId,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AncestorId The id of the app from which this app was copied
		AncestorId *string `json:"ancestorId,omitempty"`

		// Created The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Created *string `json:"created,omitempty"`

		// DataClassification The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
		DataClassification *string `json:"dataClassification,omitempty"`

		// DateFormat A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app's date format.
		DateFormat *string `json:"dateFormat,omitempty"`

		// Description The description for the app. If this property is left out, the app description will be blank.
		Description *string `json:"description,omitempty"`

		// HasEveryoneOnTheInternet Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)
		HasEveryoneOnTheInternet *bool `json:"hasEveryoneOnTheInternet,omitempty"`

		// Id The unique identifier for this application.
		Id *string `json:"id,omitempty"`

		// MemoryInfo Application memory info
		MemoryInfo *struct {
			// EstMemory The estimated memory of this application in gigabytes
			EstMemory *float32 `json:"estMemory,omitempty"`

			// EstMemoryInclDependentApps The estimated memory of this application and all dependent applications in gigabytes
			EstMemoryInclDependentApps *float32 `json:"estMemoryInclDependentApps,omitempty"`
		} `json:"memoryInfo,omitempty"`

		// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
		Name string `json:"name"`

		// SecurityProperties Security properties of the application
		SecurityProperties *GetApp_200_SecurityProperties `json:"securityProperties,omitempty"`

		// TimeZone A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application's time zone.
		TimeZone *string `json:"timeZone,omitempty"`

		// Updated The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Updated *string `json:"updated,omitempty"`

		// Variables The app variables. See [About Application Variables](https://help.quickbase.com/docs/creating-and-using-application-variables)
		Variables            *[]GetApp_200_Variables_Item `json:"variables,omitempty"`
		AdditionalProperties map[string]interface{}       `json:"-"`
	}
}
type GetApp_200_SecurityProperties struct {
	// AllowClone Allow users who are not administrators to copy
	AllowClone *bool `json:"allowClone,omitempty"`

	// AllowExport Allow users who are not administrators to export data
	AllowExport *bool `json:"allowExport,omitempty"`

	// EnableAppTokens Require Application Tokens
	EnableAppTokens *bool `json:"enableAppTokens,omitempty"`

	// HideFromPublic Hide from public application searches
	HideFromPublic *bool `json:"hideFromPublic,omitempty"`

	// MustBeRealmApproved Only "approved" users may access this application
	MustBeRealmApproved *bool `json:"mustBeRealmApproved,omitempty"`

	// UseIPFilter Only users logging in from "approved" IP addresses may access this application
	UseIPFilter          *bool                  `json:"useIPFilter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetApp_200_Variables_Item struct {
	// Name Variable name.
	Name *string `json:"name,omitempty"`

	// Value Variable value.
	Value                *string                `json:"value,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AncestorId The id of the app from which this app was copied
		AncestorId *string `json:"ancestorId,omitempty"`

		// Created The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Created *string `json:"created,omitempty"`

		// DataClassification The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
		DataClassification *string `json:"dataClassification,omitempty"`

		// DateFormat A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app's date format.
		DateFormat *string `json:"dateFormat,omitempty"`

		// Description The description for the app. If this property is left out, the app description will be blank.
		Description *string `json:"description,omitempty"`

		// HasEveryoneOnTheInternet Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)
		HasEveryoneOnTheInternet *bool `json:"hasEveryoneOnTheInternet,omitempty"`

		// Id The unique identifier for this application.
		Id *string `json:"id,omitempty"`

		// MemoryInfo Application memory info
		MemoryInfo *struct {
			// EstMemory The estimated memory of this application in gigabytes
			EstMemory *float32 `json:"estMemory,omitempty"`

			// EstMemoryInclDependentApps The estimated memory of this application and all dependent applications in gigabytes
			EstMemoryInclDependentApps *float32 `json:"estMemoryInclDependentApps,omitempty"`
		} `json:"memoryInfo,omitempty"`

		// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
		Name string `json:"name"`

		// SecurityProperties Security properties of the application
		SecurityProperties *UpdateApp_200_SecurityProperties `json:"securityProperties,omitempty"`

		// TimeZone A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application's time zone.
		TimeZone *string `json:"timeZone,omitempty"`

		// Updated The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Updated *string `json:"updated,omitempty"`

		// Variables The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
		Variables            *[]UpdateApp_200_Variables_Item `json:"variables,omitempty"`
		AdditionalProperties map[string]interface{}          `json:"-"`
	}
}
type UpdateApp_200_SecurityProperties struct {
	// AllowClone Allow users who are not administrators to copy
	AllowClone *bool `json:"allowClone,omitempty"`

	// AllowExport Allow users who are not administrators to export data
	AllowExport *bool `json:"allowExport,omitempty"`

	// EnableAppTokens Require Application Tokens
	EnableAppTokens *bool `json:"enableAppTokens,omitempty"`

	// HideFromPublic Hide from public application searches
	HideFromPublic *bool `json:"hideFromPublic,omitempty"`

	// MustBeRealmApproved Only "approved" users may access this application
	MustBeRealmApproved *bool `json:"mustBeRealmApproved,omitempty"`

	// UseIPFilter Only users logging in from "approved" IP addresses may access this application
	UseIPFilter          *bool                  `json:"useIPFilter,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type UpdateApp_200_Variables_Item struct {
	// Name Variable name.
	Name *string `json:"name,omitempty"`

	// Value Variable value.
	Value                *string                `json:"value,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r UpdateAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CopyAppResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AncestorId The id of the app from which this app was copied
		AncestorId *string `json:"ancestorId,omitempty"`

		// Created The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Created *string `json:"created,omitempty"`

		// DataClassification The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
		DataClassification *string `json:"dataClassification,omitempty"`

		// DateFormat A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app's date format.
		DateFormat *string `json:"dateFormat,omitempty"`

		// Description The description for the app
		Description *string `json:"description,omitempty"`

		// HasEveryoneOnTheInternet Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)
		HasEveryoneOnTheInternet *bool `json:"hasEveryoneOnTheInternet,omitempty"`

		// Id The unique identifier for this application.
		Id *string `json:"id,omitempty"`

		// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
		Name string `json:"name"`

		// TimeZone A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application's time zone.
		TimeZone *string `json:"timeZone,omitempty"`

		// Updated The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Updated *string `json:"updated,omitempty"`

		// Variables The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
		Variables            *[]CopyApp_200_Variables_Item `json:"variables,omitempty"`
		AdditionalProperties map[string]interface{}        `json:"-"`
	}
}
type CopyApp_200_Variables_Item struct {
	// Name Variable name.
	Name *string `json:"name,omitempty"`

	// Value Variable value.
	Value                *string                `json:"value,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r CopyAppResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CopyAppResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GetAppEvents_200_Item
}
type GetAppEvents_200_Owner struct {
	// Email User email.
	Email *string `json:"email,omitempty"`

	// Id User Id.
	Id *string `json:"id,omitempty"`

	// Name User full name.
	Name *string `json:"name,omitempty"`

	// UserName User Name as updated in user properties. Optional, appears if not the same as user email.
	UserName             *string                `json:"userName,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetAppEvents200Type string
type GetAppEvents_200_Item struct {
	// IsActive Indication of whether current event is active.
	IsActive *bool `json:"isActive,omitempty"`

	// Name The name of the event. This property is not returned for automations.
	Name *string `json:"name,omitempty"`

	// Owner The user that owns the event.
	Owner *GetAppEvents_200_Owner `json:"owner,omitempty"`

	// TableId The unique identifier of the table to which event belongs to.
	TableId *string `json:"tableId,omitempty"`

	// Type Type of an event.
	Type *GetAppEvents200Type `json:"type,omitempty"`

	// Url The url to automation that can be accessed from the browser. Only returned for automations.
	Url                  *string                `json:"url,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetAppEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GetRoles_200_Item
}
type GetRoles200AccessType string
type GetRoles_200_Access struct {
	// Id The ID of the access type the role is given. (0 = None, 1 = Administrator, 2 = Basic Access with Share, 3 = Basic Access, 4 = Partial Administrator).
	Id *int `json:"id,omitempty"`

	// Type The type of access the role is given.
	Type                 *GetRoles200AccessType `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetRoles_200_Item struct {
	// Access The role access properties.
	Access *GetRoles_200_Access `json:"access,omitempty"`

	// Id The role id.
	Id *int `json:"id,omitempty"`

	// Name The role name.
	Name                 *string                `json:"name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AuditResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Events All events of the audit log.
		Events *[]Audit_200_Events_Item `json:"events,omitempty"`

		// NextToken Token to fetch the next 1000 logs.
		NextToken *string `json:"nextToken,omitempty"`

		// QueryId Query id of the requested audit log.
		QueryId              string                 `json:"queryId"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
	JSON202 *struct {
		// QueryId Query id of the requested audit log.
		QueryId              string                 `json:"queryId"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type Audit_200_Events_PayloadChanges_Changes struct {
	// Current The current value of the fields that have been changed.
	Current []interface{} `json:"current"`

	// Fields The list of fields and their types that have been changed.
	Fields []interface{} `json:"fields"`

	// Previous The previous value of the fields that have been changed.
	Previous             []interface{}          `json:"previous"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type Audit_200_Events_PayloadChanges struct {
	// ChangeType The change type that occured for a record. Could be one of add, edit, delete.
	ChangeType string `json:"changeType"`

	// Changes An object describing the changes that occured on record changes.
	Changes Audit_200_Events_PayloadChanges_Changes `json:"changes"`

	// Rid The recordId that has been edited.
	Rid int `json:"rid"`

	// Type A placeholder for type changes.
	Type                 string                 `json:"type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type Audit_200_Events_Item struct {
	// Application UI for user interface or API for an API call.
	Application string `json:"application"`

	// Description A brief description of the action that you can click to see additional details.
	Description string `json:"description"`

	// Email User's email address.
	Email string `json:"email"`

	// Firstname User's first name.
	Firstname string `json:"firstname"`

	// Id Log ID.
	Id string `json:"id"`

	// Ipaddress The IP address the action was taken from.
	Ipaddress string `json:"ipaddress"`

	// Lastname User's last name.
	Lastname string `json:"lastname"`

	// PayloadChanges The data changes that have occured to a field that has been marked as audited.
	PayloadChanges *Audit_200_Events_PayloadChanges `json:"payloadChanges,omitempty"`

	// Time Exact time the action was taken, including date, and time with hour, minutes and seconds. Time zone is the browser time zone.
	Time string `json:"time"`

	// Topic What action was taken, such as log in, create app, report access, or table search.
	Topic string `json:"topic"`

	// Useragent The browser and OS the action was taken from.
	Useragent            string                 `json:"useragent"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r AuditResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AuditResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExchangeSsoTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccessToken The security token issued by the authorization server in response to the token exchange request. The identifier `access_token` is used for historical reasons and the issued token need not be an OAuth access token.
		AccessToken *string `json:"access_token,omitempty"`

		// IssuedTokenType An identifier for the representation of the issued security token.
		IssuedTokenType *ExchangeSsoToken200IssuedTokenType `json:"issued_token_type,omitempty"`

		// TokenType Will always return `N_A`
		TokenType            *ExchangeSsoToken200TokenType `json:"token_type,omitempty"`
		AdditionalProperties map[string]interface{}        `json:"-"`
	}
}
type ExchangeSsoToken200IssuedTokenType string
type ExchangeSsoToken200TokenType string

// Status returns HTTPResponse.Status
func (r ExchangeSsoTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExchangeSsoTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTempTokenDBIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// TemporaryAuthorization Temporary authorization token.
		TemporaryAuthorization *string                `json:"temporaryAuthorization,omitempty"`
		AdditionalProperties   map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTempTokenDBIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTempTokenDBIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateDocumentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ContentType The document content type.
		ContentType *string `json:"contentType,omitempty"`

		// Data Base64 encoded file content.
		Data *string `json:"data,omitempty"`

		// FileName The file name.
		FileName             *string                `json:"fileName,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r GenerateDocumentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateDocumentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeletedFieldIds List of field IDs to were deleted.
		DeletedFieldIds []int `json:"deletedFieldIds"`

		// Errors List of errors found.
		Errors               []string               `json:"errors"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GetFields_200_Item
}
type GetFields200PropertiesCompositeFields0 = int
type GetFields200PropertiesCompositeFields1 = map[string]interface{}
type GetFields_200_Properties_CompositeFields_Item struct {
	union json.RawMessage
}
type GetFields200PropertiesCurrencyFormat string
type GetFields200PropertiesSummaryFunction string
type GetFields200PropertiesVersionMode string
type GetFields_200_Properties struct {
	// Abbreviate Don't show the URL protocol when showing the URL.
	Abbreviate *bool `json:"abbreviate,omitempty"`

	// AllowHTML Whether this field allows html.
	AllowHTML *bool `json:"allowHTML,omitempty"`

	// AllowMentions If someone can @mention users in the rich text field to generate an email notification.
	AllowMentions *bool `json:"allowMentions,omitempty"`

	// AllowNewChoices Indicates if users can add new choices to a selection list.
	AllowNewChoices *bool `json:"allowNewChoices,omitempty"`

	// AppearsAs The link text, if empty, the url will be used as link text.
	AppearsAs *string `json:"appearsAs,omitempty"`

	// AppendOnly Whether this field is append only.
	AppendOnly *bool `json:"appendOnly,omitempty"`

	// AutoSave Whether the link field will auto save.
	AutoSave *bool `json:"autoSave,omitempty"`

	// BlankIsZero Whether a blank value is treated the same as 0 in calculations within the product.
	BlankIsZero *bool `json:"blankIsZero,omitempty"`

	// CarryChoices Whether the field should carry its multiple choice fields when copied.
	CarryChoices *bool `json:"carryChoices,omitempty"`

	// Choices An array of entries that exist for a field that offers choices to the user.
	Choices *[]string `json:"choices,omitempty"`

	// ChoicesLuid List of user choices.
	ChoicesLuid *[]string `json:"choicesLuid,omitempty"`

	// CommaStart The number of digits before commas display in the product, when applicable.
	CommaStart *int `json:"commaStart,omitempty"`

	// Comments The comments entered on the field properties by an administrator.
	Comments *string `json:"comments,omitempty"`

	// CompositeFields An array of the fields that make up a composite field (e.g., address).
	CompositeFields *[]GetFields_200_Properties_CompositeFields_Item `json:"compositeFields,omitempty"`

	// CoverText An alternate user friendly text that can be used to display a link in the browser.
	CoverText *string `json:"coverText,omitempty"`

	// CurrencyFormat The currency format used when displaying field values within the product.
	CurrencyFormat *GetFields200PropertiesCurrencyFormat `json:"currencyFormat,omitempty"`

	// CurrencySymbol The current symbol used when displaying field values within the product.
	CurrencySymbol *string `json:"currencySymbol,omitempty"`

	// DecimalPlaces The number of decimal places displayed in the product for this field.
	DecimalPlaces *int `json:"decimalPlaces,omitempty"`

	// DefaultCountryCode Controls the default country shown on international phone widgets on forms. Country code should be entered in the ISO 3166-1 alpha-2 format.
	DefaultCountryCode *string `json:"defaultCountryCode,omitempty"`

	// DefaultDomain Default email domain.
	DefaultDomain *string `json:"defaultDomain,omitempty"`

	// DefaultKind The user default type.
	DefaultKind *string `json:"defaultKind,omitempty"`

	// DefaultToday Indicates if the field value is defaulted today for new records.
	DefaultToday *bool `json:"defaultToday,omitempty"`

	// DefaultValue The default value configured for a field when a new record is added.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// DefaultValueLuid Default user id value.
	DefaultValueLuid *int `json:"defaultValueLuid,omitempty"`

	// DisplayAsLink Indicates if a field that is part of the relationship should be shown as a hyperlink to the parent record within the product.
	DisplayAsLink *bool `json:"displayAsLink,omitempty"`

	// DisplayCheckboxAsText Indicates whether the checkbox values will be shown as text in reports.
	DisplayCheckboxAsText *bool `json:"displayCheckboxAsText,omitempty"`

	// DisplayDayOfWeek Indicates whether to display the day of the week within the product.
	DisplayDayOfWeek *bool `json:"displayDayOfWeek,omitempty"`

	// DisplayEmail How the email is displayed.
	DisplayEmail *string `json:"displayEmail,omitempty"`

	// DisplayMonth How to display months.
	DisplayMonth *string `json:"displayMonth,omitempty"`

	// DisplayRelative Whether to display time as relative.
	DisplayRelative *bool `json:"displayRelative,omitempty"`

	// DisplayTime Indicates whether to display the time, in addition to the date.
	DisplayTime *bool `json:"displayTime,omitempty"`

	// DisplayTimezone Indicates whether to display the timezone within the product.
	DisplayTimezone *bool `json:"displayTimezone,omitempty"`

	// DisplayUser The configured option for how users display within the product.
	DisplayUser *string `json:"displayUser,omitempty"`

	// DoesAverage Whether this field averages in reports within the product.
	DoesAverage *bool `json:"doesAverage,omitempty"`

	// DoesTotal Whether this field totals in reports within the product.
	DoesTotal *bool `json:"doesTotal,omitempty"`

	// DurationField The duration field id.
	DurationField *int `json:"durationField,omitempty"`

	// Exact Whether an exact match is required for a report link.
	Exact *bool `json:"exact,omitempty"`

	// ForeignKey Indicates if the field is a foreign key (or reference field) in a relationship.
	ForeignKey *bool `json:"foreignKey,omitempty"`

	// Format The format to display time.
	Format *int `json:"format,omitempty"`

	// Formula The formula of the field as configured in Quickbase.
	Formula *string `json:"formula,omitempty"`

	// HasExtension Whether this field has a phone extension.
	HasExtension *bool `json:"hasExtension,omitempty"`

	// Hours24 Indicates whether or not to display time in the 24-hour format within the product.
	Hours24 *bool `json:"hours24,omitempty"`

	// LinkText The configured text value that replaces the URL that users see within the product.
	LinkText *string `json:"linkText,omitempty"`

	// LookupReferenceFieldId The id of the field that is the reference in the relationship for this lookup.
	LookupReferenceFieldId *int `json:"lookupReferenceFieldId,omitempty"`

	// LookupTargetFieldId The id of the field that is the target on the master table for this lookup.
	LookupTargetFieldId *int `json:"lookupTargetFieldId,omitempty"`

	// MasterChoiceFieldId The id of the field that is the reference in the relationship.
	MasterChoiceFieldId *int `json:"masterChoiceFieldId,omitempty"`

	// MasterChoiceTableId The id of the table that is the master in this relationship.
	MasterChoiceTableId *string `json:"masterChoiceTableId,omitempty"`

	// MasterTableTag The table alias for the master table in the relationship this field is part of.
	MasterTableTag *string `json:"masterTableTag,omitempty"`

	// MaxLength The maximum number of characters allowed for entry in Quickbase for this field.
	MaxLength *int `json:"maxLength,omitempty"`

	// MaxVersions The maximum number of versions configured for a file attachment.
	MaxVersions *int `json:"maxVersions,omitempty"`

	// NumLines The number of lines shown in Quickbase for this text field.
	NumLines *int `json:"numLines,omitempty"`

	// NumberFormat The format used for displaying numeric values in the product (decimal, separators, digit group).
	NumberFormat *int `json:"numberFormat,omitempty"`

	// ParentFieldId The id of the parent composite field, when applicable.
	ParentFieldId *int `json:"parentFieldId,omitempty"`

	// PostTempToken POSTs a temporary token to the first URL when clicked by a user. [Learn more](https://help.quickbase.com/docs/post-temporary-token-from-a-quickbase-field)
	PostTempToken *bool `json:"postTempToken,omitempty"`

	// SeeVersions Indicates if the user can see other versions, aside from the most recent, of a file attachment within the product.
	SeeVersions *bool `json:"seeVersions,omitempty"`

	// SnapFieldId The id of the field that is used to snapshot values from, when applicable.
	SnapFieldId *int `json:"snapFieldId,omitempty"`

	// SortAlpha Whether to sort alphabetically, default sort is by record ID.
	SortAlpha *bool `json:"sortAlpha,omitempty"`

	// SortAsGiven Indicates if the listed entries sort as entered vs alphabetically.
	SortAsGiven *bool `json:"sortAsGiven,omitempty"`

	// SourceFieldId The id of the source field.
	SourceFieldId *int `json:"sourceFieldId,omitempty"`

	// StartField The start field id.
	StartField *int `json:"startField,omitempty"`

	// SummaryFunction The summary accumulation function type.
	SummaryFunction *GetFields200PropertiesSummaryFunction `json:"summaryFunction,omitempty"`

	// SummaryReferenceFieldId The id of the field that is the reference in the relationship for this summary.
	SummaryReferenceFieldId *int64 `json:"summaryReferenceFieldId,omitempty"`

	// SummaryTargetFieldId The id of the field that is used to aggregate values from the child, when applicable. This displays 0 if the summary function doesn't require a field selection (like count).
	SummaryTargetFieldId *int `json:"summaryTargetFieldId,omitempty"`

	// TargetFieldId The id of the target field.
	TargetFieldId *int `json:"targetFieldId,omitempty"`

	// TargetTableId The id of the target table.
	TargetTableId *string `json:"targetTableId,omitempty"`

	// TargetTableName The field's target table name.
	TargetTableName *string `json:"targetTableName,omitempty"`

	// Units The units label.
	Units *string `json:"units,omitempty"`

	// UseI18NFormat Whether phone numbers should be in E.164 standard international format.
	UseI18NFormat *bool `json:"useI18NFormat,omitempty"`

	// UseNewWindow Indicates if the URL should open a new window when a user clicks it within the product.
	UseNewWindow *bool `json:"useNewWindow,omitempty"`

	// VersionMode Version modes for files. Keep all versions vs keep last version.
	VersionMode *GetFields200PropertiesVersionMode `json:"versionMode,omitempty"`

	// Width The field's html input width in the product.
	Width *int `json:"width,omitempty"`

	// WorkWeek The work week type.
	WorkWeek *int `json:"workWeek,omitempty"`

	// XmlTag The field's xml tag.
	XmlTag               *string                `json:"xmlTag,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFields_200_Item struct {
	// AppearsByDefault Indicates if the field is marked as a default in reports.
	AppearsByDefault *bool `json:"appearsByDefault,omitempty"`

	// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs.
	Audited *bool `json:"audited,omitempty"`

	// Bold Indicates if the field is configured to display in bold in the product.
	Bold *bool `json:"bold,omitempty"`

	// DoesDataCopy Indicates if the field data will copy when a user copies the record.
	DoesDataCopy *bool `json:"doesDataCopy,omitempty"`

	// FieldHelp The configured help text shown to users within the product.
	FieldHelp *string `json:"fieldHelp,omitempty"`

	// FieldType The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
	FieldType *string `json:"fieldType,omitempty"`

	// FindEnabled Indicates if the field is marked as searchable.
	FindEnabled *bool `json:"findEnabled,omitempty"`

	// Id The id of the field, unique to this table.
	Id int64 `json:"id"`

	// Label The label (name) of the field.
	Label *string `json:"label,omitempty"`

	// Mode For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
	Mode *string `json:"mode,omitempty"`

	// NoWrap Indicates if the field is configured to not wrap when displayed in the product.
	NoWrap *bool `json:"noWrap,omitempty"`

	// Permissions Field Permissions for different roles.
	Permissions *[]struct {
		// PermissionType The permission given to the role for this field
		PermissionType *string `json:"permissionType,omitempty"`

		// Role The role associated with a given permission for the field
		Role *string `json:"role,omitempty"`

		// RoleId The Id of the given role
		RoleId *int `json:"roleId,omitempty"`
	} `json:"permissions,omitempty"`

	// Properties Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
	Properties *GetFields_200_Properties `json:"properties,omitempty"`

	// Required Indicates if the field is marked required.
	Required *bool `json:"required,omitempty"`

	// Unique Indicates if the field is marked unique.
	Unique               *bool                  `json:"unique,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AppearsByDefault Indicates if the field is marked as a default in reports.
		AppearsByDefault *bool `json:"appearsByDefault,omitempty"`

		// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs.
		Audited *bool `json:"audited,omitempty"`

		// Bold Indicates if the field is configured to display in bold in the product.
		Bold *bool `json:"bold,omitempty"`

		// DoesDataCopy Indicates if the field data will copy when a user copies the record.
		DoesDataCopy *bool `json:"doesDataCopy,omitempty"`

		// FieldHelp The configured help text shown to users within the product.
		FieldHelp *string `json:"fieldHelp,omitempty"`

		// FieldType The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
		FieldType *string `json:"fieldType,omitempty"`

		// FindEnabled Indicates if the field is marked as searchable.
		FindEnabled *bool `json:"findEnabled,omitempty"`

		// Id The id of the field, unique to this table.
		Id int64 `json:"id"`

		// Label The label (name) of the field.
		Label *string `json:"label,omitempty"`

		// Mode For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
		Mode *string `json:"mode,omitempty"`

		// NoWrap Indicates if the field is configured to not wrap when displayed in the product.
		NoWrap *bool `json:"noWrap,omitempty"`

		// Permissions Field Permissions for different roles.
		Permissions *[]struct {
			// PermissionType The permission given to the role for this field
			PermissionType *string `json:"permissionType,omitempty"`

			// Role The role associated with a given permission for the field
			Role *string `json:"role,omitempty"`

			// RoleId The Id of the given role
			RoleId *int `json:"roleId,omitempty"`
		} `json:"permissions,omitempty"`

		// Properties Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
		Properties *CreateField_200_Properties `json:"properties,omitempty"`

		// Required Indicates if the field is marked required.
		Required *bool `json:"required,omitempty"`

		// Unique Indicates if the field is marked unique.
		Unique               *bool                  `json:"unique,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type CreateField200PropertiesCompositeFields0 = int
type CreateField200PropertiesCompositeFields1 = map[string]interface{}
type CreateField_200_Properties_CompositeFields_Item struct {
	union json.RawMessage
}
type CreateField200PropertiesCurrencyFormat string
type CreateField200PropertiesSummaryFunction string
type CreateField200PropertiesVersionMode string
type CreateField_200_Properties struct {
	// Abbreviate Don't show the URL protocol when showing the URL.
	Abbreviate *bool `json:"abbreviate,omitempty"`

	// AllowHTML Whether this field allows html.
	AllowHTML *bool `json:"allowHTML,omitempty"`

	// AllowMentions If someone can @mention users in the rich text field to generate an email notification.
	AllowMentions *bool `json:"allowMentions,omitempty"`

	// AllowNewChoices Indicates if users can add new choices to a selection list.
	AllowNewChoices *bool `json:"allowNewChoices,omitempty"`

	// AppearsAs The link text, if empty, the url will be used as link text.
	AppearsAs *string `json:"appearsAs,omitempty"`

	// AppendOnly Whether this field is append only.
	AppendOnly *bool `json:"appendOnly,omitempty"`

	// AutoSave Whether the link field will auto save.
	AutoSave *bool `json:"autoSave,omitempty"`

	// BlankIsZero Whether a blank value is treated the same as 0 in calculations within the product.
	BlankIsZero *bool `json:"blankIsZero,omitempty"`

	// CarryChoices Whether the field should carry its multiple choice fields when copied.
	CarryChoices *bool `json:"carryChoices,omitempty"`

	// Choices An array of entries that exist for a field that offers choices to the user.
	Choices *[]string `json:"choices,omitempty"`

	// ChoicesLuid List of user choices.
	ChoicesLuid *[]string `json:"choicesLuid,omitempty"`

	// CommaStart The number of digits before commas display in the product, when applicable.
	CommaStart *int `json:"commaStart,omitempty"`

	// Comments The comments entered on the field properties by an administrator.
	Comments *string `json:"comments,omitempty"`

	// CompositeFields An array of the fields that make up a composite field (e.g., address).
	CompositeFields *[]CreateField_200_Properties_CompositeFields_Item `json:"compositeFields,omitempty"`

	// CoverText An alternate user friendly text that can be used to display a link in the browser.
	CoverText *string `json:"coverText,omitempty"`

	// CurrencyFormat The currency format used when displaying field values within the product.
	CurrencyFormat *CreateField200PropertiesCurrencyFormat `json:"currencyFormat,omitempty"`

	// CurrencySymbol The current symbol used when displaying field values within the product.
	CurrencySymbol *string `json:"currencySymbol,omitempty"`

	// DecimalPlaces The number of decimal places displayed in the product for this field.
	DecimalPlaces *int `json:"decimalPlaces,omitempty"`

	// DefaultCountryCode Controls the default country shown on international phone widgets on forms. Country code should be entered in the ISO 3166-1 alpha-2 format.
	DefaultCountryCode *string `json:"defaultCountryCode,omitempty"`

	// DefaultDomain Default email domain.
	DefaultDomain *string `json:"defaultDomain,omitempty"`

	// DefaultKind The user default type.
	DefaultKind *string `json:"defaultKind,omitempty"`

	// DefaultToday Indicates if the field value is defaulted today for new records.
	DefaultToday *bool `json:"defaultToday,omitempty"`

	// DefaultValue The default value configured for a field when a new record is added.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// DefaultValueLuid Default user id value.
	DefaultValueLuid *int `json:"defaultValueLuid,omitempty"`

	// DisplayAsLink Indicates if a field that is part of the relationship should be shown as a hyperlink to the parent record within the product.
	DisplayAsLink *bool `json:"displayAsLink,omitempty"`

	// DisplayCheckboxAsText Indicates whether the checkbox values will be shown as text in reports.
	DisplayCheckboxAsText *bool `json:"displayCheckboxAsText,omitempty"`

	// DisplayDayOfWeek Indicates whether to display the day of the week within the product.
	DisplayDayOfWeek *bool `json:"displayDayOfWeek,omitempty"`

	// DisplayEmail How the email is displayed.
	DisplayEmail *string `json:"displayEmail,omitempty"`

	// DisplayMonth How to display months.
	DisplayMonth *string `json:"displayMonth,omitempty"`

	// DisplayRelative Whether to display time as relative.
	DisplayRelative *bool `json:"displayRelative,omitempty"`

	// DisplayTime Indicates whether to display the time, in addition to the date.
	DisplayTime *bool `json:"displayTime,omitempty"`

	// DisplayTimezone Indicates whether to display the timezone within the product.
	DisplayTimezone *bool `json:"displayTimezone,omitempty"`

	// DisplayUser The configured option for how users display within the product.
	DisplayUser *string `json:"displayUser,omitempty"`

	// DoesAverage Whether this field averages in reports within the product.
	DoesAverage *bool `json:"doesAverage,omitempty"`

	// DoesTotal Whether this field totals in reports within the product.
	DoesTotal *bool `json:"doesTotal,omitempty"`

	// DurationField The duration field id.
	DurationField *int `json:"durationField,omitempty"`

	// Exact Whether an exact match is required for a report link.
	Exact *bool `json:"exact,omitempty"`

	// ForeignKey Indicates if the field is a foreign key (or reference field) in a relationship.
	ForeignKey *bool `json:"foreignKey,omitempty"`

	// Format The format to display time.
	Format *int `json:"format,omitempty"`

	// Formula The formula of the field as configured in Quickbase.
	Formula *string `json:"formula,omitempty"`

	// HasExtension Whether this field has a phone extension.
	HasExtension *bool `json:"hasExtension,omitempty"`

	// Hours24 Indicates whether or not to display time in the 24-hour format within the product.
	Hours24 *bool `json:"hours24,omitempty"`

	// LinkText The configured text value that replaces the URL that users see within the product.
	LinkText *string `json:"linkText,omitempty"`

	// LookupReferenceFieldId The id of the field that is the reference in the relationship for this lookup.
	LookupReferenceFieldId *int `json:"lookupReferenceFieldId,omitempty"`

	// LookupTargetFieldId The id of the field that is the target on the master table for this lookup.
	LookupTargetFieldId *int `json:"lookupTargetFieldId,omitempty"`

	// MasterChoiceFieldId The id of the field that is the reference in the relationship.
	MasterChoiceFieldId *int `json:"masterChoiceFieldId,omitempty"`

	// MasterChoiceTableId The id of the table that is the master in this relationship.
	MasterChoiceTableId *string `json:"masterChoiceTableId,omitempty"`

	// MasterTableTag The table alias for the master table in the relationship this field is part of.
	MasterTableTag *string `json:"masterTableTag,omitempty"`

	// MaxLength The maximum number of characters allowed for entry in Quickbase for this field.
	MaxLength *int `json:"maxLength,omitempty"`

	// MaxVersions The maximum number of versions configured for a file attachment.
	MaxVersions *int `json:"maxVersions,omitempty"`

	// NumLines The number of lines shown in Quickbase for this text field.
	NumLines *int `json:"numLines,omitempty"`

	// NumberFormat The format used for displaying numeric values in the product (decimal, separators, digit group).
	NumberFormat *int `json:"numberFormat,omitempty"`

	// ParentFieldId The id of the parent composite field, when applicable.
	ParentFieldId *int `json:"parentFieldId,omitempty"`

	// PostTempToken POSTs a temporary token to the first URL when clicked by a user. [Learn more](https://help.quickbase.com/docs/post-temporary-token-from-a-quickbase-field)
	PostTempToken *bool `json:"postTempToken,omitempty"`

	// SeeVersions Indicates if the user can see other versions, aside from the most recent, of a file attachment within the product.
	SeeVersions *bool `json:"seeVersions,omitempty"`

	// SnapFieldId The id of the field that is used to snapshot values from, when applicable.
	SnapFieldId *int `json:"snapFieldId,omitempty"`

	// SortAlpha Whether to sort alphabetically, default sort is by record ID.
	SortAlpha *bool `json:"sortAlpha,omitempty"`

	// SortAsGiven Indicates if the listed entries sort as entered vs alphabetically.
	SortAsGiven *bool `json:"sortAsGiven,omitempty"`

	// SourceFieldId The id of the source field.
	SourceFieldId *int `json:"sourceFieldId,omitempty"`

	// StartField The start field id.
	StartField *int `json:"startField,omitempty"`

	// SummaryFunction The summary accumulation function type.
	SummaryFunction *CreateField200PropertiesSummaryFunction `json:"summaryFunction,omitempty"`

	// SummaryReferenceFieldId The id of the field that is the reference in the relationship for this summary.
	SummaryReferenceFieldId *int64 `json:"summaryReferenceFieldId,omitempty"`

	// SummaryTargetFieldId The id of the field that is used to aggregate values from the child, when applicable. This displays 0 if the summary function doesn't require a field selection (like count).
	SummaryTargetFieldId *int `json:"summaryTargetFieldId,omitempty"`

	// TargetFieldId The id of the target field.
	TargetFieldId *int `json:"targetFieldId,omitempty"`

	// TargetTableId The id of the target table.
	TargetTableId *string `json:"targetTableId,omitempty"`

	// TargetTableName The field's target table name.
	TargetTableName *string `json:"targetTableName,omitempty"`

	// Units The units label.
	Units *string `json:"units,omitempty"`

	// UseI18NFormat Whether phone numbers should be in E.164 standard international format.
	UseI18NFormat *bool `json:"useI18NFormat,omitempty"`

	// UseNewWindow Indicates if the URL should open a new window when a user clicks it within the product.
	UseNewWindow *bool `json:"useNewWindow,omitempty"`

	// VersionMode Version modes for files. Keep all versions vs keep last version.
	VersionMode *CreateField200PropertiesVersionMode `json:"versionMode,omitempty"`

	// Width The field's html input width in the product.
	Width *int `json:"width,omitempty"`

	// WorkWeek The work week type.
	WorkWeek *int `json:"workWeek,omitempty"`

	// XmlTag The field's xml tag.
	XmlTag               *string                `json:"xmlTag,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r CreateFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFieldsUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GetFieldsUsage_200_Item
}
type GetFieldsUsage_200_Field struct {
	// Id Field id.
	Id int `json:"id"`

	// Name Field name.
	Name string `json:"name"`

	// Type Field type.
	Type                 string                 `json:"type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_Actions struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_AppHomePages struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_DefaultReports struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_ExactForms struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_Fields struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_Forms struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_Notifications struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_PersonalReports struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_Pipelines struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_Relationships struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_Reminders struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_Reports struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_Roles struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage_Webhooks struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldsUsage_200_Usage struct {
	// Actions The number of quickbase actions where the given field is referenced.
	Actions GetFieldsUsage_200_Usage_Actions `json:"actions"`

	// AppHomePages The number of app home pages where the given field is referenced.
	AppHomePages GetFieldsUsage_200_Usage_AppHomePages `json:"appHomePages"`

	// Dashboards The number of dashboards where the given field is referenced.
	Dashboards struct {
		// Count the number of times a field has been used for the given item.
		Count int `json:"count"`
	} `json:"dashboards"`

	// DefaultReports The number of default reports where the given field is referenced.
	DefaultReports GetFieldsUsage_200_Usage_DefaultReports `json:"defaultReports"`

	// ExactForms The number of exact forms where the given field is referenced.
	ExactForms GetFieldsUsage_200_Usage_ExactForms `json:"exactForms"`

	// Fields The number of fields where the given field is referenced.
	Fields GetFieldsUsage_200_Usage_Fields `json:"fields"`

	// Forms The number of forms where the given field is referenced.
	Forms GetFieldsUsage_200_Usage_Forms `json:"forms"`

	// Notifications The number of notifications where the given field is referenced.
	Notifications GetFieldsUsage_200_Usage_Notifications `json:"notifications"`

	// PersonalReports The number of personal reports where the given field is referenced.
	PersonalReports GetFieldsUsage_200_Usage_PersonalReports `json:"personalReports"`

	// Pipelines The number of pipelines where the given field is referenced.
	Pipelines GetFieldsUsage_200_Usage_Pipelines `json:"pipelines"`

	// Relationships The number of relationships where the given field is referenced.
	Relationships GetFieldsUsage_200_Usage_Relationships `json:"relationships"`

	// Reminders The number of reminders where the given field is referenced.
	Reminders GetFieldsUsage_200_Usage_Reminders `json:"reminders"`

	// Reports The number of reports where the given field is referenced.
	Reports GetFieldsUsage_200_Usage_Reports `json:"reports"`

	// Roles The number of roles where the given field is referenced.
	Roles GetFieldsUsage_200_Usage_Roles `json:"roles"`

	// TableImports The number of table imports where the given field is referenced.
	TableImports struct {
		// Count the number of times a field has been used for the given item.
		Count int `json:"count"`
	} `json:"tableImports"`

	// TableRules The number of table rules where the given field is referenced.
	TableRules struct {
		// Count the number of times a field has been used for the given item.
		Count int `json:"count"`
	} `json:"tableRules"`

	// Webhooks The number of webhooks where the given field is referenced.
	Webhooks             GetFieldsUsage_200_Usage_Webhooks `json:"webhooks"`
	AdditionalProperties map[string]interface{}            `json:"-"`
}
type GetFieldsUsage_200_Item struct {
	// Field Basic information about the field.
	Field GetFieldsUsage_200_Field `json:"field"`

	// Usage Usage Information about the field.
	Usage                GetFieldsUsage_200_Usage `json:"usage"`
	AdditionalProperties map[string]interface{}   `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetFieldsUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFieldsUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFieldUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GetFieldUsage_200_Item
}
type GetFieldUsage_200_Field struct {
	// Id Field id.
	Id int `json:"id"`

	// Name Field name.
	Name string `json:"name"`

	// Type Field type.
	Type                 string                 `json:"type"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_Actions struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_AppHomePages struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_DefaultReports struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_ExactForms struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_Fields struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_Forms struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_Notifications struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_PersonalReports struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_Pipelines struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_Relationships struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_Reminders struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_Reports struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_Roles struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage_Webhooks struct {
	// Count the number of times a field has been used for the given item.
	Count                int                    `json:"count"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetFieldUsage_200_Usage struct {
	// Actions The number of quickbase actions where the given field is referenced.
	Actions GetFieldUsage_200_Usage_Actions `json:"actions"`

	// AppHomePages The number of app home pages where the given field is referenced.
	AppHomePages GetFieldUsage_200_Usage_AppHomePages `json:"appHomePages"`

	// Dashboards The number of dashboards where the given field is referenced.
	Dashboards struct {
		// Count the number of times a field has been used for the given item.
		Count int `json:"count"`
	} `json:"dashboards"`

	// DefaultReports The number of default reports where the given field is referenced.
	DefaultReports GetFieldUsage_200_Usage_DefaultReports `json:"defaultReports"`

	// ExactForms The number of exact forms where the given field is referenced.
	ExactForms GetFieldUsage_200_Usage_ExactForms `json:"exactForms"`

	// Fields The number of fields where the given field is referenced.
	Fields GetFieldUsage_200_Usage_Fields `json:"fields"`

	// Forms The number of forms where the given field is referenced.
	Forms GetFieldUsage_200_Usage_Forms `json:"forms"`

	// Notifications The number of notifications where the given field is referenced.
	Notifications GetFieldUsage_200_Usage_Notifications `json:"notifications"`

	// PersonalReports The number of personal reports where the given field is referenced.
	PersonalReports GetFieldUsage_200_Usage_PersonalReports `json:"personalReports"`

	// Pipelines The number of pipelines where the given field is referenced.
	Pipelines GetFieldUsage_200_Usage_Pipelines `json:"pipelines"`

	// Relationships The number of relationships where the given field is referenced.
	Relationships GetFieldUsage_200_Usage_Relationships `json:"relationships"`

	// Reminders The number of reminders where the given field is referenced.
	Reminders GetFieldUsage_200_Usage_Reminders `json:"reminders"`

	// Reports The number of reports where the given field is referenced.
	Reports GetFieldUsage_200_Usage_Reports `json:"reports"`

	// Roles The number of roles where the given field is referenced.
	Roles GetFieldUsage_200_Usage_Roles `json:"roles"`

	// TableImports The number of table imports where the given field is referenced.
	TableImports struct {
		// Count the number of times a field has been used for the given item.
		Count int `json:"count"`
	} `json:"tableImports"`

	// TableRules The number of table rules where the given field is referenced.
	TableRules struct {
		// Count the number of times a field has been used for the given item.
		Count int `json:"count"`
	} `json:"tableRules"`

	// Webhooks The number of webhooks where the given field is referenced.
	Webhooks             GetFieldUsage_200_Usage_Webhooks `json:"webhooks"`
	AdditionalProperties map[string]interface{}           `json:"-"`
}
type GetFieldUsage_200_Item struct {
	// Field Basic information about the field.
	Field GetFieldUsage_200_Field `json:"field"`

	// Usage Usage Information about the field.
	Usage                GetFieldUsage_200_Usage `json:"usage"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetFieldUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFieldUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AppearsByDefault Indicates if the field is marked as a default in reports.
		AppearsByDefault *bool `json:"appearsByDefault,omitempty"`

		// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs.
		Audited *bool `json:"audited,omitempty"`

		// Bold Indicates if the field is configured to display in bold in the product.
		Bold *bool `json:"bold,omitempty"`

		// DoesDataCopy Indicates if the field data will copy when a user copies the record.
		DoesDataCopy *bool `json:"doesDataCopy,omitempty"`

		// FieldHelp The configured help text shown to users within the product.
		FieldHelp *string `json:"fieldHelp,omitempty"`

		// FieldType The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
		FieldType *string `json:"fieldType,omitempty"`

		// FindEnabled Indicates if the field is marked as searchable.
		FindEnabled *bool `json:"findEnabled,omitempty"`

		// Id The id of the field, unique to this table.
		Id int64 `json:"id"`

		// Label The label (name) of the field.
		Label *string `json:"label,omitempty"`

		// Mode For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
		Mode *string `json:"mode,omitempty"`

		// NoWrap Indicates if the field is configured to not wrap when displayed in the product.
		NoWrap *bool `json:"noWrap,omitempty"`

		// Permissions Field Permissions for different roles.
		Permissions *[]struct {
			// PermissionType The permission given to the role for this field
			PermissionType *string `json:"permissionType,omitempty"`

			// Role The role associated with a given permission for the field
			Role *string `json:"role,omitempty"`

			// RoleId The Id of the given role
			RoleId *int `json:"roleId,omitempty"`
		} `json:"permissions,omitempty"`

		// Properties Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
		Properties *GetField_200_Properties `json:"properties,omitempty"`

		// Required Indicates if the field is marked required.
		Required *bool `json:"required,omitempty"`

		// Unique Indicates if the field is marked unique.
		Unique               *bool                  `json:"unique,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type GetField200PropertiesCompositeFields0 = int
type GetField200PropertiesCompositeFields1 = map[string]interface{}
type GetField_200_Properties_CompositeFields_Item struct {
	union json.RawMessage
}
type GetField200PropertiesCurrencyFormat string
type GetField200PropertiesSummaryFunction string
type GetField200PropertiesVersionMode string
type GetField_200_Properties struct {
	// Abbreviate Don't show the URL protocol when showing the URL.
	Abbreviate *bool `json:"abbreviate,omitempty"`

	// AllowHTML Whether this field allows html.
	AllowHTML *bool `json:"allowHTML,omitempty"`

	// AllowMentions If someone can @mention users in the rich text field to generate an email notification.
	AllowMentions *bool `json:"allowMentions,omitempty"`

	// AllowNewChoices Indicates if users can add new choices to a selection list.
	AllowNewChoices *bool `json:"allowNewChoices,omitempty"`

	// AppearsAs The link text, if empty, the url will be used as link text.
	AppearsAs *string `json:"appearsAs,omitempty"`

	// AppendOnly Whether this field is append only.
	AppendOnly *bool `json:"appendOnly,omitempty"`

	// AutoSave Whether the link field will auto save.
	AutoSave *bool `json:"autoSave,omitempty"`

	// BlankIsZero Whether a blank value is treated the same as 0 in calculations within the product.
	BlankIsZero *bool `json:"blankIsZero,omitempty"`

	// CarryChoices Whether the field should carry its multiple choice fields when copied.
	CarryChoices *bool `json:"carryChoices,omitempty"`

	// Choices An array of entries that exist for a field that offers choices to the user.
	Choices *[]string `json:"choices,omitempty"`

	// ChoicesLuid List of user choices.
	ChoicesLuid *[]string `json:"choicesLuid,omitempty"`

	// CommaStart The number of digits before commas display in the product, when applicable.
	CommaStart *int `json:"commaStart,omitempty"`

	// Comments The comments entered on the field properties by an administrator.
	Comments *string `json:"comments,omitempty"`

	// CompositeFields An array of the fields that make up a composite field (e.g., address).
	CompositeFields *[]GetField_200_Properties_CompositeFields_Item `json:"compositeFields,omitempty"`

	// CoverText An alternate user friendly text that can be used to display a link in the browser.
	CoverText *string `json:"coverText,omitempty"`

	// CurrencyFormat The currency format used when displaying field values within the product.
	CurrencyFormat *GetField200PropertiesCurrencyFormat `json:"currencyFormat,omitempty"`

	// CurrencySymbol The current symbol used when displaying field values within the product.
	CurrencySymbol *string `json:"currencySymbol,omitempty"`

	// DecimalPlaces The number of decimal places displayed in the product for this field.
	DecimalPlaces *int `json:"decimalPlaces,omitempty"`

	// DefaultCountryCode Controls the default country shown on international phone widgets on forms. Country code should be entered in the ISO 3166-1 alpha-2 format.
	DefaultCountryCode *string `json:"defaultCountryCode,omitempty"`

	// DefaultDomain Default email domain.
	DefaultDomain *string `json:"defaultDomain,omitempty"`

	// DefaultKind The user default type.
	DefaultKind *string `json:"defaultKind,omitempty"`

	// DefaultToday Indicates if the field value is defaulted today for new records.
	DefaultToday *bool `json:"defaultToday,omitempty"`

	// DefaultValue The default value configured for a field when a new record is added.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// DefaultValueLuid Default user id value.
	DefaultValueLuid *int `json:"defaultValueLuid,omitempty"`

	// DisplayAsLink Indicates if a field that is part of the relationship should be shown as a hyperlink to the parent record within the product.
	DisplayAsLink *bool `json:"displayAsLink,omitempty"`

	// DisplayCheckboxAsText Indicates whether the checkbox values will be shown as text in reports.
	DisplayCheckboxAsText *bool `json:"displayCheckboxAsText,omitempty"`

	// DisplayDayOfWeek Indicates whether to display the day of the week within the product.
	DisplayDayOfWeek *bool `json:"displayDayOfWeek,omitempty"`

	// DisplayEmail How the email is displayed.
	DisplayEmail *string `json:"displayEmail,omitempty"`

	// DisplayMonth How to display months.
	DisplayMonth *string `json:"displayMonth,omitempty"`

	// DisplayRelative Whether to display time as relative.
	DisplayRelative *bool `json:"displayRelative,omitempty"`

	// DisplayTime Indicates whether to display the time, in addition to the date.
	DisplayTime *bool `json:"displayTime,omitempty"`

	// DisplayTimezone Indicates whether to display the timezone within the product.
	DisplayTimezone *bool `json:"displayTimezone,omitempty"`

	// DisplayUser The configured option for how users display within the product.
	DisplayUser *string `json:"displayUser,omitempty"`

	// DoesAverage Whether this field averages in reports within the product.
	DoesAverage *bool `json:"doesAverage,omitempty"`

	// DoesTotal Whether this field totals in reports within the product.
	DoesTotal *bool `json:"doesTotal,omitempty"`

	// DurationField The duration field id.
	DurationField *int `json:"durationField,omitempty"`

	// Exact Whether an exact match is required for a report link.
	Exact *bool `json:"exact,omitempty"`

	// ForeignKey Indicates if the field is a foreign key (or reference field) in a relationship.
	ForeignKey *bool `json:"foreignKey,omitempty"`

	// Format The format to display time.
	Format *int `json:"format,omitempty"`

	// Formula The formula of the field as configured in Quickbase.
	Formula *string `json:"formula,omitempty"`

	// HasExtension Whether this field has a phone extension.
	HasExtension *bool `json:"hasExtension,omitempty"`

	// Hours24 Indicates whether or not to display time in the 24-hour format within the product.
	Hours24 *bool `json:"hours24,omitempty"`

	// LinkText The configured text value that replaces the URL that users see within the product.
	LinkText *string `json:"linkText,omitempty"`

	// LookupReferenceFieldId The id of the field that is the reference in the relationship for this lookup.
	LookupReferenceFieldId *int `json:"lookupReferenceFieldId,omitempty"`

	// LookupTargetFieldId The id of the field that is the target on the master table for this lookup.
	LookupTargetFieldId *int `json:"lookupTargetFieldId,omitempty"`

	// MasterChoiceFieldId The id of the field that is the reference in the relationship.
	MasterChoiceFieldId *int `json:"masterChoiceFieldId,omitempty"`

	// MasterChoiceTableId The id of the table that is the master in this relationship.
	MasterChoiceTableId *string `json:"masterChoiceTableId,omitempty"`

	// MasterTableTag The table alias for the master table in the relationship this field is part of.
	MasterTableTag *string `json:"masterTableTag,omitempty"`

	// MaxLength The maximum number of characters allowed for entry in Quickbase for this field.
	MaxLength *int `json:"maxLength,omitempty"`

	// MaxVersions The maximum number of versions configured for a file attachment.
	MaxVersions *int `json:"maxVersions,omitempty"`

	// NumLines The number of lines shown in Quickbase for this text field.
	NumLines *int `json:"numLines,omitempty"`

	// NumberFormat The format used for displaying numeric values in the product (decimal, separators, digit group).
	NumberFormat *int `json:"numberFormat,omitempty"`

	// ParentFieldId The id of the parent composite field, when applicable.
	ParentFieldId *int `json:"parentFieldId,omitempty"`

	// PostTempToken POSTs a temporary token to the first URL when clicked by a user. [Learn more](https://help.quickbase.com/docs/post-temporary-token-from-a-quickbase-field)
	PostTempToken *bool `json:"postTempToken,omitempty"`

	// SeeVersions Indicates if the user can see other versions, aside from the most recent, of a file attachment within the product.
	SeeVersions *bool `json:"seeVersions,omitempty"`

	// SnapFieldId The id of the field that is used to snapshot values from, when applicable.
	SnapFieldId *int `json:"snapFieldId,omitempty"`

	// SortAlpha Whether to sort alphabetically, default sort is by record ID.
	SortAlpha *bool `json:"sortAlpha,omitempty"`

	// SortAsGiven Indicates if the listed entries sort as entered vs alphabetically.
	SortAsGiven *bool `json:"sortAsGiven,omitempty"`

	// SourceFieldId The id of the source field.
	SourceFieldId *int `json:"sourceFieldId,omitempty"`

	// StartField The start field id.
	StartField *int `json:"startField,omitempty"`

	// SummaryFunction The summary accumulation function type.
	SummaryFunction *GetField200PropertiesSummaryFunction `json:"summaryFunction,omitempty"`

	// SummaryReferenceFieldId The id of the field that is the reference in the relationship for this summary.
	SummaryReferenceFieldId *int64 `json:"summaryReferenceFieldId,omitempty"`

	// SummaryTargetFieldId The id of the field that is used to aggregate values from the child, when applicable. This displays 0 if the summary function doesn't require a field selection (like count).
	SummaryTargetFieldId *int `json:"summaryTargetFieldId,omitempty"`

	// TargetFieldId The id of the target field.
	TargetFieldId *int `json:"targetFieldId,omitempty"`

	// TargetTableId The id of the target table.
	TargetTableId *string `json:"targetTableId,omitempty"`

	// TargetTableName The field's target table name.
	TargetTableName *string `json:"targetTableName,omitempty"`

	// Units The units label.
	Units *string `json:"units,omitempty"`

	// UseI18NFormat Whether phone numbers should be in E.164 standard international format.
	UseI18NFormat *bool `json:"useI18NFormat,omitempty"`

	// UseNewWindow Indicates if the URL should open a new window when a user clicks it within the product.
	UseNewWindow *bool `json:"useNewWindow,omitempty"`

	// VersionMode Version modes for files. Keep all versions vs keep last version.
	VersionMode *GetField200PropertiesVersionMode `json:"versionMode,omitempty"`

	// Width The field's html input width in the product.
	Width *int `json:"width,omitempty"`

	// WorkWeek The work week type.
	WorkWeek *int `json:"workWeek,omitempty"`

	// XmlTag The field's xml tag.
	XmlTag               *string                `json:"xmlTag,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFieldResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AppearsByDefault Indicates if the field is marked as a default in reports.
		AppearsByDefault *bool `json:"appearsByDefault,omitempty"`

		// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs.
		Audited *bool `json:"audited,omitempty"`

		// Bold Indicates if the field is configured to display in bold in the product.
		Bold *bool `json:"bold,omitempty"`

		// DoesDataCopy Indicates if the field data will copy when a user copies the record.
		DoesDataCopy *bool `json:"doesDataCopy,omitempty"`

		// FieldHelp The configured help text shown to users within the product.
		FieldHelp *string `json:"fieldHelp,omitempty"`

		// FieldType The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
		FieldType *string `json:"fieldType,omitempty"`

		// FindEnabled Indicates if the field is marked as searchable.
		FindEnabled *bool `json:"findEnabled,omitempty"`

		// Id The id of the field, unique to this table.
		Id int64 `json:"id"`

		// Label The label (name) of the field.
		Label *string `json:"label,omitempty"`

		// Mode For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
		Mode *string `json:"mode,omitempty"`

		// NoWrap Indicates if the field is configured to not wrap when displayed in the product.
		NoWrap *bool `json:"noWrap,omitempty"`

		// Permissions Field Permissions for different roles.
		Permissions *[]struct {
			// PermissionType The permission given to the role for this field
			PermissionType *string `json:"permissionType,omitempty"`

			// Role The role associated with a given permission for the field
			Role *string `json:"role,omitempty"`

			// RoleId The Id of the given role
			RoleId *int `json:"roleId,omitempty"`
		} `json:"permissions,omitempty"`

		// Properties Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
		Properties *UpdateField_200_Properties `json:"properties,omitempty"`

		// Required Indicates if the field is marked required.
		Required *bool `json:"required,omitempty"`

		// Unique Indicates if the field is marked unique.
		Unique               *bool                  `json:"unique,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type UpdateField200PropertiesCompositeFields0 = int
type UpdateField200PropertiesCompositeFields1 = map[string]interface{}
type UpdateField_200_Properties_CompositeFields_Item struct {
	union json.RawMessage
}
type UpdateField200PropertiesCurrencyFormat string
type UpdateField200PropertiesSummaryFunction string
type UpdateField200PropertiesVersionMode string
type UpdateField_200_Properties struct {
	// Abbreviate Don't show the URL protocol when showing the URL.
	Abbreviate *bool `json:"abbreviate,omitempty"`

	// AllowHTML Whether this field allows html.
	AllowHTML *bool `json:"allowHTML,omitempty"`

	// AllowMentions If someone can @mention users in the rich text field to generate an email notification.
	AllowMentions *bool `json:"allowMentions,omitempty"`

	// AllowNewChoices Indicates if users can add new choices to a selection list.
	AllowNewChoices *bool `json:"allowNewChoices,omitempty"`

	// AppearsAs The link text, if empty, the url will be used as link text.
	AppearsAs *string `json:"appearsAs,omitempty"`

	// AppendOnly Whether this field is append only.
	AppendOnly *bool `json:"appendOnly,omitempty"`

	// AutoSave Whether the link field will auto save.
	AutoSave *bool `json:"autoSave,omitempty"`

	// BlankIsZero Whether a blank value is treated the same as 0 in calculations within the product.
	BlankIsZero *bool `json:"blankIsZero,omitempty"`

	// CarryChoices Whether the field should carry its multiple choice fields when copied.
	CarryChoices *bool `json:"carryChoices,omitempty"`

	// Choices An array of entries that exist for a field that offers choices to the user.
	Choices *[]string `json:"choices,omitempty"`

	// ChoicesLuid List of user choices.
	ChoicesLuid *[]string `json:"choicesLuid,omitempty"`

	// CommaStart The number of digits before commas display in the product, when applicable.
	CommaStart *int `json:"commaStart,omitempty"`

	// Comments The comments entered on the field properties by an administrator.
	Comments *string `json:"comments,omitempty"`

	// CompositeFields An array of the fields that make up a composite field (e.g., address).
	CompositeFields *[]UpdateField_200_Properties_CompositeFields_Item `json:"compositeFields,omitempty"`

	// CoverText An alternate user friendly text that can be used to display a link in the browser.
	CoverText *string `json:"coverText,omitempty"`

	// CurrencyFormat The currency format used when displaying field values within the product.
	CurrencyFormat *UpdateField200PropertiesCurrencyFormat `json:"currencyFormat,omitempty"`

	// CurrencySymbol The current symbol used when displaying field values within the product.
	CurrencySymbol *string `json:"currencySymbol,omitempty"`

	// DecimalPlaces The number of decimal places displayed in the product for this field.
	DecimalPlaces *int `json:"decimalPlaces,omitempty"`

	// DefaultCountryCode Controls the default country shown on international phone widgets on forms. Country code should be entered in the ISO 3166-1 alpha-2 format.
	DefaultCountryCode *string `json:"defaultCountryCode,omitempty"`

	// DefaultDomain Default email domain.
	DefaultDomain *string `json:"defaultDomain,omitempty"`

	// DefaultKind The user default type.
	DefaultKind *string `json:"defaultKind,omitempty"`

	// DefaultToday Indicates if the field value is defaulted today for new records.
	DefaultToday *bool `json:"defaultToday,omitempty"`

	// DefaultValue The default value configured for a field when a new record is added.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// DefaultValueLuid Default user id value.
	DefaultValueLuid *int `json:"defaultValueLuid,omitempty"`

	// DisplayAsLink Indicates if a field that is part of the relationship should be shown as a hyperlink to the parent record within the product.
	DisplayAsLink *bool `json:"displayAsLink,omitempty"`

	// DisplayCheckboxAsText Indicates whether the checkbox values will be shown as text in reports.
	DisplayCheckboxAsText *bool `json:"displayCheckboxAsText,omitempty"`

	// DisplayDayOfWeek Indicates whether to display the day of the week within the product.
	DisplayDayOfWeek *bool `json:"displayDayOfWeek,omitempty"`

	// DisplayEmail How the email is displayed.
	DisplayEmail *string `json:"displayEmail,omitempty"`

	// DisplayMonth How to display months.
	DisplayMonth *string `json:"displayMonth,omitempty"`

	// DisplayRelative Whether to display time as relative.
	DisplayRelative *bool `json:"displayRelative,omitempty"`

	// DisplayTime Indicates whether to display the time, in addition to the date.
	DisplayTime *bool `json:"displayTime,omitempty"`

	// DisplayTimezone Indicates whether to display the timezone within the product.
	DisplayTimezone *bool `json:"displayTimezone,omitempty"`

	// DisplayUser The configured option for how users display within the product.
	DisplayUser *string `json:"displayUser,omitempty"`

	// DoesAverage Whether this field averages in reports within the product.
	DoesAverage *bool `json:"doesAverage,omitempty"`

	// DoesTotal Whether this field totals in reports within the product.
	DoesTotal *bool `json:"doesTotal,omitempty"`

	// DurationField The duration field id.
	DurationField *int `json:"durationField,omitempty"`

	// Exact Whether an exact match is required for a report link.
	Exact *bool `json:"exact,omitempty"`

	// ForeignKey Indicates if the field is a foreign key (or reference field) in a relationship.
	ForeignKey *bool `json:"foreignKey,omitempty"`

	// Format The format to display time.
	Format *int `json:"format,omitempty"`

	// Formula The formula of the field as configured in Quickbase.
	Formula *string `json:"formula,omitempty"`

	// HasExtension Whether this field has a phone extension.
	HasExtension *bool `json:"hasExtension,omitempty"`

	// Hours24 Indicates whether or not to display time in the 24-hour format within the product.
	Hours24 *bool `json:"hours24,omitempty"`

	// LinkText The configured text value that replaces the URL that users see within the product.
	LinkText *string `json:"linkText,omitempty"`

	// LookupReferenceFieldId The id of the field that is the reference in the relationship for this lookup.
	LookupReferenceFieldId *int `json:"lookupReferenceFieldId,omitempty"`

	// LookupTargetFieldId The id of the field that is the target on the master table for this lookup.
	LookupTargetFieldId *int `json:"lookupTargetFieldId,omitempty"`

	// MasterChoiceFieldId The id of the field that is the reference in the relationship.
	MasterChoiceFieldId *int `json:"masterChoiceFieldId,omitempty"`

	// MasterChoiceTableId The id of the table that is the master in this relationship.
	MasterChoiceTableId *string `json:"masterChoiceTableId,omitempty"`

	// MasterTableTag The table alias for the master table in the relationship this field is part of.
	MasterTableTag *string `json:"masterTableTag,omitempty"`

	// MaxLength The maximum number of characters allowed for entry in Quickbase for this field.
	MaxLength *int `json:"maxLength,omitempty"`

	// MaxVersions The maximum number of versions configured for a file attachment.
	MaxVersions *int `json:"maxVersions,omitempty"`

	// NumLines The number of lines shown in Quickbase for this text field.
	NumLines *int `json:"numLines,omitempty"`

	// NumberFormat The format used for displaying numeric values in the product (decimal, separators, digit group).
	NumberFormat *int `json:"numberFormat,omitempty"`

	// ParentFieldId The id of the parent composite field, when applicable.
	ParentFieldId *int `json:"parentFieldId,omitempty"`

	// PostTempToken POSTs a temporary token to the first URL when clicked by a user. [Learn more](https://help.quickbase.com/docs/post-temporary-token-from-a-quickbase-field)
	PostTempToken *bool `json:"postTempToken,omitempty"`

	// SeeVersions Indicates if the user can see other versions, aside from the most recent, of a file attachment within the product.
	SeeVersions *bool `json:"seeVersions,omitempty"`

	// SnapFieldId The id of the field that is used to snapshot values from, when applicable.
	SnapFieldId *int `json:"snapFieldId,omitempty"`

	// SortAlpha Whether to sort alphabetically, default sort is by record ID.
	SortAlpha *bool `json:"sortAlpha,omitempty"`

	// SortAsGiven Indicates if the listed entries sort as entered vs alphabetically.
	SortAsGiven *bool `json:"sortAsGiven,omitempty"`

	// SourceFieldId The id of the source field.
	SourceFieldId *int `json:"sourceFieldId,omitempty"`

	// StartField The start field id.
	StartField *int `json:"startField,omitempty"`

	// SummaryFunction The summary accumulation function type.
	SummaryFunction *UpdateField200PropertiesSummaryFunction `json:"summaryFunction,omitempty"`

	// SummaryReferenceFieldId The id of the field that is the reference in the relationship for this summary.
	SummaryReferenceFieldId *int64 `json:"summaryReferenceFieldId,omitempty"`

	// SummaryTargetFieldId The id of the field that is used to aggregate values from the child, when applicable. This displays 0 if the summary function doesn't require a field selection (like count).
	SummaryTargetFieldId *int `json:"summaryTargetFieldId,omitempty"`

	// TargetFieldId The id of the target field.
	TargetFieldId *int `json:"targetFieldId,omitempty"`

	// TargetTableId The id of the target table.
	TargetTableId *string `json:"targetTableId,omitempty"`

	// TargetTableName The field's target table name.
	TargetTableName *string `json:"targetTableName,omitempty"`

	// Units The units label.
	Units *string `json:"units,omitempty"`

	// UseI18NFormat Whether phone numbers should be in E.164 standard international format.
	UseI18NFormat *bool `json:"useI18NFormat,omitempty"`

	// UseNewWindow Indicates if the URL should open a new window when a user clicks it within the product.
	UseNewWindow *bool `json:"useNewWindow,omitempty"`

	// VersionMode Version modes for files. Keep all versions vs keep last version.
	VersionMode *UpdateField200PropertiesVersionMode `json:"versionMode,omitempty"`

	// Width The field's html input width in the product.
	Width *int `json:"width,omitempty"`

	// WorkWeek The work week type.
	WorkWeek *int `json:"workWeek,omitempty"`

	// XmlTag The field's xml tag.
	XmlTag               *string                `json:"xmlTag,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r UpdateFieldResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFieldResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Creator The user that uploaded version.
		Creator *DeleteFile_200_Creator `json:"creator,omitempty"`

		// FileName The name of file associated with deleted version.
		FileName *string `json:"fileName,omitempty"`

		// Uploaded The timestamp when the version was originally uploaded.
		Uploaded *string `json:"uploaded,omitempty"`

		// VersionNumber The number of deleted version.
		VersionNumber        *int                   `json:"versionNumber,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type DeleteFile_200_Creator struct {
	// Email User email.
	Email *string `json:"email,omitempty"`

	// Id User Id.
	Id *string `json:"id,omitempty"`

	// Name User full name.
	Name *string `json:"name,omitempty"`

	// UserName User Name as updated in user properties. Optional, appears if not the same as user email.
	UserName             *string                `json:"userName,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r DeleteFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r DownloadFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunFormulaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Result The formula execution result.
		Result               *string                `json:"result,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r RunFormulaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunFormulaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveManagersFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of users that couldn't be removed from the group. This includes a list of IDs that represent invalid users.
		Failure []string `json:"failure"`

		// Success A list of users that have been removed from the group successfully.
		Success              []string               `json:"success"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveManagersFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveManagersFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddManagersToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of users that couldn't be added to the group. This includes a list of IDs that represent invalid users and users who have already been added to the group.
		Failure []string `json:"failure"`

		// Success A list of users that have been added to the group successfully.
		Success              []string               `json:"success"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r AddManagersToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddManagersToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveMembersFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of users that couldn't be removed from the group. This includes a list of IDs that represent invalid users.
		Failure []string `json:"failure"`

		// Success A list of users that have been removed from the group successfully.
		Success              []string               `json:"success"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveMembersFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveMembersFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddMembersToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of users that couldn't be added to the group. This includes a list of IDs that represent invalid users and users who have already been added to the group.
		Failure []string `json:"failure"`

		// Success A list of users that have been added to the group successfully.
		Success              []string               `json:"success"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r AddMembersToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddMembersToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveSubgroupsFromGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of child groups that couldn't be removed from the group. This includes a list of IDs that represent invalid groups.
		Failure []string `json:"failure"`

		// Success A list of child groups that have been removed from the group successfully.
		Success              []string               `json:"success"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r RemoveSubgroupsFromGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveSubgroupsFromGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddSubgroupsToGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of child groups that couldn't be added to the group. This includes a list of IDs that represent invalid groups and groups that have already been added to the group.
		Failure []string `json:"failure"`

		// Success A list of child groups that have been added to the group successfully.
		Success              []string               `json:"success"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r AddSubgroupsToGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddSubgroupsToGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRecordsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NumberDeleted The number of records deleted.
		NumberDeleted        *int                   `json:"numberDeleted,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRecordsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRecordsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpsertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data The data that is expected to be returned.
		Data *[]QuickbaseRecord `json:"data,omitempty"`

		// Metadata Information about created records, updated records, referenced but unchanged records, and records having any errors while being processed.
		Metadata             *Upsert_200_Metadata   `json:"metadata,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
	JSON207 *struct {
		// Data The data that is expected to be returned.
		Data *[]interface{} `json:"data,omitempty"`

		// Metadata Information about created records, updated records, referenced but unchanged records, and records having any errors while being processed.
		Metadata             *Upsert_207_Metadata   `json:"metadata,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
	JSON400 *struct {
		// Description The description for the occurence of the error.
		Description *string `json:"description,omitempty"`

		// Message The type of error found.
		Message              *string                `json:"message,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type Upsert_200_Metadata struct {
	// CreatedRecordIds Array containing the created record ids.
	CreatedRecordIds *[]int `json:"createdRecordIds,omitempty"`

	// LineErrors This will only be returned in the case of failed records. It is a collection of errors that occurred when processing the incoming data that resulted in records not being processed. Each object has a key representing the sequence number of the record in the original payload (starting from 1). The value is a list of errors occurred.
	LineErrors *map[string][]string `json:"lineErrors,omitempty"`

	// TotalNumberOfRecordsProcessed Number of records processed. Includes successful and failed record updates.
	TotalNumberOfRecordsProcessed *int `json:"totalNumberOfRecordsProcessed,omitempty"`

	// UnchangedRecordIds Array containing the unchanged record ids.
	UnchangedRecordIds *[]int `json:"unchangedRecordIds,omitempty"`

	// UpdatedRecordIds Array containing the updated record ids.
	UpdatedRecordIds     *[]int                 `json:"updatedRecordIds,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type Upsert_207_Metadata struct {
	// CreatedRecordIds Array containing the created record ids.
	CreatedRecordIds *[]int `json:"createdRecordIds,omitempty"`

	// LineErrors This will only be returned in the case of failed records. It is a collection of errors that occurred when processing the incoming data that resulted in records not being processed. Each object has a key representing the sequence number of the record in the original payload (starting from 1). The value is a list of errors occurred.
	LineErrors *map[string][]string `json:"lineErrors,omitempty"`

	// TotalNumberOfRecordsProcessed Number of records processed. Includes successful and failed record updates.
	TotalNumberOfRecordsProcessed *int `json:"totalNumberOfRecordsProcessed,omitempty"`

	// UnchangedRecordIds Array containing the unchanged record ids.
	UnchangedRecordIds *[]int `json:"unchangedRecordIds,omitempty"`

	// UpdatedRecordIds Array containing the updated record ids.
	UpdatedRecordIds     *[]int                 `json:"updatedRecordIds,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r UpsertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpsertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RecordsModifiedSinceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Changes When includeDetails is true, this array contains the individual record changes. If includeDetails is false, this array will not be returned.
		Changes *[]RecordsModifiedSince_200_Changes_Item `json:"changes,omitempty"`

		// Count The count of changes found.
		Count int `json:"count"`

		// DeletesTruncated When true, this indicates that the number of deletes detected exceeded the limit and details could not be returned.
		DeletesTruncated     *bool                  `json:"deletesTruncated,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type RecordsModifiedSince200ChangesChangeType string
type RecordsModifiedSince_200_Changes_Item struct {
	// ChangeType The type of change that was detected.
	ChangeType *RecordsModifiedSince200ChangesChangeType `json:"changeType,omitempty"`

	// RecordId A record whose dependencies were found to have been updated after the time provided.
	RecordId *int `json:"recordId,omitempty"`

	// Timestamp The timestamp that Quickbase found that exceeded the after time. This does not represent the latest date modified in the record graph.
	Timestamp            *time.Time             `json:"timestamp,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r RecordsModifiedSinceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RecordsModifiedSinceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunQueryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An array of objects that either represents the record data or summarized values, depending on the report type.
		Data *[]QuickbaseRecord `json:"data,omitempty"`

		// Fields An array of objects that contains limited meta-data of each field displayed in the report. This assists in building logic that depends on field types and IDs.
		Fields *[]RunQuery_200_Fields_Item `json:"fields,omitempty"`

		// Metadata Additional information about the results that may be helpful. Pagination may be needed if either you specify a smaller number of results to skip than is available, or if the API automatically returns fewer results. numRecords can be compared to totalRecords to determine if further pagination is needed.
		Metadata             *RunQuery_200_Metadata `json:"metadata,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type RunQuery_200_Fields_Item struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type RunQuery_200_Metadata struct {
	// NumFields The number of fields in each record in the current response object
	NumFields int `json:"numFields"`

	// NumRecords The number of records in the current response object
	NumRecords int `json:"numRecords"`

	// Skip The number of records to skip
	Skip *int `json:"skip,omitempty"`

	// Top If present, the maximum number of records requested by the caller
	Top *int `json:"top,omitempty"`

	// TotalRecords The total number of records in the result set
	TotalRecords         int                    `json:"totalRecords"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r RunQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableReportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GetTableReports_200_Item
}
type GetTableReports200QueryFormulaFieldsFieldType string
type GetTableReports_200_Query_FormulaFields_Item struct {
	// DecimalPrecision For numeric formula the number precision.
	DecimalPrecision *int `json:"decimalPrecision,omitempty"`

	// FieldType Resulting formula value type.
	FieldType *GetTableReports200QueryFormulaFieldsFieldType `json:"fieldType,omitempty"`

	// Formula Formula text.
	Formula *string `json:"formula,omitempty"`

	// Id Formula field identifier.
	Id *int `json:"id,omitempty"`

	// Label Formula field label.
	Label                *string                `json:"label,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetTableReports_200_Query struct {
	// Filter Filter used to query for data.
	Filter *string `json:"filter,omitempty"`

	// FormulaFields Calculated formula fields.
	FormulaFields *[]GetTableReports_200_Query_FormulaFields_Item `json:"formulaFields,omitempty"`

	// TableId The table identifier for the report.
	TableId              *string                `json:"tableId,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetTableReports_200_Item struct {
	// Description The configured description of a report.
	Description *string `json:"description,omitempty"`

	// Id The identifier of the report, unique to the table.
	Id *string `json:"id,omitempty"`

	// Name The configured name of the report.
	Name *string `json:"name,omitempty"`

	// OwnerId Optional, showed only for personal reports. The user ID of report owner.
	OwnerId *int `json:"ownerId,omitempty"`

	// Properties A list of properties specific to the report type. To see a detailed description of the properties for each report type, See [Report Types.](../reportTypes)
	Properties *map[string]interface{} `json:"properties,omitempty"`

	// Query The query definition as configured in Quickbase that gets executed when the report is run.
	Query *GetTableReports_200_Query `json:"query,omitempty"`

	// Type The type of report in Quickbase (e.g., chart).
	Type *string `json:"type,omitempty"`

	// UsedCount The number of times a report has been used.
	UsedCount *int `json:"usedCount,omitempty"`

	// UsedLast The instant at which a report was last used.
	UsedLast             *string                `json:"usedLast,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetTableReportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableReportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Description The configured description of a report.
		Description *string `json:"description,omitempty"`

		// Id The identifier of the report, unique to the table.
		Id *string `json:"id,omitempty"`

		// Name The configured name of the report.
		Name *string `json:"name,omitempty"`

		// OwnerId Optional, showed only for personal reports. The user ID of report owner.
		OwnerId *int `json:"ownerId,omitempty"`

		// Properties A list of properties specific to the report type. To see a detailed description of the properties for each report type, See [Report Types.](../reportTypes)
		Properties *map[string]interface{} `json:"properties,omitempty"`

		// Query The query definition as configured in Quickbase that gets executed when the report is run.
		Query *GetReport_200_Query `json:"query,omitempty"`

		// Type The type of report in Quickbase (e.g., chart).
		Type *string `json:"type,omitempty"`

		// UsedCount The number of times a report has been used.
		UsedCount *int `json:"usedCount,omitempty"`

		// UsedLast The instant at which a report was last used.
		UsedLast             *string                `json:"usedLast,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type GetReport200QueryFormulaFieldsFieldType string
type GetReport_200_Query_FormulaFields_Item struct {
	// DecimalPrecision For numeric formula the number precision.
	DecimalPrecision *int `json:"decimalPrecision,omitempty"`

	// FieldType Resulting formula value type.
	FieldType *GetReport200QueryFormulaFieldsFieldType `json:"fieldType,omitempty"`

	// Formula Formula text.
	Formula *string `json:"formula,omitempty"`

	// Id Formula field identifier.
	Id *int `json:"id,omitempty"`

	// Label Formula field label.
	Label                *string                `json:"label,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetReport_200_Query struct {
	// Filter Filter used to query for data.
	Filter *string `json:"filter,omitempty"`

	// FormulaFields Calculated formula fields.
	FormulaFields *[]GetReport_200_Query_FormulaFields_Item `json:"formulaFields,omitempty"`

	// TableId The table identifier for the report.
	TableId              *string                `json:"tableId,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data An array of objects that either represents the record data or summarized values, depending on the report type.
		Data *[]QuickbaseRecord `json:"data,omitempty"`

		// Fields An array of objects that contains limited meta-data of each field displayed in the report. This assists in building logic that depends on field types and IDs.
		Fields *[]RunReport_200_Fields_Item `json:"fields,omitempty"`

		// Metadata Additional information about the results that may be helpful. Pagination may be needed if either you specify a smaller number of results to skip than is available, or if the API automatically returns fewer results. numRecords can be compared to totalRecords to determine if further pagination is needed.
		Metadata             *RunReport_200_Metadata `json:"metadata,omitempty"`
		AdditionalProperties map[string]interface{}  `json:"-"`
	}
}
type RunReport_200_Fields_Item struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// LabelOverride Column heading label override for field in report.
	LabelOverride *string `json:"labelOverride,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type RunReport_200_Metadata struct {
	// NumFields The number of fields in each record in the current response object
	NumFields int `json:"numFields"`

	// NumRecords The number of records in the current response object
	NumRecords int `json:"numRecords"`

	// Skip The number of records to skip
	Skip *int `json:"skip,omitempty"`

	// Top If present, the maximum number of records requested by the caller
	Top *int `json:"top,omitempty"`

	// TotalRecords The total number of records in the result set
	TotalRecords         int                    `json:"totalRecords"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r RunReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSolutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *interface{}
	JSON401      *interface{}
	JSONDefault  *interface{}
}

// Status returns HTTPResponse.Status
func (r CreateSolutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSolutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSolutionFromRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *interface{}
	JSON401      *interface{}
	JSON404      *interface{}
	JSONDefault  *interface{}
}

// Status returns HTTPResponse.Status
func (r CreateSolutionFromRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSolutionFromRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSolutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *interface{}
	JSON401      *interface{}
	JSON404      *interface{}
	JSONDefault  *interface{}
}

// Status returns HTTPResponse.Status
func (r ExportSolutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSolutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSolutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *interface{}
	JSON401      *interface{}
	JSONDefault  *interface{}
}

// Status returns HTTPResponse.Status
func (r UpdateSolutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSolutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangesetSolutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *interface{}
	JSON401      *interface{}
	JSON404      *interface{}
	JSONDefault  *interface{}
}

// Status returns HTTPResponse.Status
func (r ChangesetSolutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangesetSolutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangesetSolutionFromRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *interface{}
	JSON401      *interface{}
	JSON404      *interface{}
	JSONDefault  *interface{}
}

// Status returns HTTPResponse.Status
func (r ChangesetSolutionFromRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangesetSolutionFromRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSolutionToRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *interface{}
	JSON401      *interface{}
	JSON404      *interface{}
	JSONDefault  *interface{}
}

// Status returns HTTPResponse.Status
func (r UpdateSolutionToRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSolutionToRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSolutionPublicResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *interface{}
	JSON401      *interface{}
	JSON404      *interface{}
	JSON500      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetSolutionPublicResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSolutionPublicResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportSolutionToRecordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
	JSON400      *interface{}
	JSON401      *interface{}
	JSON404      *interface{}
	JSONDefault  *interface{}
}

// Status returns HTTPResponse.Status
func (r ExportSolutionToRecordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportSolutionToRecordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GetAppTables_200_Item
}
type GetAppTables200DefaultSortOrder string
type GetAppTables_200_Item struct {
	// Alias The automatically-created table alias for the table.
	Alias *string `json:"alias,omitempty"`

	// Created The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
	Created *string `json:"created,omitempty"`

	// DefaultSortFieldId The id of the field that is configured for default sorting.
	DefaultSortFieldId *int `json:"defaultSortFieldId,omitempty"`

	// DefaultSortOrder The configuration of the default sort order on the table.
	DefaultSortOrder *GetAppTables200DefaultSortOrder `json:"defaultSortOrder,omitempty"`

	// Description The description of the table, as configured by an application administrator.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier (dbid) of the table.
	Id *string `json:"id,omitempty"`

	// KeyFieldId The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
	KeyFieldId *int `json:"keyFieldId,omitempty"`

	// Name The name of the table.
	Name *string `json:"name,omitempty"`

	// NextFieldId The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
	NextFieldId *int `json:"nextFieldId,omitempty"`

	// NextRecordId The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
	NextRecordId *int `json:"nextRecordId,omitempty"`

	// PluralRecordName The builder-configured plural noun of the table.
	PluralRecordName *string `json:"pluralRecordName,omitempty"`

	// SingleRecordName The builder-configured singular noun of the table.
	SingleRecordName *string `json:"singleRecordName,omitempty"`

	// SizeLimit The size limit for the table.
	SizeLimit *string `json:"sizeLimit,omitempty"`

	// SpaceRemaining The amount of space remaining for use by the table.
	SpaceRemaining *string `json:"spaceRemaining,omitempty"`

	// SpaceUsed The amount of space currently being used by the table.
	SpaceUsed *string `json:"spaceUsed,omitempty"`

	// Updated The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
	Updated              *string                `json:"updated,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetAppTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Alias The automatically-created table alias for the table.
		Alias *string `json:"alias,omitempty"`

		// Created The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Created *string `json:"created,omitempty"`

		// DefaultSortFieldId The id of the field that is configured for default sorting.
		DefaultSortFieldId *int `json:"defaultSortFieldId,omitempty"`

		// DefaultSortOrder The configuration of the default sort order on the table.
		DefaultSortOrder *CreateTable200DefaultSortOrder `json:"defaultSortOrder,omitempty"`

		// Description The description of the table, as configured by an application administrator.
		Description *string `json:"description,omitempty"`

		// Id The unique identifier (dbid) of the table.
		Id *string `json:"id,omitempty"`

		// KeyFieldId The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
		KeyFieldId *int `json:"keyFieldId,omitempty"`

		// Name The name of the table.
		Name *string `json:"name,omitempty"`

		// NextFieldId The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
		NextFieldId *int `json:"nextFieldId,omitempty"`

		// NextRecordId The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
		NextRecordId *int `json:"nextRecordId,omitempty"`

		// PluralRecordName The builder-configured plural noun of the table.
		PluralRecordName *string `json:"pluralRecordName,omitempty"`

		// SingleRecordName The builder-configured singular noun of the table.
		SingleRecordName *string `json:"singleRecordName,omitempty"`

		// SizeLimit The size limit for the table.
		SizeLimit *string `json:"sizeLimit,omitempty"`

		// SpaceRemaining The amount of space remaining for use by the table.
		SpaceRemaining *string `json:"spaceRemaining,omitempty"`

		// SpaceUsed The amount of space currently being used by the table.
		SpaceUsed *string `json:"spaceUsed,omitempty"`

		// Updated The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Updated              *string                `json:"updated,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type CreateTable200DefaultSortOrder string

// Status returns HTTPResponse.Status
func (r CreateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeletedTableId The deleted table id.
		DeletedTableId       *string                `json:"deletedTableId,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Alias The automatically-created table alias for the table.
		Alias *string `json:"alias,omitempty"`

		// Created The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Created *string `json:"created,omitempty"`

		// DefaultSortFieldId The id of the field that is configured for default sorting.
		DefaultSortFieldId *int `json:"defaultSortFieldId,omitempty"`

		// DefaultSortOrder The configuration of the default sort order on the table.
		DefaultSortOrder *GetTable200DefaultSortOrder `json:"defaultSortOrder,omitempty"`

		// Description The description of the table, as configured by an application administrator.
		Description *string `json:"description,omitempty"`

		// Id The unique identifier (dbid) of the table.
		Id *string `json:"id,omitempty"`

		// KeyFieldId The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
		KeyFieldId *int `json:"keyFieldId,omitempty"`

		// Name The name of the table.
		Name *string `json:"name,omitempty"`

		// NextFieldId The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
		NextFieldId *int `json:"nextFieldId,omitempty"`

		// NextRecordId The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
		NextRecordId *int `json:"nextRecordId,omitempty"`

		// PluralRecordName The builder-configured plural noun of the table.
		PluralRecordName *string `json:"pluralRecordName,omitempty"`

		// SingleRecordName The builder-configured singular noun of the table.
		SingleRecordName *string `json:"singleRecordName,omitempty"`

		// SizeLimit The size limit for the table.
		SizeLimit *string `json:"sizeLimit,omitempty"`

		// SpaceRemaining The amount of space remaining for use by the table.
		SpaceRemaining *string `json:"spaceRemaining,omitempty"`

		// SpaceUsed The amount of space currently being used by the table.
		SpaceUsed *string `json:"spaceUsed,omitempty"`

		// Updated The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Updated              *string                `json:"updated,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type GetTable200DefaultSortOrder string

// Status returns HTTPResponse.Status
func (r GetTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTableResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Alias The automatically-created table alias for the table.
		Alias *string `json:"alias,omitempty"`

		// Created The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Created *string `json:"created,omitempty"`

		// DefaultSortFieldId The id of the field that is configured for default sorting.
		DefaultSortFieldId *int `json:"defaultSortFieldId,omitempty"`

		// DefaultSortOrder The configuration of the default sort order on the table.
		DefaultSortOrder *UpdateTable200DefaultSortOrder `json:"defaultSortOrder,omitempty"`

		// Description The description of the table, as configured by an application administrator.
		Description *string `json:"description,omitempty"`

		// Id The unique identifier (dbid) of the table.
		Id *string `json:"id,omitempty"`

		// KeyFieldId The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
		KeyFieldId *int `json:"keyFieldId,omitempty"`

		// Name The name of the table.
		Name *string `json:"name,omitempty"`

		// NextFieldId The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
		NextFieldId *int `json:"nextFieldId,omitempty"`

		// NextRecordId The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
		NextRecordId *int `json:"nextRecordId,omitempty"`

		// PluralRecordName The builder-configured plural noun of the table.
		PluralRecordName *string `json:"pluralRecordName,omitempty"`

		// SingleRecordName The builder-configured singular noun of the table.
		SingleRecordName *string `json:"singleRecordName,omitempty"`

		// SizeLimit The size limit for the table.
		SizeLimit *string `json:"sizeLimit,omitempty"`

		// SpaceRemaining The amount of space remaining for use by the table.
		SpaceRemaining *string `json:"spaceRemaining,omitempty"`

		// SpaceUsed The amount of space currently being used by the table.
		SpaceUsed *string `json:"spaceUsed,omitempty"`

		// Updated The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		Updated              *string                `json:"updated,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type UpdateTable200DefaultSortOrder string

// Status returns HTTPResponse.Status
func (r UpdateTableResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTableResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ChildTableId The child table id of the relationship.
		ChildTableId string `json:"childTableId"`

		// ForeignKeyField The foreign key field information.
		ForeignKeyField *CreateRelationship_200_ForeignKeyField `json:"foreignKeyField,omitempty"`

		// Id The relationship id (foreign key field id).
		Id int `json:"id"`

		// IsCrossApp Whether this is a cross-app relationship.
		IsCrossApp bool `json:"isCrossApp"`

		// LookupFields The lookup fields array.
		LookupFields *[]CreateRelationship_200_LookupFields_Item `json:"lookupFields,omitempty"`

		// ParentTableId The parent table id of the relationship.
		ParentTableId string `json:"parentTableId"`

		// SummaryFields The summary fields array.
		SummaryFields        *[]CreateRelationship_200_SummaryFields_Item `json:"summaryFields,omitempty"`
		AdditionalProperties map[string]interface{}                       `json:"-"`
	}
}
type CreateRelationship_200_ForeignKeyField struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type CreateRelationship_200_LookupFields_Item struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type CreateRelationship_200_SummaryFields_Item struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r CreateRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// RelationshipId The relationship id.
		RelationshipId       int                    `json:"relationshipId"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRelationshipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ChildTableId The child table id of the relationship.
		ChildTableId string `json:"childTableId"`

		// ForeignKeyField The foreign key field information.
		ForeignKeyField *UpdateRelationship_200_ForeignKeyField `json:"foreignKeyField,omitempty"`

		// Id The relationship id (foreign key field id).
		Id int `json:"id"`

		// IsCrossApp Whether this is a cross-app relationship.
		IsCrossApp bool `json:"isCrossApp"`

		// LookupFields The lookup fields array.
		LookupFields *[]UpdateRelationship_200_LookupFields_Item `json:"lookupFields,omitempty"`

		// ParentTableId The parent table id of the relationship.
		ParentTableId string `json:"parentTableId"`

		// SummaryFields The summary fields array.
		SummaryFields        *[]UpdateRelationship_200_SummaryFields_Item `json:"summaryFields,omitempty"`
		AdditionalProperties map[string]interface{}                       `json:"-"`
	}
}
type UpdateRelationship_200_ForeignKeyField struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type UpdateRelationship_200_LookupFields_Item struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type UpdateRelationship_200_SummaryFields_Item struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r UpdateRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRelationshipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Metadata Additional information about the results that may be helpful.
		Metadata *GetRelationships_200_Metadata `json:"metadata,omitempty"`

		// Relationships The relationships in a table.
		Relationships        []GetRelationships_200_Relationships_Item `json:"relationships"`
		AdditionalProperties map[string]interface{}                    `json:"-"`
	}
}
type GetRelationships_200_Metadata struct {
	// NumRelationships The number of relationships in the current response object.
	NumRelationships *int `json:"numRelationships,omitempty"`

	// Skip The number of relationships to skip.
	Skip *int `json:"skip,omitempty"`

	// TotalRelationships The total number of relationships.
	TotalRelationships   *int                   `json:"totalRelationships,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetRelationships_200_Relationships_ForeignKeyField struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetRelationships_200_Relationships_LookupFields_Item struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetRelationships_200_Relationships_SummaryFields_Item struct {
	// Id Field id.
	Id *int `json:"id,omitempty"`

	// Label Field label.
	Label *string `json:"label,omitempty"`

	// Type Field type.
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetRelationships_200_Relationships_Item struct {
	// ChildTableId The child table id of the relationship.
	ChildTableId string `json:"childTableId"`

	// ForeignKeyField The foreign key field information.
	ForeignKeyField *GetRelationships_200_Relationships_ForeignKeyField `json:"foreignKeyField,omitempty"`

	// Id The relationship id (foreign key field id).
	Id int `json:"id"`

	// IsCrossApp Whether this is a cross-app relationship.
	IsCrossApp bool `json:"isCrossApp"`

	// LookupFields The lookup fields array.
	LookupFields *[]GetRelationships_200_Relationships_LookupFields_Item `json:"lookupFields,omitempty"`

	// ParentTableId The parent table id of the relationship.
	ParentTableId string `json:"parentTableId"`

	// SummaryFields The summary fields array.
	SummaryFields        *[]GetRelationships_200_Relationships_SummaryFields_Item `json:"summaryFields,omitempty"`
	AdditionalProperties map[string]interface{}                                   `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetRelationshipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRelationshipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Metadata Additional request information
		Metadata GetUsers_200_Metadata `json:"metadata"`

		// Users A list of users found in an account with the given criterias
		Users                []GetUsers_200_Users_Item `json:"users"`
		AdditionalProperties map[string]interface{}    `json:"-"`
	}
}
type GetUsers_200_Metadata struct {
	NextPageToken        string                 `json:"nextPageToken"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetUsers_200_Users_Item struct {
	EmailAddress         string                 `json:"emailAddress"`
	FirstName            string                 `json:"firstName"`
	HashId               string                 `json:"hashId"`
	LastName             string                 `json:"lastName"`
	UserName             string                 `json:"userName"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DenyUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of users that couldn't be denied. This also includes the ID's of users that are not valid.
		Failure []string `json:"failure"`

		// Success A list of users that have successfully been denied.
		Success              []string               `json:"success"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r DenyUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DenyUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DenyUsersAndGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of users that couldn't be denied. This also includes the ID's of users that are not valid.
		Failure []string `json:"failure"`

		// Success A list of users that have successfully been denied.
		Success              []string               `json:"success"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r DenyUsersAndGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DenyUsersAndGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UndenyUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Failure A list of users that couldn't be undenied. This also includes the ID's of users that are not valid.
		Failure []string `json:"failure"`

		// Success A list of users that have successfully been undenied.
		Success              []string               `json:"success"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r UndenyUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UndenyUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The user token id.
		Id                   *int                   `json:"id,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CloneUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Active Whether the user token is active.
		Active *bool `json:"active,omitempty"`

		// Apps The list of apps this user token is assigned to.
		Apps *[]CloneUserToken_200_Apps_Item `json:"apps,omitempty"`

		// Description User Token description.
		Description *string `json:"description,omitempty"`

		// Id User Token id.
		Id *int `json:"id,omitempty"`

		// LastUsed The last date this user token was used, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		LastUsed *string `json:"lastUsed,omitempty"`

		// Name User Token name.
		Name *string `json:"name,omitempty"`

		// Token User Token value.
		Token                *string                `json:"token,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type CloneUserToken_200_Apps_Item struct {
	// Id The unique identifier for this application.
	Id *string `json:"id,omitempty"`

	// Name The application's name.
	Name                 *string                `json:"name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r CloneUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CloneUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeactivateUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id The user token id.
		Id                   *int                   `json:"id,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}

// Status returns HTTPResponse.Status
func (r DeactivateUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeactivateUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferUserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Active Whether the user token is active.
		Active *bool `json:"active,omitempty"`

		// Apps The list of apps this user token is assigned to.
		Apps *[]TransferUserToken_200_Apps_Item `json:"apps,omitempty"`

		// Description User Token description.
		Description *string `json:"description,omitempty"`

		// Id User Token id.
		Id *int `json:"id,omitempty"`

		// LastUsed The last date this user token was used, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
		LastUsed *string `json:"lastUsed,omitempty"`

		// Name User Token name.
		Name                 *string                `json:"name,omitempty"`
		AdditionalProperties map[string]interface{} `json:"-"`
	}
}
type TransferUserToken_200_Apps_Item struct {
	// Id The unique identifier for this application.
	Id *string `json:"id,omitempty"`

	// Name The application's name.
	Name                 *string                `json:"name,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// Status returns HTTPResponse.Status
func (r TransferUserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferUserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PlatformAnalyticEventSummariesWithBodyWithResponse request with arbitrary body returning *PlatformAnalyticEventSummariesResponse
func (c *ClientWithResponses) PlatformAnalyticEventSummariesWithBodyWithResponse(ctx context.Context, params *PlatformAnalyticEventSummariesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PlatformAnalyticEventSummariesResponse, error) {
	rsp, err := c.PlatformAnalyticEventSummariesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlatformAnalyticEventSummariesResponse(rsp)
}

func (c *ClientWithResponses) PlatformAnalyticEventSummariesWithResponse(ctx context.Context, params *PlatformAnalyticEventSummariesParams, body PlatformAnalyticEventSummariesJSONRequestBody, reqEditors ...RequestEditorFn) (*PlatformAnalyticEventSummariesResponse, error) {
	rsp, err := c.PlatformAnalyticEventSummaries(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlatformAnalyticEventSummariesResponse(rsp)
}

// PlatformAnalyticReadsWithResponse request returning *PlatformAnalyticReadsResponse
func (c *ClientWithResponses) PlatformAnalyticReadsWithResponse(ctx context.Context, params *PlatformAnalyticReadsParams, reqEditors ...RequestEditorFn) (*PlatformAnalyticReadsResponse, error) {
	rsp, err := c.PlatformAnalyticReads(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePlatformAnalyticReadsResponse(rsp)
}

// RemoveTrusteesWithBodyWithResponse request with arbitrary body returning *RemoveTrusteesResponse
func (c *ClientWithResponses) RemoveTrusteesWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveTrusteesResponse, error) {
	rsp, err := c.RemoveTrusteesWithBody(ctx, appId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTrusteesResponse(rsp)
}

func (c *ClientWithResponses) RemoveTrusteesWithResponse(ctx context.Context, appId string, body RemoveTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveTrusteesResponse, error) {
	rsp, err := c.RemoveTrustees(ctx, appId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveTrusteesResponse(rsp)
}

// GetTrusteesWithResponse request returning *GetTrusteesResponse
func (c *ClientWithResponses) GetTrusteesWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetTrusteesResponse, error) {
	rsp, err := c.GetTrustees(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTrusteesResponse(rsp)
}

// UpdateTrusteesWithBodyWithResponse request with arbitrary body returning *UpdateTrusteesResponse
func (c *ClientWithResponses) UpdateTrusteesWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTrusteesResponse, error) {
	rsp, err := c.UpdateTrusteesWithBody(ctx, appId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTrusteesResponse(rsp)
}

func (c *ClientWithResponses) UpdateTrusteesWithResponse(ctx context.Context, appId string, body UpdateTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTrusteesResponse, error) {
	rsp, err := c.UpdateTrustees(ctx, appId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTrusteesResponse(rsp)
}

// AddTrusteesWithBodyWithResponse request with arbitrary body returning *AddTrusteesResponse
func (c *ClientWithResponses) AddTrusteesWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddTrusteesResponse, error) {
	rsp, err := c.AddTrusteesWithBody(ctx, appId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTrusteesResponse(rsp)
}

func (c *ClientWithResponses) AddTrusteesWithResponse(ctx context.Context, appId string, body AddTrusteesJSONRequestBody, reqEditors ...RequestEditorFn) (*AddTrusteesResponse, error) {
	rsp, err := c.AddTrustees(ctx, appId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddTrusteesResponse(rsp)
}

// CreateAppWithBodyWithResponse request with arbitrary body returning *CreateAppResponse
func (c *ClientWithResponses) CreateAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.CreateAppWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResponse(rsp)
}

func (c *ClientWithResponses) CreateAppWithResponse(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResponse, error) {
	rsp, err := c.CreateApp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResponse(rsp)
}

// DeleteAppWithBodyWithResponse request with arbitrary body returning *DeleteAppResponse
func (c *ClientWithResponses) DeleteAppWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error) {
	rsp, err := c.DeleteAppWithBody(ctx, appId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppResponse(rsp)
}

func (c *ClientWithResponses) DeleteAppWithResponse(ctx context.Context, appId string, body DeleteAppJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAppResponse, error) {
	rsp, err := c.DeleteApp(ctx, appId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppResponse(rsp)
}

// GetAppWithResponse request returning *GetAppResponse
func (c *ClientWithResponses) GetAppWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetAppResponse, error) {
	rsp, err := c.GetApp(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppResponse(rsp)
}

// UpdateAppWithBodyWithResponse request with arbitrary body returning *UpdateAppResponse
func (c *ClientWithResponses) UpdateAppWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateAppWithBody(ctx, appId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

func (c *ClientWithResponses) UpdateAppWithResponse(ctx context.Context, appId string, body UpdateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAppResponse, error) {
	rsp, err := c.UpdateApp(ctx, appId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAppResponse(rsp)
}

// CopyAppWithBodyWithResponse request with arbitrary body returning *CopyAppResponse
func (c *ClientWithResponses) CopyAppWithBodyWithResponse(ctx context.Context, appId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CopyAppResponse, error) {
	rsp, err := c.CopyAppWithBody(ctx, appId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyAppResponse(rsp)
}

func (c *ClientWithResponses) CopyAppWithResponse(ctx context.Context, appId string, body CopyAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CopyAppResponse, error) {
	rsp, err := c.CopyApp(ctx, appId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCopyAppResponse(rsp)
}

// GetAppEventsWithResponse request returning *GetAppEventsResponse
func (c *ClientWithResponses) GetAppEventsWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetAppEventsResponse, error) {
	rsp, err := c.GetAppEvents(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppEventsResponse(rsp)
}

// GetRolesWithResponse request returning *GetRolesResponse
func (c *ClientWithResponses) GetRolesWithResponse(ctx context.Context, appId string, reqEditors ...RequestEditorFn) (*GetRolesResponse, error) {
	rsp, err := c.GetRoles(ctx, appId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesResponse(rsp)
}

// AuditWithBodyWithResponse request with arbitrary body returning *AuditResponse
func (c *ClientWithResponses) AuditWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AuditResponse, error) {
	rsp, err := c.AuditWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuditResponse(rsp)
}

func (c *ClientWithResponses) AuditWithResponse(ctx context.Context, body AuditJSONRequestBody, reqEditors ...RequestEditorFn) (*AuditResponse, error) {
	rsp, err := c.Audit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAuditResponse(rsp)
}

// ExchangeSsoTokenWithBodyWithResponse request with arbitrary body returning *ExchangeSsoTokenResponse
func (c *ClientWithResponses) ExchangeSsoTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExchangeSsoTokenResponse, error) {
	rsp, err := c.ExchangeSsoTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeSsoTokenResponse(rsp)
}

func (c *ClientWithResponses) ExchangeSsoTokenWithResponse(ctx context.Context, body ExchangeSsoTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*ExchangeSsoTokenResponse, error) {
	rsp, err := c.ExchangeSsoToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExchangeSsoTokenResponse(rsp)
}

// GetTempTokenDBIDWithResponse request returning *GetTempTokenDBIDResponse
func (c *ClientWithResponses) GetTempTokenDBIDWithResponse(ctx context.Context, dbid string, params *GetTempTokenDBIDParams, reqEditors ...RequestEditorFn) (*GetTempTokenDBIDResponse, error) {
	rsp, err := c.GetTempTokenDBID(ctx, dbid, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTempTokenDBIDResponse(rsp)
}

// GenerateDocumentWithResponse request returning *GenerateDocumentResponse
func (c *ClientWithResponses) GenerateDocumentWithResponse(ctx context.Context, templateId float32, params *GenerateDocumentParams, reqEditors ...RequestEditorFn) (*GenerateDocumentResponse, error) {
	rsp, err := c.GenerateDocument(ctx, templateId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateDocumentResponse(rsp)
}

// DeleteFieldsWithBodyWithResponse request with arbitrary body returning *DeleteFieldsResponse
func (c *ClientWithResponses) DeleteFieldsWithBodyWithResponse(ctx context.Context, params *DeleteFieldsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteFieldsResponse, error) {
	rsp, err := c.DeleteFieldsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFieldsResponse(rsp)
}

func (c *ClientWithResponses) DeleteFieldsWithResponse(ctx context.Context, params *DeleteFieldsParams, body DeleteFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteFieldsResponse, error) {
	rsp, err := c.DeleteFields(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFieldsResponse(rsp)
}

// GetFieldsWithResponse request returning *GetFieldsResponse
func (c *ClientWithResponses) GetFieldsWithResponse(ctx context.Context, params *GetFieldsParams, reqEditors ...RequestEditorFn) (*GetFieldsResponse, error) {
	rsp, err := c.GetFields(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFieldsResponse(rsp)
}

// CreateFieldWithBodyWithResponse request with arbitrary body returning *CreateFieldResponse
func (c *ClientWithResponses) CreateFieldWithBodyWithResponse(ctx context.Context, params *CreateFieldParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFieldResponse, error) {
	rsp, err := c.CreateFieldWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFieldResponse(rsp)
}

func (c *ClientWithResponses) CreateFieldWithResponse(ctx context.Context, params *CreateFieldParams, body CreateFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFieldResponse, error) {
	rsp, err := c.CreateField(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFieldResponse(rsp)
}

// GetFieldsUsageWithResponse request returning *GetFieldsUsageResponse
func (c *ClientWithResponses) GetFieldsUsageWithResponse(ctx context.Context, params *GetFieldsUsageParams, reqEditors ...RequestEditorFn) (*GetFieldsUsageResponse, error) {
	rsp, err := c.GetFieldsUsage(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFieldsUsageResponse(rsp)
}

// GetFieldUsageWithResponse request returning *GetFieldUsageResponse
func (c *ClientWithResponses) GetFieldUsageWithResponse(ctx context.Context, fieldId int, params *GetFieldUsageParams, reqEditors ...RequestEditorFn) (*GetFieldUsageResponse, error) {
	rsp, err := c.GetFieldUsage(ctx, fieldId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFieldUsageResponse(rsp)
}

// GetFieldWithResponse request returning *GetFieldResponse
func (c *ClientWithResponses) GetFieldWithResponse(ctx context.Context, fieldId int, params *GetFieldParams, reqEditors ...RequestEditorFn) (*GetFieldResponse, error) {
	rsp, err := c.GetField(ctx, fieldId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFieldResponse(rsp)
}

// UpdateFieldWithBodyWithResponse request with arbitrary body returning *UpdateFieldResponse
func (c *ClientWithResponses) UpdateFieldWithBodyWithResponse(ctx context.Context, fieldId int, params *UpdateFieldParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFieldResponse, error) {
	rsp, err := c.UpdateFieldWithBody(ctx, fieldId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFieldResponse(rsp)
}

func (c *ClientWithResponses) UpdateFieldWithResponse(ctx context.Context, fieldId int, params *UpdateFieldParams, body UpdateFieldJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFieldResponse, error) {
	rsp, err := c.UpdateField(ctx, fieldId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFieldResponse(rsp)
}

// DeleteFileWithResponse request returning *DeleteFileResponse
func (c *ClientWithResponses) DeleteFileWithResponse(ctx context.Context, tableId string, recordId int, fieldId int, versionNumber int, reqEditors ...RequestEditorFn) (*DeleteFileResponse, error) {
	rsp, err := c.DeleteFile(ctx, tableId, recordId, fieldId, versionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFileResponse(rsp)
}

// DownloadFileWithResponse request returning *DownloadFileResponse
func (c *ClientWithResponses) DownloadFileWithResponse(ctx context.Context, tableId string, recordId int, fieldId int, versionNumber int, reqEditors ...RequestEditorFn) (*DownloadFileResponse, error) {
	rsp, err := c.DownloadFile(ctx, tableId, recordId, fieldId, versionNumber, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadFileResponse(rsp)
}

// RunFormulaWithBodyWithResponse request with arbitrary body returning *RunFormulaResponse
func (c *ClientWithResponses) RunFormulaWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunFormulaResponse, error) {
	rsp, err := c.RunFormulaWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFormulaResponse(rsp)
}

func (c *ClientWithResponses) RunFormulaWithResponse(ctx context.Context, body RunFormulaJSONRequestBody, reqEditors ...RequestEditorFn) (*RunFormulaResponse, error) {
	rsp, err := c.RunFormula(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunFormulaResponse(rsp)
}

// RemoveManagersFromGroupWithBodyWithResponse request with arbitrary body returning *RemoveManagersFromGroupResponse
func (c *ClientWithResponses) RemoveManagersFromGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveManagersFromGroupResponse, error) {
	rsp, err := c.RemoveManagersFromGroupWithBody(ctx, gid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveManagersFromGroupResponse(rsp)
}

func (c *ClientWithResponses) RemoveManagersFromGroupWithResponse(ctx context.Context, gid float32, body RemoveManagersFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveManagersFromGroupResponse, error) {
	rsp, err := c.RemoveManagersFromGroup(ctx, gid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveManagersFromGroupResponse(rsp)
}

// AddManagersToGroupWithBodyWithResponse request with arbitrary body returning *AddManagersToGroupResponse
func (c *ClientWithResponses) AddManagersToGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddManagersToGroupResponse, error) {
	rsp, err := c.AddManagersToGroupWithBody(ctx, gid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddManagersToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddManagersToGroupWithResponse(ctx context.Context, gid float32, body AddManagersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddManagersToGroupResponse, error) {
	rsp, err := c.AddManagersToGroup(ctx, gid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddManagersToGroupResponse(rsp)
}

// RemoveMembersFromGroupWithBodyWithResponse request with arbitrary body returning *RemoveMembersFromGroupResponse
func (c *ClientWithResponses) RemoveMembersFromGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveMembersFromGroupResponse, error) {
	rsp, err := c.RemoveMembersFromGroupWithBody(ctx, gid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMembersFromGroupResponse(rsp)
}

func (c *ClientWithResponses) RemoveMembersFromGroupWithResponse(ctx context.Context, gid float32, body RemoveMembersFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveMembersFromGroupResponse, error) {
	rsp, err := c.RemoveMembersFromGroup(ctx, gid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveMembersFromGroupResponse(rsp)
}

// AddMembersToGroupWithBodyWithResponse request with arbitrary body returning *AddMembersToGroupResponse
func (c *ClientWithResponses) AddMembersToGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddMembersToGroupResponse, error) {
	rsp, err := c.AddMembersToGroupWithBody(ctx, gid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMembersToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddMembersToGroupWithResponse(ctx context.Context, gid float32, body AddMembersToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddMembersToGroupResponse, error) {
	rsp, err := c.AddMembersToGroup(ctx, gid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddMembersToGroupResponse(rsp)
}

// RemoveSubgroupsFromGroupWithBodyWithResponse request with arbitrary body returning *RemoveSubgroupsFromGroupResponse
func (c *ClientWithResponses) RemoveSubgroupsFromGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RemoveSubgroupsFromGroupResponse, error) {
	rsp, err := c.RemoveSubgroupsFromGroupWithBody(ctx, gid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubgroupsFromGroupResponse(rsp)
}

func (c *ClientWithResponses) RemoveSubgroupsFromGroupWithResponse(ctx context.Context, gid float32, body RemoveSubgroupsFromGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*RemoveSubgroupsFromGroupResponse, error) {
	rsp, err := c.RemoveSubgroupsFromGroup(ctx, gid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveSubgroupsFromGroupResponse(rsp)
}

// AddSubgroupsToGroupWithBodyWithResponse request with arbitrary body returning *AddSubgroupsToGroupResponse
func (c *ClientWithResponses) AddSubgroupsToGroupWithBodyWithResponse(ctx context.Context, gid float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddSubgroupsToGroupResponse, error) {
	rsp, err := c.AddSubgroupsToGroupWithBody(ctx, gid, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSubgroupsToGroupResponse(rsp)
}

func (c *ClientWithResponses) AddSubgroupsToGroupWithResponse(ctx context.Context, gid float32, body AddSubgroupsToGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*AddSubgroupsToGroupResponse, error) {
	rsp, err := c.AddSubgroupsToGroup(ctx, gid, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddSubgroupsToGroupResponse(rsp)
}

// DeleteRecordsWithBodyWithResponse request with arbitrary body returning *DeleteRecordsResponse
func (c *ClientWithResponses) DeleteRecordsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteRecordsResponse, error) {
	rsp, err := c.DeleteRecordsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordsResponse(rsp)
}

func (c *ClientWithResponses) DeleteRecordsWithResponse(ctx context.Context, body DeleteRecordsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteRecordsResponse, error) {
	rsp, err := c.DeleteRecords(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRecordsResponse(rsp)
}

// UpsertWithBodyWithResponse request with arbitrary body returning *UpsertResponse
func (c *ClientWithResponses) UpsertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpsertResponse, error) {
	rsp, err := c.UpsertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertResponse(rsp)
}

func (c *ClientWithResponses) UpsertWithResponse(ctx context.Context, body UpsertJSONRequestBody, reqEditors ...RequestEditorFn) (*UpsertResponse, error) {
	rsp, err := c.Upsert(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpsertResponse(rsp)
}

// RecordsModifiedSinceWithBodyWithResponse request with arbitrary body returning *RecordsModifiedSinceResponse
func (c *ClientWithResponses) RecordsModifiedSinceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RecordsModifiedSinceResponse, error) {
	rsp, err := c.RecordsModifiedSinceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordsModifiedSinceResponse(rsp)
}

func (c *ClientWithResponses) RecordsModifiedSinceWithResponse(ctx context.Context, body RecordsModifiedSinceJSONRequestBody, reqEditors ...RequestEditorFn) (*RecordsModifiedSinceResponse, error) {
	rsp, err := c.RecordsModifiedSince(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRecordsModifiedSinceResponse(rsp)
}

// RunQueryWithBodyWithResponse request with arbitrary body returning *RunQueryResponse
func (c *ClientWithResponses) RunQueryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunQueryResponse, error) {
	rsp, err := c.RunQueryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunQueryResponse(rsp)
}

func (c *ClientWithResponses) RunQueryWithResponse(ctx context.Context, body RunQueryJSONRequestBody, reqEditors ...RequestEditorFn) (*RunQueryResponse, error) {
	rsp, err := c.RunQuery(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunQueryResponse(rsp)
}

// GetTableReportsWithResponse request returning *GetTableReportsResponse
func (c *ClientWithResponses) GetTableReportsWithResponse(ctx context.Context, params *GetTableReportsParams, reqEditors ...RequestEditorFn) (*GetTableReportsResponse, error) {
	rsp, err := c.GetTableReports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableReportsResponse(rsp)
}

// GetReportWithResponse request returning *GetReportResponse
func (c *ClientWithResponses) GetReportWithResponse(ctx context.Context, reportId string, params *GetReportParams, reqEditors ...RequestEditorFn) (*GetReportResponse, error) {
	rsp, err := c.GetReport(ctx, reportId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportResponse(rsp)
}

// RunReportWithBodyWithResponse request with arbitrary body returning *RunReportResponse
func (c *ClientWithResponses) RunReportWithBodyWithResponse(ctx context.Context, reportId string, params *RunReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunReportResponse, error) {
	rsp, err := c.RunReportWithBody(ctx, reportId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunReportResponse(rsp)
}

func (c *ClientWithResponses) RunReportWithResponse(ctx context.Context, reportId string, params *RunReportParams, body RunReportJSONRequestBody, reqEditors ...RequestEditorFn) (*RunReportResponse, error) {
	rsp, err := c.RunReport(ctx, reportId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunReportResponse(rsp)
}

// CreateSolutionWithBodyWithResponse request with arbitrary body returning *CreateSolutionResponse
func (c *ClientWithResponses) CreateSolutionWithBodyWithResponse(ctx context.Context, params *CreateSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSolutionResponse, error) {
	rsp, err := c.CreateSolutionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolutionResponse(rsp)
}

func (c *ClientWithResponses) CreateSolutionWithResponse(ctx context.Context, params *CreateSolutionParams, body CreateSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSolutionResponse, error) {
	rsp, err := c.CreateSolution(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolutionResponse(rsp)
}

// CreateSolutionFromRecordWithResponse request returning *CreateSolutionFromRecordResponse
func (c *ClientWithResponses) CreateSolutionFromRecordWithResponse(ctx context.Context, params *CreateSolutionFromRecordParams, reqEditors ...RequestEditorFn) (*CreateSolutionFromRecordResponse, error) {
	rsp, err := c.CreateSolutionFromRecord(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSolutionFromRecordResponse(rsp)
}

// ExportSolutionWithResponse request returning *ExportSolutionResponse
func (c *ClientWithResponses) ExportSolutionWithResponse(ctx context.Context, solutionId string, params *ExportSolutionParams, reqEditors ...RequestEditorFn) (*ExportSolutionResponse, error) {
	rsp, err := c.ExportSolution(ctx, solutionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolutionResponse(rsp)
}

// UpdateSolutionWithBodyWithResponse request with arbitrary body returning *UpdateSolutionResponse
func (c *ClientWithResponses) UpdateSolutionWithBodyWithResponse(ctx context.Context, solutionId string, params *UpdateSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSolutionResponse, error) {
	rsp, err := c.UpdateSolutionWithBody(ctx, solutionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSolutionResponse(rsp)
}

func (c *ClientWithResponses) UpdateSolutionWithResponse(ctx context.Context, solutionId string, params *UpdateSolutionParams, body UpdateSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSolutionResponse, error) {
	rsp, err := c.UpdateSolution(ctx, solutionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSolutionResponse(rsp)
}

// ChangesetSolutionWithBodyWithResponse request with arbitrary body returning *ChangesetSolutionResponse
func (c *ClientWithResponses) ChangesetSolutionWithBodyWithResponse(ctx context.Context, solutionId string, params *ChangesetSolutionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangesetSolutionResponse, error) {
	rsp, err := c.ChangesetSolutionWithBody(ctx, solutionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangesetSolutionResponse(rsp)
}

func (c *ClientWithResponses) ChangesetSolutionWithResponse(ctx context.Context, solutionId string, params *ChangesetSolutionParams, body ChangesetSolutionJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangesetSolutionResponse, error) {
	rsp, err := c.ChangesetSolution(ctx, solutionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangesetSolutionResponse(rsp)
}

// ChangesetSolutionFromRecordWithResponse request returning *ChangesetSolutionFromRecordResponse
func (c *ClientWithResponses) ChangesetSolutionFromRecordWithResponse(ctx context.Context, solutionId string, params *ChangesetSolutionFromRecordParams, reqEditors ...RequestEditorFn) (*ChangesetSolutionFromRecordResponse, error) {
	rsp, err := c.ChangesetSolutionFromRecord(ctx, solutionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangesetSolutionFromRecordResponse(rsp)
}

// UpdateSolutionToRecordWithResponse request returning *UpdateSolutionToRecordResponse
func (c *ClientWithResponses) UpdateSolutionToRecordWithResponse(ctx context.Context, solutionId string, params *UpdateSolutionToRecordParams, reqEditors ...RequestEditorFn) (*UpdateSolutionToRecordResponse, error) {
	rsp, err := c.UpdateSolutionToRecord(ctx, solutionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSolutionToRecordResponse(rsp)
}

// GetSolutionPublicWithResponse request returning *GetSolutionPublicResponse
func (c *ClientWithResponses) GetSolutionPublicWithResponse(ctx context.Context, solutionId string, params *GetSolutionPublicParams, reqEditors ...RequestEditorFn) (*GetSolutionPublicResponse, error) {
	rsp, err := c.GetSolutionPublic(ctx, solutionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSolutionPublicResponse(rsp)
}

// ExportSolutionToRecordWithResponse request returning *ExportSolutionToRecordResponse
func (c *ClientWithResponses) ExportSolutionToRecordWithResponse(ctx context.Context, solutionId string, params *ExportSolutionToRecordParams, reqEditors ...RequestEditorFn) (*ExportSolutionToRecordResponse, error) {
	rsp, err := c.ExportSolutionToRecord(ctx, solutionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportSolutionToRecordResponse(rsp)
}

// GetAppTablesWithResponse request returning *GetAppTablesResponse
func (c *ClientWithResponses) GetAppTablesWithResponse(ctx context.Context, params *GetAppTablesParams, reqEditors ...RequestEditorFn) (*GetAppTablesResponse, error) {
	rsp, err := c.GetAppTables(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppTablesResponse(rsp)
}

// CreateTableWithBodyWithResponse request with arbitrary body returning *CreateTableResponse
func (c *ClientWithResponses) CreateTableWithBodyWithResponse(ctx context.Context, params *CreateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTableWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

func (c *ClientWithResponses) CreateTableWithResponse(ctx context.Context, params *CreateTableParams, body CreateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTableResponse, error) {
	rsp, err := c.CreateTable(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTableResponse(rsp)
}

// DeleteTableWithResponse request returning *DeleteTableResponse
func (c *ClientWithResponses) DeleteTableWithResponse(ctx context.Context, tableId string, params *DeleteTableParams, reqEditors ...RequestEditorFn) (*DeleteTableResponse, error) {
	rsp, err := c.DeleteTable(ctx, tableId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTableResponse(rsp)
}

// GetTableWithResponse request returning *GetTableResponse
func (c *ClientWithResponses) GetTableWithResponse(ctx context.Context, tableId string, params *GetTableParams, reqEditors ...RequestEditorFn) (*GetTableResponse, error) {
	rsp, err := c.GetTable(ctx, tableId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableResponse(rsp)
}

// UpdateTableWithBodyWithResponse request with arbitrary body returning *UpdateTableResponse
func (c *ClientWithResponses) UpdateTableWithBodyWithResponse(ctx context.Context, tableId string, params *UpdateTableParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error) {
	rsp, err := c.UpdateTableWithBody(ctx, tableId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTableResponse(rsp)
}

func (c *ClientWithResponses) UpdateTableWithResponse(ctx context.Context, tableId string, params *UpdateTableParams, body UpdateTableJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTableResponse, error) {
	rsp, err := c.UpdateTable(ctx, tableId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTableResponse(rsp)
}

// CreateRelationshipWithBodyWithResponse request with arbitrary body returning *CreateRelationshipResponse
func (c *ClientWithResponses) CreateRelationshipWithBodyWithResponse(ctx context.Context, tableId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRelationshipResponse, error) {
	rsp, err := c.CreateRelationshipWithBody(ctx, tableId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRelationshipResponse(rsp)
}

func (c *ClientWithResponses) CreateRelationshipWithResponse(ctx context.Context, tableId string, body CreateRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRelationshipResponse, error) {
	rsp, err := c.CreateRelationship(ctx, tableId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRelationshipResponse(rsp)
}

// DeleteRelationshipWithResponse request returning *DeleteRelationshipResponse
func (c *ClientWithResponses) DeleteRelationshipWithResponse(ctx context.Context, tableId string, relationshipId float32, reqEditors ...RequestEditorFn) (*DeleteRelationshipResponse, error) {
	rsp, err := c.DeleteRelationship(ctx, tableId, relationshipId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRelationshipResponse(rsp)
}

// UpdateRelationshipWithBodyWithResponse request with arbitrary body returning *UpdateRelationshipResponse
func (c *ClientWithResponses) UpdateRelationshipWithBodyWithResponse(ctx context.Context, tableId string, relationshipId float32, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRelationshipResponse, error) {
	rsp, err := c.UpdateRelationshipWithBody(ctx, tableId, relationshipId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRelationshipResponse(rsp)
}

func (c *ClientWithResponses) UpdateRelationshipWithResponse(ctx context.Context, tableId string, relationshipId float32, body UpdateRelationshipJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRelationshipResponse, error) {
	rsp, err := c.UpdateRelationship(ctx, tableId, relationshipId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRelationshipResponse(rsp)
}

// GetRelationshipsWithResponse request returning *GetRelationshipsResponse
func (c *ClientWithResponses) GetRelationshipsWithResponse(ctx context.Context, tableId string, params *GetRelationshipsParams, reqEditors ...RequestEditorFn) (*GetRelationshipsResponse, error) {
	rsp, err := c.GetRelationships(ctx, tableId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRelationshipsResponse(rsp)
}

// GetUsersWithBodyWithResponse request with arbitrary body returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithBodyWithResponse(ctx context.Context, params *GetUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, body GetUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// DenyUsersWithBodyWithResponse request with arbitrary body returning *DenyUsersResponse
func (c *ClientWithResponses) DenyUsersWithBodyWithResponse(ctx context.Context, params *DenyUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DenyUsersResponse, error) {
	rsp, err := c.DenyUsersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDenyUsersResponse(rsp)
}

func (c *ClientWithResponses) DenyUsersWithResponse(ctx context.Context, params *DenyUsersParams, body DenyUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*DenyUsersResponse, error) {
	rsp, err := c.DenyUsers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDenyUsersResponse(rsp)
}

// DenyUsersAndGroupsWithBodyWithResponse request with arbitrary body returning *DenyUsersAndGroupsResponse
func (c *ClientWithResponses) DenyUsersAndGroupsWithBodyWithResponse(ctx context.Context, shouldDeleteFromGroups bool, params *DenyUsersAndGroupsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DenyUsersAndGroupsResponse, error) {
	rsp, err := c.DenyUsersAndGroupsWithBody(ctx, shouldDeleteFromGroups, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDenyUsersAndGroupsResponse(rsp)
}

func (c *ClientWithResponses) DenyUsersAndGroupsWithResponse(ctx context.Context, shouldDeleteFromGroups bool, params *DenyUsersAndGroupsParams, body DenyUsersAndGroupsJSONRequestBody, reqEditors ...RequestEditorFn) (*DenyUsersAndGroupsResponse, error) {
	rsp, err := c.DenyUsersAndGroups(ctx, shouldDeleteFromGroups, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDenyUsersAndGroupsResponse(rsp)
}

// UndenyUsersWithBodyWithResponse request with arbitrary body returning *UndenyUsersResponse
func (c *ClientWithResponses) UndenyUsersWithBodyWithResponse(ctx context.Context, params *UndenyUsersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UndenyUsersResponse, error) {
	rsp, err := c.UndenyUsersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUndenyUsersResponse(rsp)
}

func (c *ClientWithResponses) UndenyUsersWithResponse(ctx context.Context, params *UndenyUsersParams, body UndenyUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*UndenyUsersResponse, error) {
	rsp, err := c.UndenyUsers(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUndenyUsersResponse(rsp)
}

// DeleteUserTokenWithResponse request returning *DeleteUserTokenResponse
func (c *ClientWithResponses) DeleteUserTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteUserTokenResponse, error) {
	rsp, err := c.DeleteUserToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserTokenResponse(rsp)
}

// CloneUserTokenWithBodyWithResponse request with arbitrary body returning *CloneUserTokenResponse
func (c *ClientWithResponses) CloneUserTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CloneUserTokenResponse, error) {
	rsp, err := c.CloneUserTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneUserTokenResponse(rsp)
}

func (c *ClientWithResponses) CloneUserTokenWithResponse(ctx context.Context, body CloneUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*CloneUserTokenResponse, error) {
	rsp, err := c.CloneUserToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCloneUserTokenResponse(rsp)
}

// DeactivateUserTokenWithResponse request returning *DeactivateUserTokenResponse
func (c *ClientWithResponses) DeactivateUserTokenWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeactivateUserTokenResponse, error) {
	rsp, err := c.DeactivateUserToken(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeactivateUserTokenResponse(rsp)
}

// TransferUserTokenWithBodyWithResponse request with arbitrary body returning *TransferUserTokenResponse
func (c *ClientWithResponses) TransferUserTokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TransferUserTokenResponse, error) {
	rsp, err := c.TransferUserTokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferUserTokenResponse(rsp)
}

func (c *ClientWithResponses) TransferUserTokenWithResponse(ctx context.Context, body TransferUserTokenJSONRequestBody, reqEditors ...RequestEditorFn) (*TransferUserTokenResponse, error) {
	rsp, err := c.TransferUserToken(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferUserTokenResponse(rsp)
}

// ParsePlatformAnalyticEventSummariesResponse parses an HTTP response from a PlatformAnalyticEventSummariesWithResponse call
func ParsePlatformAnalyticEventSummariesResponse(rsp *http.Response) (*PlatformAnalyticEventSummariesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlatformAnalyticEventSummariesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				EventsSummaries struct {
					// AccountId The ID of the account the events are associated with.
					AccountId string `json:"accountId"`

					// End The end date and time of the requested summaries in ISO 8601 time format.
					End time.Time `json:"end"`

					// GroupBy How the events should be grouped.
					GroupBy PlatformAnalyticEventSummaries200DataEventsSummariesGroupBy `json:"groupBy"`

					// Metadata Additional information about the results that may be helpful.
					Metadata struct {
						// NextToken Supply this token in a subsequent request to fetch the next page of results.
						NextToken string `json:"nextToken"`
					} `json:"metadata"`

					// Results An array of objects that contains Application/User information and an events object with summaries by event type.
					Results []struct {
						// EventTypes An array of events that contains specific information associated with an Application/User broken down by event type.
						EventTypes []struct {
							// BillingCategory Billing category of the event type.
							BillingCategory *PlatformAnalyticEventSummaries200DataEventsSummariesResultsEventTypesBillingCategory `json:"billingCategory,omitempty"`

							// Count Count of events associated with that event type and Application/User.
							Count *int `json:"count,omitempty"`

							// EventType Event type
							EventType *string `json:"eventType,omitempty"`
						} `json:"eventTypes"`

						// Id Id of the Application/User.
						Id string `json:"id"`

						// Name Name of the Application/User.
						Name string `json:"name"`

						// Totals Totals by billing category for the event grouping.
						Totals struct {
							All         *float32 `json:"all,omitempty"`
							Integration *float32 `json:"integration,omitempty"`
							User        *float32 `json:"user,omitempty"`
						} `json:"totals"`
					} `json:"results"`

					// Start The start date and time of the requested summaries in ISO 8601 time format.
					Start time.Time `json:"start"`

					// Totals Totals by billing category for all queried events.
					Totals struct {
						All         *float32 `json:"all,omitempty"`
						Integration *float32 `json:"integration,omitempty"`
						User        *float32 `json:"user,omitempty"`
					} `json:"totals"`
					Where []struct {
						// Id Id of the item to filter by.
						Id string `json:"id"`

						// Type The type of item to filter by.
						Type PlatformAnalyticEventSummaries200DataEventsSummariesWhereType `json:"type"`
					} `json:"where"`
				} `json:"eventsSummaries"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePlatformAnalyticReadsResponse parses an HTTP response from a PlatformAnalyticReadsWithResponse call
func ParsePlatformAnalyticReadsResponse(rsp *http.Response) (*PlatformAnalyticReadsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PlatformAnalyticReadsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The data object containing the read summaries.
			Data                 PlatformAnalyticReads_200_Data `json:"data"`
			AdditionalProperties map[string]interface{}         `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveTrusteesResponse parses an HTTP response from a RemoveTrusteesWithResponse call
func ParseRemoveTrusteesResponse(rsp *http.Response) (*RemoveTrusteesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveTrusteesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
			Failure []struct {
				// Error The error message associated with the trustee that could not be updated.
				Error *string `json:"error,omitempty"`

				// Trustee Object used for operations to read, create, or update trustees in an app.
				Trustee *struct {
					// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
					Id string `json:"id"`

					// RoleId The ID of the role to be assigned or currently assigned to the trustee.
					RoleId int `json:"roleId"`

					// Type The type of trustee being added. This can be a user, group, or email domain group.
					Type RemoveTrustees200FailureTrusteeType `json:"type"`
				} `json:"trustee,omitempty"`
			} `json:"failure"`

			// Success A list of trustees that have been successfully updated.
			Success []struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type RemoveTrustees200SuccessType `json:"type"`
			} `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest struct {
			// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
			Failure []struct {
				// Error The error message associated with the trustee that could not be updated.
				Error *string `json:"error,omitempty"`

				// Trustee Object used for operations to read, create, or update trustees in an app.
				Trustee *struct {
					// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
					Id string `json:"id"`

					// RoleId The ID of the role to be assigned or currently assigned to the trustee.
					RoleId int `json:"roleId"`

					// Type The type of trustee being added. This can be a user, group, or email domain group.
					Type RemoveTrustees207FailureTrusteeType `json:"type"`
				} `json:"trustee,omitempty"`
			} `json:"failure"`

			// Success A list of trustees that have been successfully updated.
			Success []struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type RemoveTrustees207SuccessType `json:"type"`
			} `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	}

	return response, nil
}

// ParseGetTrusteesResponse parses an HTTP response from a GetTrusteesWithResponse call
func ParseGetTrusteesResponse(rsp *http.Response) (*GetTrusteesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTrusteesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
			Id string `json:"id"`

			// RoleId The ID of the role to be assigned or currently assigned to the trustee.
			RoleId int `json:"roleId"`

			// Type The type of trustee being added. This can be a user, group, or email domain group.
			Type GetTrustees200Type `json:"type"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTrusteesResponse parses an HTTP response from a UpdateTrusteesWithResponse call
func ParseUpdateTrusteesResponse(rsp *http.Response) (*UpdateTrusteesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTrusteesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
			Failure []struct {
				// Error The error message associated with the trustee that could not be updated.
				Error *string `json:"error,omitempty"`

				// Trustee Object used for operations to read, create, or update trustees in an app.
				Trustee *struct {
					// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
					Id string `json:"id"`

					// OldRoleId The ID of the role to be changed for the trustee. This is used to identify the current role before updating it.
					OldRoleId int `json:"oldRoleId"`

					// RoleId The ID of the role to be assigned or currently assigned to the trustee.
					RoleId int `json:"roleId"`

					// Type The type of trustee being added. This can be a user, group, or email domain group.
					Type UpdateTrustees200FailureTrusteeType `json:"type"`
				} `json:"trustee,omitempty"`
			} `json:"failure"`

			// Success A list of trustees that have been successfully updated.
			Success []struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// OldRoleId The ID of the role to be changed for the trustee. This is used to identify the current role before updating it.
				OldRoleId int `json:"oldRoleId"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type UpdateTrustees200SuccessType `json:"type"`
			} `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest struct {
			// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
			Failure []struct {
				// Error The error message associated with the trustee that could not be updated.
				Error *string `json:"error,omitempty"`

				// Trustee Object used for operations to read, create, or update trustees in an app.
				Trustee *struct {
					// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
					Id string `json:"id"`

					// OldRoleId The ID of the role to be changed for the trustee. This is used to identify the current role before updating it.
					OldRoleId int `json:"oldRoleId"`

					// RoleId The ID of the role to be assigned or currently assigned to the trustee.
					RoleId int `json:"roleId"`

					// Type The type of trustee being added. This can be a user, group, or email domain group.
					Type UpdateTrustees207FailureTrusteeType `json:"type"`
				} `json:"trustee,omitempty"`
			} `json:"failure"`

			// Success A list of trustees that have been successfully updated.
			Success []struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// OldRoleId The ID of the role to be changed for the trustee. This is used to identify the current role before updating it.
				OldRoleId int `json:"oldRoleId"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type UpdateTrustees207SuccessType `json:"type"`
			} `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	}

	return response, nil
}

// ParseAddTrusteesResponse parses an HTTP response from a AddTrusteesWithResponse call
func ParseAddTrusteesResponse(rsp *http.Response) (*AddTrusteesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddTrusteesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
			Failure []struct {
				// Error The error message associated with the trustee that could not be updated.
				Error *string `json:"error,omitempty"`

				// Trustee Object used for operations to read, create, or update trustees in an app.
				Trustee *struct {
					// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
					Id string `json:"id"`

					// RoleId The ID of the role to be assigned or currently assigned to the trustee.
					RoleId int `json:"roleId"`

					// Type The type of trustee being added. This can be a user, group, or email domain group.
					Type AddTrustees200FailureTrusteeType `json:"type"`
				} `json:"trustee,omitempty"`
			} `json:"failure"`

			// Success A list of trustees that have been successfully updated.
			Success []struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type AddTrustees200SuccessType `json:"type"`
			} `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest struct {
			// Failure A list of trustees that were not updated. This includes invalid IDs or IDs that could not be processed.
			Failure []struct {
				// Error The error message associated with the trustee that could not be updated.
				Error *string `json:"error,omitempty"`

				// Trustee Object used for operations to read, create, or update trustees in an app.
				Trustee *struct {
					// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
					Id string `json:"id"`

					// RoleId The ID of the role to be assigned or currently assigned to the trustee.
					RoleId int `json:"roleId"`

					// Type The type of trustee being added. This can be a user, group, or email domain group.
					Type AddTrustees207FailureTrusteeType `json:"type"`
				} `json:"trustee,omitempty"`
			} `json:"failure"`

			// Success A list of trustees that have been successfully updated.
			Success []struct {
				// Id The ID of the user, group, or email domain group to be added as a trustee. For users and groups, this is the user's or group's ID in Quickbase. For email domain groups, this is the email domain.
				Id string `json:"id"`

				// RoleId The ID of the role to be assigned or currently assigned to the trustee.
				RoleId int `json:"roleId"`

				// Type The type of trustee being added. This can be a user, group, or email domain group.
				Type AddTrustees207SuccessType `json:"type"`
			} `json:"success"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	}

	return response, nil
}

// ParseCreateAppResponse parses an HTTP response from a CreateAppWithResponse call
func ParseCreateAppResponse(rsp *http.Response) (*CreateAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Created *string `json:"created,omitempty"`

			// DataClassification The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
			DataClassification *string `json:"dataClassification,omitempty"`

			// DateFormat A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/docs/how-to-localize-dates) to set the app's date format.
			DateFormat *string `json:"dateFormat,omitempty"`

			// Description The description for the app. If this property is left out, the app description will be blank.
			Description *string `json:"description,omitempty"`

			// HasEveryoneOnTheInternet Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/docs/sharing-apps-publicly)
			HasEveryoneOnTheInternet *bool `json:"hasEveryoneOnTheInternet,omitempty"`

			// Id The unique identifier for this application.
			Id *string `json:"id,omitempty"`

			// MemoryInfo Application memory info
			MemoryInfo *struct {
				// EstMemory The estimated memory of this application in gigabytes
				EstMemory *float32 `json:"estMemory,omitempty"`

				// EstMemoryInclDependentApps The estimated memory of this application and all dependent applications in gigabytes
				EstMemoryInclDependentApps *float32 `json:"estMemoryInclDependentApps,omitempty"`
			} `json:"memoryInfo,omitempty"`

			// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
			Name string `json:"name"`

			// SecurityProperties Security properties of the application
			SecurityProperties *CreateApp_200_SecurityProperties `json:"securityProperties,omitempty"`

			// TimeZone A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/docs/set-the-time-zone-for-both-the-application-and-the-account) to set the application's time zone.
			TimeZone *string `json:"timeZone,omitempty"`

			// Updated The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Updated *string `json:"updated,omitempty"`

			// Variables The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
			Variables            *[]CreateApp_200_Variables_Item `json:"variables,omitempty"`
			AdditionalProperties map[string]interface{}          `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteAppResponse parses an HTTP response from a DeleteAppWithResponse call
func ParseDeleteAppResponse(rsp *http.Response) (*DeleteAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeletedAppId An ID of deleted application.
			DeletedAppId         *string                `json:"deletedAppId,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppResponse parses an HTTP response from a GetAppWithResponse call
func ParseGetAppResponse(rsp *http.Response) (*GetAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AncestorId The id of the app from which this app was copied
			AncestorId *string `json:"ancestorId,omitempty"`

			// Created The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Created *string `json:"created,omitempty"`

			// DataClassification The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
			DataClassification *string `json:"dataClassification,omitempty"`

			// DateFormat A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app's date format.
			DateFormat *string `json:"dateFormat,omitempty"`

			// Description The description for the app. If this property is left out, the app description will be blank.
			Description *string `json:"description,omitempty"`

			// HasEveryoneOnTheInternet Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)
			HasEveryoneOnTheInternet *bool `json:"hasEveryoneOnTheInternet,omitempty"`

			// Id The unique identifier for this application.
			Id *string `json:"id,omitempty"`

			// MemoryInfo Application memory info
			MemoryInfo *struct {
				// EstMemory The estimated memory of this application in gigabytes
				EstMemory *float32 `json:"estMemory,omitempty"`

				// EstMemoryInclDependentApps The estimated memory of this application and all dependent applications in gigabytes
				EstMemoryInclDependentApps *float32 `json:"estMemoryInclDependentApps,omitempty"`
			} `json:"memoryInfo,omitempty"`

			// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
			Name string `json:"name"`

			// SecurityProperties Security properties of the application
			SecurityProperties *GetApp_200_SecurityProperties `json:"securityProperties,omitempty"`

			// TimeZone A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application's time zone.
			TimeZone *string `json:"timeZone,omitempty"`

			// Updated The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Updated *string `json:"updated,omitempty"`

			// Variables The app variables. See [About Application Variables](https://help.quickbase.com/docs/creating-and-using-application-variables)
			Variables            *[]GetApp_200_Variables_Item `json:"variables,omitempty"`
			AdditionalProperties map[string]interface{}       `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAppResponse parses an HTTP response from a UpdateAppWithResponse call
func ParseUpdateAppResponse(rsp *http.Response) (*UpdateAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AncestorId The id of the app from which this app was copied
			AncestorId *string `json:"ancestorId,omitempty"`

			// Created The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Created *string `json:"created,omitempty"`

			// DataClassification The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
			DataClassification *string `json:"dataClassification,omitempty"`

			// DateFormat A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app's date format.
			DateFormat *string `json:"dateFormat,omitempty"`

			// Description The description for the app. If this property is left out, the app description will be blank.
			Description *string `json:"description,omitempty"`

			// HasEveryoneOnTheInternet Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)
			HasEveryoneOnTheInternet *bool `json:"hasEveryoneOnTheInternet,omitempty"`

			// Id The unique identifier for this application.
			Id *string `json:"id,omitempty"`

			// MemoryInfo Application memory info
			MemoryInfo *struct {
				// EstMemory The estimated memory of this application in gigabytes
				EstMemory *float32 `json:"estMemory,omitempty"`

				// EstMemoryInclDependentApps The estimated memory of this application and all dependent applications in gigabytes
				EstMemoryInclDependentApps *float32 `json:"estMemoryInclDependentApps,omitempty"`
			} `json:"memoryInfo,omitempty"`

			// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
			Name string `json:"name"`

			// SecurityProperties Security properties of the application
			SecurityProperties *UpdateApp_200_SecurityProperties `json:"securityProperties,omitempty"`

			// TimeZone A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application's time zone.
			TimeZone *string `json:"timeZone,omitempty"`

			// Updated The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Updated *string `json:"updated,omitempty"`

			// Variables The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
			Variables            *[]UpdateApp_200_Variables_Item `json:"variables,omitempty"`
			AdditionalProperties map[string]interface{}          `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCopyAppResponse parses an HTTP response from a CopyAppWithResponse call
func ParseCopyAppResponse(rsp *http.Response) (*CopyAppResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CopyAppResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AncestorId The id of the app from which this app was copied
			AncestorId *string `json:"ancestorId,omitempty"`

			// Created The time and date the app was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Created *string `json:"created,omitempty"`

			// DataClassification The Data Classification label assigned to the application. If Data Classification is not turned on, this will not be returned. If Data Classification is turned on, but application is not labeled, we return None".  Data Classification labels can be added in the Admin Console by a Realm Administrator for Platform+ plans.
			DataClassification *string `json:"dataClassification,omitempty"`

			// DateFormat A description of the format used when displaying date values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the API Guide for how time values are returned in API calls. See [About Localizing Dates](https://help.quickbase.com/user-assistance/about_localizing_dates_numbers.html) to set the app's date format.
			DateFormat *string `json:"dateFormat,omitempty"`

			// Description The description for the app
			Description *string `json:"description,omitempty"`

			// HasEveryoneOnTheInternet Indicates whether app includes Everyone On The Internet access. See [Sharing apps with Everyone on the Internet (EOTI).](https://help.quickbase.com/user-assistance/share_with_everyone_on_internet.html)
			HasEveryoneOnTheInternet *bool `json:"hasEveryoneOnTheInternet,omitempty"`

			// Id The unique identifier for this application.
			Id *string `json:"id,omitempty"`

			// Name The app name. You are allowed to create multiple apps with the same name, in the same realm, because they will have different dbid values. We urge you to be careful about doing this.
			Name string `json:"name"`

			// TimeZone A description of the time zone used when displaying time values in this app. Note that this is a browser-only parameter - see the [Field type details](../fieldInfo) page in the portal for how time values are returned in API calls. See [Set the Time Zone for Both the Application and the Account](https://help.quickbase.com/user-assistance/application_local_timezone.html) to set the application's time zone.
			TimeZone *string `json:"timeZone,omitempty"`

			// Updated The time and date the app was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Updated *string `json:"updated,omitempty"`

			// Variables The app variables. See [About Application Variables](https://help.quickbase.com/user-assistance/variables.html)
			Variables            *[]CopyApp_200_Variables_Item `json:"variables,omitempty"`
			AdditionalProperties map[string]interface{}        `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppEventsResponse parses an HTTP response from a GetAppEventsWithResponse call
func ParseGetAppEventsResponse(rsp *http.Response) (*GetAppEventsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GetAppEvents_200_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRolesResponse parses an HTTP response from a GetRolesWithResponse call
func ParseGetRolesResponse(rsp *http.Response) (*GetRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GetRoles_200_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAuditResponse parses an HTTP response from a AuditWithResponse call
func ParseAuditResponse(rsp *http.Response) (*AuditResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AuditResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Events All events of the audit log.
			Events *[]Audit_200_Events_Item `json:"events,omitempty"`

			// NextToken Token to fetch the next 1000 logs.
			NextToken *string `json:"nextToken,omitempty"`

			// QueryId Query id of the requested audit log.
			QueryId              string                 `json:"queryId"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest struct {
			// QueryId Query id of the requested audit log.
			QueryId              string                 `json:"queryId"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseExchangeSsoTokenResponse parses an HTTP response from a ExchangeSsoTokenWithResponse call
func ParseExchangeSsoTokenResponse(rsp *http.Response) (*ExchangeSsoTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExchangeSsoTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccessToken The security token issued by the authorization server in response to the token exchange request. The identifier `access_token` is used for historical reasons and the issued token need not be an OAuth access token.
			AccessToken *string `json:"access_token,omitempty"`

			// IssuedTokenType An identifier for the representation of the issued security token.
			IssuedTokenType *ExchangeSsoToken200IssuedTokenType `json:"issued_token_type,omitempty"`

			// TokenType Will always return `N_A`
			TokenType            *ExchangeSsoToken200TokenType `json:"token_type,omitempty"`
			AdditionalProperties map[string]interface{}        `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTempTokenDBIDResponse parses an HTTP response from a GetTempTokenDBIDWithResponse call
func ParseGetTempTokenDBIDResponse(rsp *http.Response) (*GetTempTokenDBIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTempTokenDBIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// TemporaryAuthorization Temporary authorization token.
			TemporaryAuthorization *string                `json:"temporaryAuthorization,omitempty"`
			AdditionalProperties   map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGenerateDocumentResponse parses an HTTP response from a GenerateDocumentWithResponse call
func ParseGenerateDocumentResponse(rsp *http.Response) (*GenerateDocumentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateDocumentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ContentType The document content type.
			ContentType *string `json:"contentType,omitempty"`

			// Data Base64 encoded file content.
			Data *string `json:"data,omitempty"`

			// FileName The file name.
			FileName             *string                `json:"fileName,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFieldsResponse parses an HTTP response from a DeleteFieldsWithResponse call
func ParseDeleteFieldsResponse(rsp *http.Response) (*DeleteFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeletedFieldIds List of field IDs to were deleted.
			DeletedFieldIds []int `json:"deletedFieldIds"`

			// Errors List of errors found.
			Errors               []string               `json:"errors"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFieldsResponse parses an HTTP response from a GetFieldsWithResponse call
func ParseGetFieldsResponse(rsp *http.Response) (*GetFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GetFields_200_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFieldResponse parses an HTTP response from a CreateFieldWithResponse call
func ParseCreateFieldResponse(rsp *http.Response) (*CreateFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AppearsByDefault Indicates if the field is marked as a default in reports.
			AppearsByDefault *bool `json:"appearsByDefault,omitempty"`

			// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs.
			Audited *bool `json:"audited,omitempty"`

			// Bold Indicates if the field is configured to display in bold in the product.
			Bold *bool `json:"bold,omitempty"`

			// DoesDataCopy Indicates if the field data will copy when a user copies the record.
			DoesDataCopy *bool `json:"doesDataCopy,omitempty"`

			// FieldHelp The configured help text shown to users within the product.
			FieldHelp *string `json:"fieldHelp,omitempty"`

			// FieldType The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
			FieldType *string `json:"fieldType,omitempty"`

			// FindEnabled Indicates if the field is marked as searchable.
			FindEnabled *bool `json:"findEnabled,omitempty"`

			// Id The id of the field, unique to this table.
			Id int64 `json:"id"`

			// Label The label (name) of the field.
			Label *string `json:"label,omitempty"`

			// Mode For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
			Mode *string `json:"mode,omitempty"`

			// NoWrap Indicates if the field is configured to not wrap when displayed in the product.
			NoWrap *bool `json:"noWrap,omitempty"`

			// Permissions Field Permissions for different roles.
			Permissions *[]struct {
				// PermissionType The permission given to the role for this field
				PermissionType *string `json:"permissionType,omitempty"`

				// Role The role associated with a given permission for the field
				Role *string `json:"role,omitempty"`

				// RoleId The Id of the given role
				RoleId *int `json:"roleId,omitempty"`
			} `json:"permissions,omitempty"`

			// Properties Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
			Properties *CreateField_200_Properties `json:"properties,omitempty"`

			// Required Indicates if the field is marked required.
			Required *bool `json:"required,omitempty"`

			// Unique Indicates if the field is marked unique.
			Unique               *bool                  `json:"unique,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFieldsUsageResponse parses an HTTP response from a GetFieldsUsageWithResponse call
func ParseGetFieldsUsageResponse(rsp *http.Response) (*GetFieldsUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFieldsUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GetFieldsUsage_200_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFieldUsageResponse parses an HTTP response from a GetFieldUsageWithResponse call
func ParseGetFieldUsageResponse(rsp *http.Response) (*GetFieldUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFieldUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GetFieldUsage_200_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFieldResponse parses an HTTP response from a GetFieldWithResponse call
func ParseGetFieldResponse(rsp *http.Response) (*GetFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AppearsByDefault Indicates if the field is marked as a default in reports.
			AppearsByDefault *bool `json:"appearsByDefault,omitempty"`

			// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs.
			Audited *bool `json:"audited,omitempty"`

			// Bold Indicates if the field is configured to display in bold in the product.
			Bold *bool `json:"bold,omitempty"`

			// DoesDataCopy Indicates if the field data will copy when a user copies the record.
			DoesDataCopy *bool `json:"doesDataCopy,omitempty"`

			// FieldHelp The configured help text shown to users within the product.
			FieldHelp *string `json:"fieldHelp,omitempty"`

			// FieldType The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
			FieldType *string `json:"fieldType,omitempty"`

			// FindEnabled Indicates if the field is marked as searchable.
			FindEnabled *bool `json:"findEnabled,omitempty"`

			// Id The id of the field, unique to this table.
			Id int64 `json:"id"`

			// Label The label (name) of the field.
			Label *string `json:"label,omitempty"`

			// Mode For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
			Mode *string `json:"mode,omitempty"`

			// NoWrap Indicates if the field is configured to not wrap when displayed in the product.
			NoWrap *bool `json:"noWrap,omitempty"`

			// Permissions Field Permissions for different roles.
			Permissions *[]struct {
				// PermissionType The permission given to the role for this field
				PermissionType *string `json:"permissionType,omitempty"`

				// Role The role associated with a given permission for the field
				Role *string `json:"role,omitempty"`

				// RoleId The Id of the given role
				RoleId *int `json:"roleId,omitempty"`
			} `json:"permissions,omitempty"`

			// Properties Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
			Properties *GetField_200_Properties `json:"properties,omitempty"`

			// Required Indicates if the field is marked required.
			Required *bool `json:"required,omitempty"`

			// Unique Indicates if the field is marked unique.
			Unique               *bool                  `json:"unique,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateFieldResponse parses an HTTP response from a UpdateFieldWithResponse call
func ParseUpdateFieldResponse(rsp *http.Response) (*UpdateFieldResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFieldResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AppearsByDefault Indicates if the field is marked as a default in reports.
			AppearsByDefault *bool `json:"appearsByDefault,omitempty"`

			// Audited Indicates if the field is being tracked as part of Quickbase Audit Logs.
			Audited *bool `json:"audited,omitempty"`

			// Bold Indicates if the field is configured to display in bold in the product.
			Bold *bool `json:"bold,omitempty"`

			// DoesDataCopy Indicates if the field data will copy when a user copies the record.
			DoesDataCopy *bool `json:"doesDataCopy,omitempty"`

			// FieldHelp The configured help text shown to users within the product.
			FieldHelp *string `json:"fieldHelp,omitempty"`

			// FieldType The type of field, as described [here](https://help.quickbase.com/user-assistance/field_types.html).
			FieldType *string `json:"fieldType,omitempty"`

			// FindEnabled Indicates if the field is marked as searchable.
			FindEnabled *bool `json:"findEnabled,omitempty"`

			// Id The id of the field, unique to this table.
			Id int64 `json:"id"`

			// Label The label (name) of the field.
			Label *string `json:"label,omitempty"`

			// Mode For derived fields, this will be 'lookup', 'summary', or 'formula', to indicate the type of derived field.  For non-derived fields, this will be blank.
			Mode *string `json:"mode,omitempty"`

			// NoWrap Indicates if the field is configured to not wrap when displayed in the product.
			NoWrap *bool `json:"noWrap,omitempty"`

			// Permissions Field Permissions for different roles.
			Permissions *[]struct {
				// PermissionType The permission given to the role for this field
				PermissionType *string `json:"permissionType,omitempty"`

				// Role The role associated with a given permission for the field
				Role *string `json:"role,omitempty"`

				// RoleId The Id of the given role
				RoleId *int `json:"roleId,omitempty"`
			} `json:"permissions,omitempty"`

			// Properties Additional properties for the field. Please see [Field type details](../fieldInfo) page for more details on the properties for each field type.
			Properties *UpdateField_200_Properties `json:"properties,omitempty"`

			// Required Indicates if the field is marked required.
			Required *bool `json:"required,omitempty"`

			// Unique Indicates if the field is marked unique.
			Unique               *bool                  `json:"unique,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteFileResponse parses an HTTP response from a DeleteFileWithResponse call
func ParseDeleteFileResponse(rsp *http.Response) (*DeleteFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Creator The user that uploaded version.
			Creator *DeleteFile_200_Creator `json:"creator,omitempty"`

			// FileName The name of file associated with deleted version.
			FileName *string `json:"fileName,omitempty"`

			// Uploaded The timestamp when the version was originally uploaded.
			Uploaded *string `json:"uploaded,omitempty"`

			// VersionNumber The number of deleted version.
			VersionNumber        *int                   `json:"versionNumber,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadFileResponse parses an HTTP response from a DownloadFileWithResponse call
func ParseDownloadFileResponse(rsp *http.Response) (*DownloadFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunFormulaResponse parses an HTTP response from a RunFormulaWithResponse call
func ParseRunFormulaResponse(rsp *http.Response) (*RunFormulaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunFormulaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Result The formula execution result.
			Result               *string                `json:"result,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveManagersFromGroupResponse parses an HTTP response from a RemoveManagersFromGroupWithResponse call
func ParseRemoveManagersFromGroupResponse(rsp *http.Response) (*RemoveManagersFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveManagersFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of users that couldn't be removed from the group. This includes a list of IDs that represent invalid users.
			Failure []string `json:"failure"`

			// Success A list of users that have been removed from the group successfully.
			Success              []string               `json:"success"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddManagersToGroupResponse parses an HTTP response from a AddManagersToGroupWithResponse call
func ParseAddManagersToGroupResponse(rsp *http.Response) (*AddManagersToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddManagersToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of users that couldn't be added to the group. This includes a list of IDs that represent invalid users and users who have already been added to the group.
			Failure []string `json:"failure"`

			// Success A list of users that have been added to the group successfully.
			Success              []string               `json:"success"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveMembersFromGroupResponse parses an HTTP response from a RemoveMembersFromGroupWithResponse call
func ParseRemoveMembersFromGroupResponse(rsp *http.Response) (*RemoveMembersFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveMembersFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of users that couldn't be removed from the group. This includes a list of IDs that represent invalid users.
			Failure []string `json:"failure"`

			// Success A list of users that have been removed from the group successfully.
			Success              []string               `json:"success"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddMembersToGroupResponse parses an HTTP response from a AddMembersToGroupWithResponse call
func ParseAddMembersToGroupResponse(rsp *http.Response) (*AddMembersToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddMembersToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of users that couldn't be added to the group. This includes a list of IDs that represent invalid users and users who have already been added to the group.
			Failure []string `json:"failure"`

			// Success A list of users that have been added to the group successfully.
			Success              []string               `json:"success"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveSubgroupsFromGroupResponse parses an HTTP response from a RemoveSubgroupsFromGroupWithResponse call
func ParseRemoveSubgroupsFromGroupResponse(rsp *http.Response) (*RemoveSubgroupsFromGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveSubgroupsFromGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of child groups that couldn't be removed from the group. This includes a list of IDs that represent invalid groups.
			Failure []string `json:"failure"`

			// Success A list of child groups that have been removed from the group successfully.
			Success              []string               `json:"success"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddSubgroupsToGroupResponse parses an HTTP response from a AddSubgroupsToGroupWithResponse call
func ParseAddSubgroupsToGroupResponse(rsp *http.Response) (*AddSubgroupsToGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddSubgroupsToGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of child groups that couldn't be added to the group. This includes a list of IDs that represent invalid groups and groups that have already been added to the group.
			Failure []string `json:"failure"`

			// Success A list of child groups that have been added to the group successfully.
			Success              []string               `json:"success"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRecordsResponse parses an HTTP response from a DeleteRecordsWithResponse call
func ParseDeleteRecordsResponse(rsp *http.Response) (*DeleteRecordsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRecordsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NumberDeleted The number of records deleted.
			NumberDeleted        *int                   `json:"numberDeleted,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpsertResponse parses an HTTP response from a UpsertWithResponse call
func ParseUpsertResponse(rsp *http.Response) (*UpsertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpsertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data The data that is expected to be returned.
			Data *[]QuickbaseRecord `json:"data,omitempty"`

			// Metadata Information about created records, updated records, referenced but unchanged records, and records having any errors while being processed.
			Metadata             *Upsert_200_Metadata   `json:"metadata,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest struct {
			// Data The data that is expected to be returned.
			Data *[]interface{} `json:"data,omitempty"`

			// Metadata Information about created records, updated records, referenced but unchanged records, and records having any errors while being processed.
			Metadata             *Upsert_207_Metadata   `json:"metadata,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			// Description The description for the occurence of the error.
			Description *string `json:"description,omitempty"`

			// Message The type of error found.
			Message              *string                `json:"message,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseRecordsModifiedSinceResponse parses an HTTP response from a RecordsModifiedSinceWithResponse call
func ParseRecordsModifiedSinceResponse(rsp *http.Response) (*RecordsModifiedSinceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RecordsModifiedSinceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Changes When includeDetails is true, this array contains the individual record changes. If includeDetails is false, this array will not be returned.
			Changes *[]RecordsModifiedSince_200_Changes_Item `json:"changes,omitempty"`

			// Count The count of changes found.
			Count int `json:"count"`

			// DeletesTruncated When true, this indicates that the number of deletes detected exceeded the limit and details could not be returned.
			DeletesTruncated     *bool                  `json:"deletesTruncated,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunQueryResponse parses an HTTP response from a RunQueryWithResponse call
func ParseRunQueryResponse(rsp *http.Response) (*RunQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An array of objects that either represents the record data or summarized values, depending on the report type.
			Data *[]QuickbaseRecord `json:"data,omitempty"`

			// Fields An array of objects that contains limited meta-data of each field displayed in the report. This assists in building logic that depends on field types and IDs.
			Fields *[]RunQuery_200_Fields_Item `json:"fields,omitempty"`

			// Metadata Additional information about the results that may be helpful. Pagination may be needed if either you specify a smaller number of results to skip than is available, or if the API automatically returns fewer results. numRecords can be compared to totalRecords to determine if further pagination is needed.
			Metadata             *RunQuery_200_Metadata `json:"metadata,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTableReportsResponse parses an HTTP response from a GetTableReportsWithResponse call
func ParseGetTableReportsResponse(rsp *http.Response) (*GetTableReportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableReportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GetTableReports_200_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetReportResponse parses an HTTP response from a GetReportWithResponse call
func ParseGetReportResponse(rsp *http.Response) (*GetReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Description The configured description of a report.
			Description *string `json:"description,omitempty"`

			// Id The identifier of the report, unique to the table.
			Id *string `json:"id,omitempty"`

			// Name The configured name of the report.
			Name *string `json:"name,omitempty"`

			// OwnerId Optional, showed only for personal reports. The user ID of report owner.
			OwnerId *int `json:"ownerId,omitempty"`

			// Properties A list of properties specific to the report type. To see a detailed description of the properties for each report type, See [Report Types.](../reportTypes)
			Properties *map[string]interface{} `json:"properties,omitempty"`

			// Query The query definition as configured in Quickbase that gets executed when the report is run.
			Query *GetReport_200_Query `json:"query,omitempty"`

			// Type The type of report in Quickbase (e.g., chart).
			Type *string `json:"type,omitempty"`

			// UsedCount The number of times a report has been used.
			UsedCount *int `json:"usedCount,omitempty"`

			// UsedLast The instant at which a report was last used.
			UsedLast             *string                `json:"usedLast,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRunReportResponse parses an HTTP response from a RunReportWithResponse call
func ParseRunReportResponse(rsp *http.Response) (*RunReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data An array of objects that either represents the record data or summarized values, depending on the report type.
			Data *[]QuickbaseRecord `json:"data,omitempty"`

			// Fields An array of objects that contains limited meta-data of each field displayed in the report. This assists in building logic that depends on field types and IDs.
			Fields *[]RunReport_200_Fields_Item `json:"fields,omitempty"`

			// Metadata Additional information about the results that may be helpful. Pagination may be needed if either you specify a smaller number of results to skip than is available, or if the API automatically returns fewer results. numRecords can be compared to totalRecords to determine if further pagination is needed.
			Metadata             *RunReport_200_Metadata `json:"metadata,omitempty"`
			AdditionalProperties map[string]interface{}  `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSolutionResponse parses an HTTP response from a CreateSolutionWithResponse call
func ParseCreateSolutionResponse(rsp *http.Response) (*CreateSolutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSolutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateSolutionFromRecordResponse parses an HTTP response from a CreateSolutionFromRecordWithResponse call
func ParseCreateSolutionFromRecordResponse(rsp *http.Response) (*CreateSolutionFromRecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSolutionFromRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExportSolutionResponse parses an HTTP response from a ExportSolutionWithResponse call
func ParseExportSolutionResponse(rsp *http.Response) (*ExportSolutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSolutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSolutionResponse parses an HTTP response from a UpdateSolutionWithResponse call
func ParseUpdateSolutionResponse(rsp *http.Response) (*UpdateSolutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSolutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseChangesetSolutionResponse parses an HTTP response from a ChangesetSolutionWithResponse call
func ParseChangesetSolutionResponse(rsp *http.Response) (*ChangesetSolutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangesetSolutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseChangesetSolutionFromRecordResponse parses an HTTP response from a ChangesetSolutionFromRecordWithResponse call
func ParseChangesetSolutionFromRecordResponse(rsp *http.Response) (*ChangesetSolutionFromRecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangesetSolutionFromRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateSolutionToRecordResponse parses an HTTP response from a UpdateSolutionToRecordWithResponse call
func ParseUpdateSolutionToRecordResponse(rsp *http.Response) (*UpdateSolutionToRecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSolutionToRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSolutionPublicResponse parses an HTTP response from a GetSolutionPublicWithResponse call
func ParseGetSolutionPublicResponse(rsp *http.Response) (*GetSolutionPublicResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSolutionPublicResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExportSolutionToRecordResponse parses an HTTP response from a ExportSolutionToRecordWithResponse call
func ParseExportSolutionToRecordResponse(rsp *http.Response) (*ExportSolutionToRecordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportSolutionToRecordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAppTablesResponse parses an HTTP response from a GetAppTablesWithResponse call
func ParseGetAppTablesResponse(rsp *http.Response) (*GetAppTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GetAppTables_200_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateTableResponse parses an HTTP response from a CreateTableWithResponse call
func ParseCreateTableResponse(rsp *http.Response) (*CreateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Alias The automatically-created table alias for the table.
			Alias *string `json:"alias,omitempty"`

			// Created The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Created *string `json:"created,omitempty"`

			// DefaultSortFieldId The id of the field that is configured for default sorting.
			DefaultSortFieldId *int `json:"defaultSortFieldId,omitempty"`

			// DefaultSortOrder The configuration of the default sort order on the table.
			DefaultSortOrder *CreateTable200DefaultSortOrder `json:"defaultSortOrder,omitempty"`

			// Description The description of the table, as configured by an application administrator.
			Description *string `json:"description,omitempty"`

			// Id The unique identifier (dbid) of the table.
			Id *string `json:"id,omitempty"`

			// KeyFieldId The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
			KeyFieldId *int `json:"keyFieldId,omitempty"`

			// Name The name of the table.
			Name *string `json:"name,omitempty"`

			// NextFieldId The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
			NextFieldId *int `json:"nextFieldId,omitempty"`

			// NextRecordId The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
			NextRecordId *int `json:"nextRecordId,omitempty"`

			// PluralRecordName The builder-configured plural noun of the table.
			PluralRecordName *string `json:"pluralRecordName,omitempty"`

			// SingleRecordName The builder-configured singular noun of the table.
			SingleRecordName *string `json:"singleRecordName,omitempty"`

			// SizeLimit The size limit for the table.
			SizeLimit *string `json:"sizeLimit,omitempty"`

			// SpaceRemaining The amount of space remaining for use by the table.
			SpaceRemaining *string `json:"spaceRemaining,omitempty"`

			// SpaceUsed The amount of space currently being used by the table.
			SpaceUsed *string `json:"spaceUsed,omitempty"`

			// Updated The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Updated              *string                `json:"updated,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteTableResponse parses an HTTP response from a DeleteTableWithResponse call
func ParseDeleteTableResponse(rsp *http.Response) (*DeleteTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeletedTableId The deleted table id.
			DeletedTableId       *string                `json:"deletedTableId,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTableResponse parses an HTTP response from a GetTableWithResponse call
func ParseGetTableResponse(rsp *http.Response) (*GetTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Alias The automatically-created table alias for the table.
			Alias *string `json:"alias,omitempty"`

			// Created The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Created *string `json:"created,omitempty"`

			// DefaultSortFieldId The id of the field that is configured for default sorting.
			DefaultSortFieldId *int `json:"defaultSortFieldId,omitempty"`

			// DefaultSortOrder The configuration of the default sort order on the table.
			DefaultSortOrder *GetTable200DefaultSortOrder `json:"defaultSortOrder,omitempty"`

			// Description The description of the table, as configured by an application administrator.
			Description *string `json:"description,omitempty"`

			// Id The unique identifier (dbid) of the table.
			Id *string `json:"id,omitempty"`

			// KeyFieldId The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
			KeyFieldId *int `json:"keyFieldId,omitempty"`

			// Name The name of the table.
			Name *string `json:"name,omitempty"`

			// NextFieldId The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
			NextFieldId *int `json:"nextFieldId,omitempty"`

			// NextRecordId The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
			NextRecordId *int `json:"nextRecordId,omitempty"`

			// PluralRecordName The builder-configured plural noun of the table.
			PluralRecordName *string `json:"pluralRecordName,omitempty"`

			// SingleRecordName The builder-configured singular noun of the table.
			SingleRecordName *string `json:"singleRecordName,omitempty"`

			// SizeLimit The size limit for the table.
			SizeLimit *string `json:"sizeLimit,omitempty"`

			// SpaceRemaining The amount of space remaining for use by the table.
			SpaceRemaining *string `json:"spaceRemaining,omitempty"`

			// SpaceUsed The amount of space currently being used by the table.
			SpaceUsed *string `json:"spaceUsed,omitempty"`

			// Updated The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Updated              *string                `json:"updated,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateTableResponse parses an HTTP response from a UpdateTableWithResponse call
func ParseUpdateTableResponse(rsp *http.Response) (*UpdateTableResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTableResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Alias The automatically-created table alias for the table.
			Alias *string `json:"alias,omitempty"`

			// Created The time and date when the table was created, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Created *string `json:"created,omitempty"`

			// DefaultSortFieldId The id of the field that is configured for default sorting.
			DefaultSortFieldId *int `json:"defaultSortFieldId,omitempty"`

			// DefaultSortOrder The configuration of the default sort order on the table.
			DefaultSortOrder *UpdateTable200DefaultSortOrder `json:"defaultSortOrder,omitempty"`

			// Description The description of the table, as configured by an application administrator.
			Description *string `json:"description,omitempty"`

			// Id The unique identifier (dbid) of the table.
			Id *string `json:"id,omitempty"`

			// KeyFieldId The id of the field that is configured to be the key on this table, which is usually the Quickbase Record ID.
			KeyFieldId *int `json:"keyFieldId,omitempty"`

			// Name The name of the table.
			Name *string `json:"name,omitempty"`

			// NextFieldId The incremental Field ID that will be used when the next field is created, as determined when the API call was ran.
			NextFieldId *int `json:"nextFieldId,omitempty"`

			// NextRecordId The incremental Record ID that will be used when the next record is created, as determined when the API call was ran.
			NextRecordId *int `json:"nextRecordId,omitempty"`

			// PluralRecordName The builder-configured plural noun of the table.
			PluralRecordName *string `json:"pluralRecordName,omitempty"`

			// SingleRecordName The builder-configured singular noun of the table.
			SingleRecordName *string `json:"singleRecordName,omitempty"`

			// SizeLimit The size limit for the table.
			SizeLimit *string `json:"sizeLimit,omitempty"`

			// SpaceRemaining The amount of space remaining for use by the table.
			SpaceRemaining *string `json:"spaceRemaining,omitempty"`

			// SpaceUsed The amount of space currently being used by the table.
			SpaceUsed *string `json:"spaceUsed,omitempty"`

			// Updated The time and date when the table schema or data was last updated, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			Updated              *string                `json:"updated,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRelationshipResponse parses an HTTP response from a CreateRelationshipWithResponse call
func ParseCreateRelationshipResponse(rsp *http.Response) (*CreateRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ChildTableId The child table id of the relationship.
			ChildTableId string `json:"childTableId"`

			// ForeignKeyField The foreign key field information.
			ForeignKeyField *CreateRelationship_200_ForeignKeyField `json:"foreignKeyField,omitempty"`

			// Id The relationship id (foreign key field id).
			Id int `json:"id"`

			// IsCrossApp Whether this is a cross-app relationship.
			IsCrossApp bool `json:"isCrossApp"`

			// LookupFields The lookup fields array.
			LookupFields *[]CreateRelationship_200_LookupFields_Item `json:"lookupFields,omitempty"`

			// ParentTableId The parent table id of the relationship.
			ParentTableId string `json:"parentTableId"`

			// SummaryFields The summary fields array.
			SummaryFields        *[]CreateRelationship_200_SummaryFields_Item `json:"summaryFields,omitempty"`
			AdditionalProperties map[string]interface{}                       `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteRelationshipResponse parses an HTTP response from a DeleteRelationshipWithResponse call
func ParseDeleteRelationshipResponse(rsp *http.Response) (*DeleteRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// RelationshipId The relationship id.
			RelationshipId       int                    `json:"relationshipId"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRelationshipResponse parses an HTTP response from a UpdateRelationshipWithResponse call
func ParseUpdateRelationshipResponse(rsp *http.Response) (*UpdateRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ChildTableId The child table id of the relationship.
			ChildTableId string `json:"childTableId"`

			// ForeignKeyField The foreign key field information.
			ForeignKeyField *UpdateRelationship_200_ForeignKeyField `json:"foreignKeyField,omitempty"`

			// Id The relationship id (foreign key field id).
			Id int `json:"id"`

			// IsCrossApp Whether this is a cross-app relationship.
			IsCrossApp bool `json:"isCrossApp"`

			// LookupFields The lookup fields array.
			LookupFields *[]UpdateRelationship_200_LookupFields_Item `json:"lookupFields,omitempty"`

			// ParentTableId The parent table id of the relationship.
			ParentTableId string `json:"parentTableId"`

			// SummaryFields The summary fields array.
			SummaryFields        *[]UpdateRelationship_200_SummaryFields_Item `json:"summaryFields,omitempty"`
			AdditionalProperties map[string]interface{}                       `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRelationshipsResponse parses an HTTP response from a GetRelationshipsWithResponse call
func ParseGetRelationshipsResponse(rsp *http.Response) (*GetRelationshipsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRelationshipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Metadata Additional information about the results that may be helpful.
			Metadata *GetRelationships_200_Metadata `json:"metadata,omitempty"`

			// Relationships The relationships in a table.
			Relationships        []GetRelationships_200_Relationships_Item `json:"relationships"`
			AdditionalProperties map[string]interface{}                    `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Metadata Additional request information
			Metadata GetUsers_200_Metadata `json:"metadata"`

			// Users A list of users found in an account with the given criterias
			Users                []GetUsers_200_Users_Item `json:"users"`
			AdditionalProperties map[string]interface{}    `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDenyUsersResponse parses an HTTP response from a DenyUsersWithResponse call
func ParseDenyUsersResponse(rsp *http.Response) (*DenyUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DenyUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of users that couldn't be denied. This also includes the ID's of users that are not valid.
			Failure []string `json:"failure"`

			// Success A list of users that have successfully been denied.
			Success              []string               `json:"success"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDenyUsersAndGroupsResponse parses an HTTP response from a DenyUsersAndGroupsWithResponse call
func ParseDenyUsersAndGroupsResponse(rsp *http.Response) (*DenyUsersAndGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DenyUsersAndGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of users that couldn't be denied. This also includes the ID's of users that are not valid.
			Failure []string `json:"failure"`

			// Success A list of users that have successfully been denied.
			Success              []string               `json:"success"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUndenyUsersResponse parses an HTTP response from a UndenyUsersWithResponse call
func ParseUndenyUsersResponse(rsp *http.Response) (*UndenyUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UndenyUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Failure A list of users that couldn't be undenied. This also includes the ID's of users that are not valid.
			Failure []string `json:"failure"`

			// Success A list of users that have successfully been undenied.
			Success              []string               `json:"success"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserTokenResponse parses an HTTP response from a DeleteUserTokenWithResponse call
func ParseDeleteUserTokenResponse(rsp *http.Response) (*DeleteUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The user token id.
			Id                   *int                   `json:"id,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCloneUserTokenResponse parses an HTTP response from a CloneUserTokenWithResponse call
func ParseCloneUserTokenResponse(rsp *http.Response) (*CloneUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CloneUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Active Whether the user token is active.
			Active *bool `json:"active,omitempty"`

			// Apps The list of apps this user token is assigned to.
			Apps *[]CloneUserToken_200_Apps_Item `json:"apps,omitempty"`

			// Description User Token description.
			Description *string `json:"description,omitempty"`

			// Id User Token id.
			Id *int `json:"id,omitempty"`

			// LastUsed The last date this user token was used, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			LastUsed *string `json:"lastUsed,omitempty"`

			// Name User Token name.
			Name *string `json:"name,omitempty"`

			// Token User Token value.
			Token                *string                `json:"token,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeactivateUserTokenResponse parses an HTTP response from a DeactivateUserTokenWithResponse call
func ParseDeactivateUserTokenResponse(rsp *http.Response) (*DeactivateUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeactivateUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id The user token id.
			Id                   *int                   `json:"id,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseTransferUserTokenResponse parses an HTTP response from a TransferUserTokenWithResponse call
func ParseTransferUserTokenResponse(rsp *http.Response) (*TransferUserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferUserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Active Whether the user token is active.
			Active *bool `json:"active,omitempty"`

			// Apps The list of apps this user token is assigned to.
			Apps *[]TransferUserToken_200_Apps_Item `json:"apps,omitempty"`

			// Description User Token description.
			Description *string `json:"description,omitempty"`

			// Id User Token id.
			Id *int `json:"id,omitempty"`

			// LastUsed The last date this user token was used, in the ISO 8601 time format YYYY-MM-DDThh:mm:ss.sssZ (in UTC time zone).
			LastUsed *string `json:"lastUsed,omitempty"`

			// Name User Token name.
			Name                 *string                `json:"name,omitempty"`
			AdditionalProperties map[string]interface{} `json:"-"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
